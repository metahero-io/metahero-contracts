{
  "language": "Solidity",
  "sources": {
    "src/HEROToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./access/Controlled.sol\";\nimport \"./access/Owned.sol\";\nimport \"./erc20/ERC20.sol\";\nimport \"./lifecycle/Initializable.sol\";\nimport \"./math/MathLib.sol\";\nimport \"./math/SafeMathLib.sol\";\nimport \"./HEROLPManager.sol\";\n\n\n/**\n * @title HERO token\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract HEROToken is Controlled, Owned, ERC20, Initializable {\n  using MathLib for uint256;\n  using SafeMathLib for uint256;\n\n  struct Fees {\n    uint256 sender; // percent\n    uint256 recipient; // percent\n  }\n\n  struct Settings {\n    Fees burnFees;\n    Fees lpFees;\n    Fees rewardsFees;\n    uint256 minTotalSupply;\n  }\n\n  struct Summary {\n    uint256 totalExcluded;\n    uint256 totalHolding;\n    uint256 totalRewards;\n    uint256 totalSupply;\n  }\n\n  struct ExcludedAccount {\n    bool exists;\n    bool excludeSenderFromFee;\n    bool excludeRecipientFromFee;\n  }\n\n  // metadata\n\n  string private constant TOKEN_NAME = \"Metahero\";\n  string private constant TOKEN_SYMBOL = \"HERO\";\n  uint8 private constant TOKEN_DECIMALS = 18; // 0.000000000000000000\n\n  HEROLPManager public lpManager;\n  Settings public settings;\n  Summary public summary;\n  bool public presaleFinished;\n\n  mapping (address => uint256) private accountBalances;\n  mapping (address => mapping (address => uint256)) private accountAllowances;\n  mapping (address => ExcludedAccount) private excludedAccounts;\n\n  // events\n\n  event PresaleFinished();\n\n  event AccountExcluded(\n    address indexed account,\n    bool excludeSenderFromFee,\n    bool excludeRecipientFromFee\n  );\n\n  event TotalRewardsUpdated(\n    uint256 totalRewards\n  );\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    Controlled()\n    Owned()\n    ERC20(TOKEN_NAME, TOKEN_SYMBOL, TOKEN_DECIMALS)\n    Initializable()\n  {\n    //\n  }\n\n  // external functions\n\n  function initialize(\n    Fees memory burnFees,\n    Fees memory lpFees,\n    Fees memory rewardsFees,\n    uint256 minTotalSupply,\n    address payable lpManager_,\n    address controller_,\n    uint256 totalSupply_,\n    address[] calldata excludedAccounts_\n  )\n    external\n    onlyInitializer\n  {\n    settings.burnFees = burnFees;\n    settings.lpFees = lpFees;\n    settings.rewardsFees = rewardsFees;\n    settings.minTotalSupply = minTotalSupply;\n\n    if (\n      lpFees.sender != 0 ||\n      lpFees.recipient != 0\n    ) {\n      require(\n        lpManager_ != address(0),\n        \"HEROToken#1\"\n      );\n\n      lpManager = HEROLPManager(lpManager_);\n\n      _excludeAccount(lpManager_, false, false);\n    }\n\n    _initializeController(controller_);\n\n    if (totalSupply_ != 0) {\n      _excludeAccount(msg.sender, true, true);\n\n      _mint(\n        msg.sender,\n        totalSupply_\n      );\n    }\n\n    uint256 excludedAccountsLen = excludedAccounts_.length;\n\n    for (uint256 index; index < excludedAccountsLen; index++) {\n      _excludeAccount(excludedAccounts_[index], false, false);\n    }\n  }\n\n  function finishPresale()\n    external\n    onlyOwner\n  {\n    require(\n      !presaleFinished,\n      \"HEROToken#2\"\n    );\n\n    presaleFinished = true;\n\n    emit PresaleFinished();\n  }\n\n  function excludeAccount(\n    address account,\n    bool excludeSenderFromFee,\n    bool excludeRecipientFromFee\n  )\n    external\n    onlyOwner\n  {\n    _excludeAccount(\n      account,\n      excludeSenderFromFee,\n      excludeRecipientFromFee\n    );\n  }\n\n  function approve(\n    address spender,\n    uint256 amount\n  )\n    external\n    override\n    returns (bool)\n  {\n    _approve(\n      msg.sender,\n      spender,\n      amount\n    );\n\n    return true;\n  }\n\n  function mint(\n    address account,\n    uint256 amount\n  )\n    external\n    onlyController\n  {\n    _mint(\n      account,\n      amount\n    );\n  }\n\n  function burn(\n    uint256 amount\n  )\n    external\n  {\n    _burn(\n      msg.sender,\n      amount\n    );\n  }\n\n  function transfer(\n    address recipient,\n    uint256 amount\n  )\n    external\n    override\n    returns (bool)\n  {\n    _transfer(\n      msg.sender,\n      recipient,\n      amount\n    );\n\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    external\n    override\n    returns (bool)\n  {\n    _transfer(\n      sender,\n      recipient,\n      amount\n    );\n\n    uint256 allowance = accountAllowances[sender][msg.sender];\n\n    require(\n      allowance >= amount,\n      \"HEROToken#3\"\n    );\n\n    _approve(\n      sender,\n      msg.sender,\n      allowance.sub(amount)\n    );\n\n    return true;\n  }\n\n  // external functions (views)\n\n  function totalSupply()\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return summary.totalSupply;\n  }\n\n  function allowance(\n    address owner,\n    address spender\n  )\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return accountAllowances[owner][spender];\n  }\n\n  function balanceOf(\n    address account\n  )\n    external\n    view\n    override\n    returns (uint256 result)\n  {\n    result = accountBalances[account].add(\n      _calcRewards(account)\n    );\n\n    return result;\n  }\n\n  function getBalanceSummary(\n    address account\n  )\n    external\n    view\n    returns (\n      uint256 totalBalance,\n      uint256 holdingBalance,\n      uint256 totalRewards\n    )\n  {\n    holdingBalance = accountBalances[account];\n    totalRewards = _calcRewards(account);\n    totalBalance = holdingBalance.add(totalRewards);\n\n    return (totalBalance, holdingBalance, totalRewards);\n  }\n\n  // private functions\n\n  function _excludeAccount(\n    address account,\n    bool excludeSenderFromFee,\n    bool excludeRecipientFromFee\n  )\n    private\n  {\n    require(\n      account != address(0),\n      \"HEROToken#4\"\n    );\n\n    if (excludedAccounts[account].exists) {\n      require(\n        excludedAccounts[account].excludeSenderFromFee != excludeSenderFromFee ||\n        excludedAccounts[account].excludeRecipientFromFee != excludeRecipientFromFee,\n        \"HEROToken#5\"\n      );\n\n      excludedAccounts[account].excludeSenderFromFee = excludeSenderFromFee;\n      excludedAccounts[account].excludeRecipientFromFee = excludeRecipientFromFee;\n    } else {\n      require(\n        accountBalances[account] == 0,\n        \"HEROToken#6\"\n      );\n\n      excludedAccounts[account].exists = true;\n      excludedAccounts[account].excludeSenderFromFee = excludeSenderFromFee;\n      excludedAccounts[account].excludeRecipientFromFee = excludeRecipientFromFee;\n    }\n\n    emit AccountExcluded(\n      account,\n      excludeSenderFromFee,\n      excludeRecipientFromFee\n    );\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      owner != address(0),\n      \"HEROToken#7\"\n    );\n\n    require(\n      spender != address(0),\n      \"HEROToken#8\"\n    );\n\n    accountAllowances[owner][spender] = amount;\n\n    emit Approval(\n      owner,\n      spender,\n      amount\n    );\n  }\n\n  function _mint(\n    address account,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      account != address(0),\n      \"HEROToken#9\"\n    );\n\n    require(\n      amount != 0,\n      \"HEROToken#10\"\n    );\n\n    require(\n      excludedAccounts[account].exists,\n      \"HEROToken#11\"\n    );\n\n    summary.totalSupply = summary.totalSupply.add(amount);\n    summary.totalExcluded = summary.totalExcluded.add(amount);\n\n    accountBalances[account] = accountBalances[account].add(amount);\n\n    _emitTransfer(\n      address(0),\n      account,\n      amount\n    );\n  }\n\n  function _burn(\n    address account,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      account != address(0),\n      \"HEROToken#12\"\n    );\n\n    require(\n      amount != 0,\n      \"HEROToken#13\"\n    );\n\n    require(\n      accountBalances[account] >= amount,\n      \"HEROToken#14\"\n    );\n\n    require(\n      excludedAccounts[account].exists,\n      \"HEROToken#15\"\n    );\n\n    uint256 totalSupply_ = summary.totalSupply.sub(amount);\n\n    if (settings.minTotalSupply != 0) {\n      require(\n        totalSupply_ >= settings.minTotalSupply,\n        \"HEROToken#16\"\n      );\n    }\n\n    accountBalances[account] = accountBalances[account].sub(amount);\n\n    summary.totalSupply = totalSupply_;\n    summary.totalExcluded = summary.totalExcluded.sub(amount);\n\n    _emitTransfer(\n      account,\n      address(0),\n      amount\n    );\n  }\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      sender != address(0),\n      \"HEROToken#17\"\n    );\n\n    require(\n      recipient != address(0),\n      \"HEROToken#18\"\n    );\n\n    require(\n      amount != 0,\n      \"HEROToken#19\"\n    );\n\n    require(\n      excludedAccounts[sender].exists ||\n      presaleFinished,\n      \"HEROToken#20\"\n    );\n\n    if (sender == recipient) {\n      _syncLP();\n\n      _emitTransfer(\n        sender,\n        recipient,\n        0\n      );\n    } else if (\n      !excludedAccounts[sender].exists &&\n      !excludedAccounts[recipient].exists\n    ) {\n      _transferBetweenHolderAccounts(\n        sender,\n        recipient,\n        amount\n      );\n    } else if (\n      excludedAccounts[sender].exists &&\n      !excludedAccounts[recipient].exists\n    ) {\n      _transferFromExcludedAccount(\n        sender,\n        recipient,\n        amount\n      );\n    } else if (\n      !excludedAccounts[sender].exists &&\n      excludedAccounts[recipient].exists\n    ) {\n      _transferToExcludedAccount(\n        sender,\n        recipient,\n        amount\n      );\n    } else {\n      _transferBetweenExcludedAccounts(\n        sender,\n        recipient,\n        amount\n      );\n    }\n  }\n\n  function _transferBetweenHolderAccounts(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    uint256 senderAmount;\n    uint256 senderBurnFee;\n    uint256 senderLpFee;\n\n    uint256 recipientAmount;\n    uint256 recipientBurnFee;\n    uint256 recipientLpFee;\n\n    uint256 totalSupply_ = summary.totalSupply;\n    uint256 totalFee;\n\n    {\n      uint256 senderTotalFee;\n      uint256 recipientTotalFee;\n\n      (\n        senderTotalFee,\n        senderBurnFee,\n        senderLpFee\n      ) = _calcTransferSenderFees(amount);\n\n      (\n        totalSupply_,\n        senderTotalFee,\n        senderBurnFee\n      ) = _matchTotalSupplyWithFees(totalSupply_, senderTotalFee, senderBurnFee);\n\n      (\n        recipientTotalFee,\n        recipientBurnFee,\n        recipientLpFee\n      ) = _calcTransferRecipientFees(amount);\n\n      (\n        totalSupply_,\n        recipientTotalFee,\n        recipientBurnFee\n      ) = _matchTotalSupplyWithFees(totalSupply_, recipientTotalFee, recipientBurnFee);\n\n      totalFee = senderTotalFee.add(recipientTotalFee);\n      senderAmount = amount.add(senderTotalFee);\n      recipientAmount = amount.sub(recipientTotalFee);\n    }\n\n    if (summary.totalRewards != 0) {\n      uint256 totalHoldingWithRewards = summary.totalHolding.add(\n        summary.totalRewards\n      );\n\n      senderAmount = senderAmount.mul(summary.totalHolding).div(\n        totalHoldingWithRewards\n      );\n      recipientAmount = recipientAmount.mul(summary.totalHolding).div(\n        totalHoldingWithRewards\n      );\n      totalFee = totalFee.mul(summary.totalHolding).div(\n        totalHoldingWithRewards\n      );\n    }\n\n    require(\n      accountBalances[sender] >= senderAmount,\n      \"HEROToken#21\"\n    );\n\n    accountBalances[sender] = accountBalances[sender].sub(senderAmount);\n    accountBalances[recipient] = accountBalances[recipient].add(recipientAmount);\n\n    summary.totalSupply = totalSupply_;\n    summary.totalHolding = summary.totalHolding.sub(totalFee);\n\n    _increaseTotalLP(senderLpFee.add(recipientLpFee));\n\n    // emits events\n\n    _emitTransfer(\n      sender,\n      recipient,\n      amount\n    );\n\n    _emitTransfer(\n      sender,\n      address(0),\n      senderBurnFee\n    );\n\n    _emitTransfer(\n      sender,\n      address(lpManager),\n      senderLpFee\n    );\n\n    _emitTransfer(\n      recipient,\n      address(0),\n      recipientBurnFee\n    );\n\n    _emitTransfer(\n      recipient,\n      address(lpManager),\n      recipientLpFee\n    );\n\n    _updateTotalRewards();\n\n    _syncLP();\n  }\n\n  function _transferFromExcludedAccount(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      accountBalances[sender] >= amount,\n      \"HEROToken#22\"\n    );\n\n    (\n      bool shouldSyncLPBefore,\n      bool shouldSyncLPAfter\n    ) = _canSyncLP(\n      sender,\n      address(0)\n    );\n\n    if (shouldSyncLPBefore) {\n      lpManager.syncLP();\n    }\n\n    uint256 recipientTotalFee;\n    uint256 recipientBurnFee;\n    uint256 recipientLPFee;\n\n    uint256 totalSupply_ = summary.totalSupply;\n\n    if (!excludedAccounts[sender].excludeRecipientFromFee) {\n      (\n        recipientTotalFee,\n        recipientBurnFee,\n        recipientLPFee\n      ) = _calcTransferRecipientFees(amount);\n\n      (\n        totalSupply_,\n        recipientTotalFee,\n        recipientBurnFee\n      ) = _matchTotalSupplyWithFees(totalSupply_, recipientTotalFee, recipientBurnFee);\n    }\n\n    uint256 recipientAmount = amount.sub(recipientTotalFee);\n\n    accountBalances[sender] = accountBalances[sender].sub(amount);\n    accountBalances[recipient] = accountBalances[recipient].add(recipientAmount);\n\n    summary.totalSupply = totalSupply_;\n    summary.totalExcluded = summary.totalExcluded.sub(amount);\n    summary.totalHolding = summary.totalHolding.add(recipientAmount);\n\n    _increaseTotalLP(recipientLPFee);\n\n    // emits events\n\n    _emitTransfer(\n      sender,\n      recipient,\n      amount\n    );\n\n    _emitTransfer(\n      recipient,\n      address(0),\n      recipientBurnFee\n    );\n\n    _emitTransfer(\n      recipient,\n      address(lpManager),\n      recipientLPFee\n    );\n\n    _updateTotalRewards();\n\n    if (shouldSyncLPAfter) {\n      lpManager.syncLP();\n    }\n  }\n\n  function _transferToExcludedAccount(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    (\n      bool shouldSyncLPBefore,\n      bool shouldSyncLPAfter\n    ) = _canSyncLP(\n      address(0),\n      recipient\n    );\n\n    if (shouldSyncLPBefore) {\n      lpManager.syncLP();\n    }\n\n    uint256 senderTotalFee;\n    uint256 senderBurnFee;\n    uint256 senderLpFee;\n\n    uint256 totalSupply_ = summary.totalSupply;\n\n    if (!excludedAccounts[recipient].excludeSenderFromFee) {\n      (\n        senderTotalFee,\n        senderBurnFee,\n        senderLpFee\n      ) = _calcTransferSenderFees(amount);\n\n      (\n        totalSupply_,\n        senderTotalFee,\n        senderBurnFee\n      ) = _matchTotalSupplyWithFees(totalSupply_, senderTotalFee, senderBurnFee);\n    }\n\n    uint256 senderAmount = amount.add(senderTotalFee);\n\n    if (summary.totalRewards != 0) {\n      uint256 totalHoldingWithRewards = summary.totalHolding.add(\n        summary.totalRewards\n      );\n\n      senderAmount = senderAmount.mul(summary.totalHolding).div(\n        totalHoldingWithRewards\n      );\n    }\n\n    require(\n      accountBalances[sender] >= senderAmount,\n      \"HEROToken#23\"\n    );\n\n    accountBalances[sender] = accountBalances[sender].sub(senderAmount);\n    accountBalances[recipient] = accountBalances[recipient].add(amount);\n\n    summary.totalSupply = totalSupply_;\n    summary.totalExcluded = summary.totalExcluded.add(amount);\n    summary.totalHolding = summary.totalHolding.sub(senderAmount);\n\n    _increaseTotalLP(senderLpFee);\n\n    // emits events\n\n    _emitTransfer(\n      sender,\n      recipient,\n      amount\n    );\n\n    _emitTransfer(\n      sender,\n      address(0),\n      senderBurnFee\n    );\n\n    _emitTransfer(\n      sender,\n      address(lpManager),\n      senderLpFee\n    );\n\n    _updateTotalRewards();\n\n    if (shouldSyncLPAfter) {\n      lpManager.syncLP();\n    }\n  }\n\n  function _transferBetweenExcludedAccounts(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      accountBalances[sender] >= amount,\n      \"HEROToken#24\"\n    );\n\n    (\n      bool shouldSyncLPBefore,\n      bool shouldSyncLPAfter\n    ) = _canSyncLP(\n      address(0),\n      recipient\n    );\n\n    if (shouldSyncLPBefore) {\n      lpManager.syncLP();\n    }\n\n    accountBalances[sender] = accountBalances[sender].sub(amount);\n    accountBalances[recipient] = accountBalances[recipient].add(amount);\n\n    _emitTransfer(\n      sender,\n      recipient,\n      amount\n    );\n\n    if (shouldSyncLPAfter) {\n      lpManager.syncLP();\n    }\n  }\n\n  function _emitTransfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    if (amount != 0) {\n      emit Transfer(\n        sender,\n        recipient,\n        amount\n      );\n    }\n  }\n\n  function _increaseTotalLP(\n    uint256 amount\n  )\n    private\n  {\n    if (amount != 0) {\n      accountBalances[address(lpManager)] = accountBalances[address(lpManager)].add(amount);\n\n      summary.totalExcluded = summary.totalExcluded.add(amount);\n    }\n  }\n\n  function _syncLP()\n    private\n  {\n    if (address(lpManager) != address(0)) {\n      lpManager.syncLP();\n    }\n  }\n\n  function _updateTotalRewards()\n    private\n  {\n    uint256 totalRewards = summary.totalSupply\n    .sub(summary.totalExcluded)\n    .sub(summary.totalHolding);\n\n    if (totalRewards != summary.totalRewards) {\n      summary.totalRewards = totalRewards;\n\n      emit TotalRewardsUpdated(\n        totalRewards\n      );\n    }\n  }\n\n  // private functions (views)\n\n  function _matchTotalSupplyWithFees(\n    uint256 totalSupply_,\n    uint256 totalFee,\n    uint256 burnFee\n  )\n    private\n    view\n    returns (uint256, uint256, uint256)\n  {\n    if (burnFee != 0 && settings.minTotalSupply != 0) {\n      uint256 newTotalSupply = totalSupply_.sub(burnFee);\n\n      if (newTotalSupply >= settings.minTotalSupply) {\n        totalSupply_ = newTotalSupply;\n      } else  {\n        totalFee = totalFee.sub(burnFee);\n        burnFee = 0;\n      }\n    }\n\n    return (totalSupply_, totalFee, burnFee);\n  }\n\n  function _canSyncLP(\n    address sender,\n    address recipient\n  )\n    private\n    view\n    returns (\n      bool shouldSyncLPBefore,\n      bool shouldSyncLPAfter\n    )\n  {\n    if (address(lpManager) != address(0)) {\n      (shouldSyncLPBefore, shouldSyncLPAfter) = lpManager.canSyncLP(\n        sender,\n        recipient\n      );\n    }\n\n    return (shouldSyncLPBefore, shouldSyncLPAfter);\n  }\n\n  function _calcRewards(\n    address account\n  )\n    private\n    view\n    returns (uint256 result)\n  {\n    if (\n      !excludedAccounts[account].exists &&\n      summary.totalRewards != 0\n    ) {\n      result = summary.totalRewards\n        .mul(accountBalances[account])\n        .div(summary.totalHolding);\n    }\n\n    return result;\n  }\n\n  function _calcTransferSenderFees(\n    uint256 amount\n  )\n    private\n    view\n    returns (\n      uint256 totalFee,\n      uint256 burnFee,\n      uint256 lpFee\n    )\n  {\n    uint256 rewardsFee = amount.percent(settings.rewardsFees.sender);\n\n    lpFee = amount.percent(settings.lpFees.sender);\n    burnFee = amount.percent(settings.burnFees.sender);\n\n    totalFee = lpFee.add(rewardsFee).add(burnFee);\n\n    return (totalFee, burnFee, lpFee);\n  }\n\n  function _calcTransferRecipientFees(\n    uint256 amount\n  )\n    private\n    view\n    returns (\n      uint256 totalFee,\n      uint256 burnFee,\n      uint256 lpFee\n    )\n  {\n    uint256 rewardsFee = amount.percent(settings.rewardsFees.recipient);\n\n    lpFee = amount.percent(settings.lpFees.recipient);\n    burnFee = amount.percent(settings.burnFees.recipient);\n\n    totalFee = lpFee.add(rewardsFee).add(burnFee);\n\n    return (totalFee, burnFee, lpFee);\n  }\n}\n"
    },
    "src/access/Controlled.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Controlled\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract Controlled {\n  address public controller;\n\n  // modifiers\n\n  modifier onlyController() {\n    require(\n      msg.sender == controller,\n      \"Controlled#1\"\n    );\n\n    _;\n  }\n\n  // events\n\n  event ControllerUpdated(\n    address controller\n  );\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor()\n    internal\n  {\n    //\n  }\n\n  // internal functions\n\n  function _initializeController(\n    address controller_\n  )\n    internal\n  {\n    controller = controller_;\n  }\n\n  function _setController(\n    address controller_\n  )\n    internal\n  {\n    require(\n      controller_ != address(0),\n      \"Controlled#2\"\n    );\n\n    require(\n      controller_ != controller,\n      \"Controlled#3\"\n    );\n\n    controller = controller_;\n\n    emit ControllerUpdated(\n      controller_\n    );\n  }\n\n  function _removeController()\n    internal\n  {\n    require(\n      controller != address(0),\n      \"Controlled#4\"\n    );\n\n    controller = address(0);\n\n    emit ControllerUpdated(\n      address(0)\n    );\n  }\n}\n"
    },
    "src/access/Owned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Owned\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract Owned {\n  address public owner;\n\n  // modifiers\n\n  modifier onlyOwner() {\n    require(\n      msg.sender == owner,\n      \"Owned#1\"\n    );\n\n    _;\n  }\n\n  // events\n\n  event OwnerUpdated(\n    address owner\n  );\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor()\n    internal\n  {\n    owner = msg.sender;\n  }\n\n  // external functions\n\n  function setOwner(\n    address owner_\n  )\n    external\n    onlyOwner\n  {\n    require(\n      owner_ != address(0),\n      \"Owned#2\"\n    );\n\n    require(\n      owner_ != owner,\n      \"Owned#3\"\n    );\n\n    owner = owner_;\n\n    emit OwnerUpdated(\n      owner_\n    );\n  }\n}\n"
    },
    "src/erc20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./ERC20Standard.sol\";\n\n\n/**\n * @title ERC20 abstract token\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\nabstract contract ERC20 is ERC20Standard {\n  string public override name;\n  string public override symbol;\n  uint8 public override decimals;\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor (\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  )\n    internal\n  {\n    name = name_;\n    symbol = symbol_;\n    decimals = decimals_;\n  }\n}\n"
    },
    "src/lifecycle/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Initializable\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract Initializable {\n  address private initializer;\n\n  // events\n\n  event Initialized();\n\n  // modifiers\n\n  modifier onlyInitializer() {\n    require(\n      initializer != address(0),\n      \"Initializable#1\"\n    );\n\n    require(\n      msg.sender == initializer,\n      \"Initializable#2\"\n    );\n\n    initializer = address(0);\n\n    _;\n\n    emit Initialized();\n  }\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor()\n    internal\n  {\n    initializer = msg.sender;\n  }\n\n  // external functions (views)\n\n  function initialized()\n    external\n    view\n    returns (bool)\n  {\n    return initializer == address(0);\n  }\n}\n"
    },
    "src/math/MathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./SafeMathLib.sol\";\n\n\n/**\n * @title Math library\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\nlibrary MathLib {\n  using SafeMathLib for uint256;\n\n  // internal functions (pure)\n\n  function percent(\n    uint256 a,\n    uint256 p\n  )\n    internal\n    pure\n    returns (uint256 result)\n  {\n    if (a != 0 && p != 0) {\n      result = a.mul(p).div(100);\n    }\n\n    return result;\n  }\n}\n"
    },
    "src/math/SafeMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Safe math library\n *\n * @notice Based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5fe8f4e93bd1d4f5cc9a6899d7f24f5ffe4c14aa/contracts/math/SafeMath.sol\n */\nlibrary SafeMathLib {\n  // internal functions (pure)\n\n  function add(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    uint256 c = a + b;\n\n    require(\n      c >= a,\n      \"SafeMathLib#1\"\n    );\n\n    return c;\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    require(\n      b <= a,\n      \"SafeMathLib#2\"\n    );\n\n    return a - b;\n  }\n\n  function mul(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256 result)\n  {\n    if (a != 0 && b != 0) {\n      result = a * b;\n\n      require(\n        result / a == b,\n        \"SafeMathLib#3\"\n      );\n    }\n\n    return result;\n  }\n\n  function div(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    require(\n      b != 0,\n      \"SafeMathLib#4\"\n    );\n\n    return a / b;\n  }\n}\n"
    },
    "src/HEROLPManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./access/Lockable.sol\";\nimport \"./access/Owned.sol\";\nimport \"./lifecycle/Initializable.sol\";\nimport \"./math/SafeMathLib.sol\";\nimport \"./HEROToken.sol\";\n\n\n/**\n * @title HERO abstract liquidity pool manager\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\nabstract contract HEROLPManager is Lockable, Owned, Initializable {\n  using SafeMathLib for uint256;\n\n  HEROToken public token;\n\n  // modifiers\n\n  modifier onlyToken() {\n    require(\n      msg.sender == address(token),\n      \"HEROLPManager#1\"\n    );\n\n    _;\n  }\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor ()\n    internal\n    Lockable()\n    Owned()\n    Initializable()\n  {\n    //\n  }\n\n  // external functions\n\n  function syncLP()\n    external\n    onlyToken\n    lock\n  {\n    _syncLP();\n  }\n\n  function burnLP(\n    uint256 amount\n  )\n    external\n    onlyOwner\n    lockOrThrowError\n  {\n    require(\n      amount != 0,\n      \"HEROLPManager#2\"\n    );\n\n    _burnLP(amount);\n  }\n\n  // external functions (views)\n\n  function canSyncLP(\n    address sender,\n    address recipient\n  )\n    external\n    view\n    virtual\n    returns (\n      bool shouldSyncLPBefore,\n      bool shouldSyncLPAfter\n    );\n\n  // internal functions\n\n  function _initialize(\n    address token_\n  )\n    internal\n  {\n    require(\n      token_ != address(0),\n      \"HEROLPManager#3\"\n    );\n\n    token = HEROToken(token_);\n  }\n\n  function _syncLP()\n    internal\n    virtual;\n\n  function _burnLP(\n    uint256 amount\n  )\n    internal\n    virtual;\n}\n"
    },
    "src/erc20/ERC20Standard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title ERC20 standard interface\n *\n * @notice See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n */\ninterface ERC20Standard {\n  // events\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  // external functions\n\n  function approve(\n    address spender,\n    uint256 value\n  )\n    external\n    returns (bool);\n\n  function transfer(\n    address to,\n    uint256 value\n  )\n    external\n    returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  )\n    external\n    returns (bool);\n\n  // external functions (views)\n\n  function totalSupply()\n    external\n    view\n    returns (uint256);\n\n  function balanceOf(\n    address owner\n  )\n    external\n    view\n    returns (uint256);\n\n  function allowance(\n    address owner,\n    address spender\n  )\n    external\n    view\n    returns (uint256);\n\n  // external functions (pure)\n\n  function name()\n    external\n    pure\n    returns (string memory);\n\n  function symbol()\n    external\n    pure\n    returns (string memory);\n\n  function decimals()\n    external\n    pure\n    returns (uint8);\n}\n"
    },
    "src/access/Lockable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Lockable\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract Lockable {\n  bool public locked;\n\n  // modifiers\n\n  modifier lock() {\n    if (!locked) {\n      locked = true;\n\n      _;\n\n      locked = false;\n    }\n  }\n\n  modifier lockOrThrowError() {\n    require(\n      !locked,\n      \"Lockable#1\"\n    );\n\n    locked = true;\n\n    _;\n\n    locked = false;\n  }\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor()\n    internal\n  {\n    //\n  }\n}\n"
    },
    "src/HEROPresale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./access/Owned.sol\";\nimport \"./lifecycle/Initializable.sol\";\nimport \"./math/SafeMathLib.sol\";\nimport \"./HEROToken.sol\";\n\n\n/**\n * @title HERO presale\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract HEROPresale is Owned, Initializable {\n  using SafeMathLib for uint256;\n\n  struct Settings {\n    uint256 tokensAmountPerNative;\n    uint256 maxPurchasePrice; // max purchase price per whitelisted account\n  }\n\n  struct Summary {\n    uint256 totalAccounts;\n    uint256 totalTokens;\n  }\n\n  HEROToken public token;\n  Settings public settings;\n  Summary public summary;\n  uint256 public deadline;\n\n  mapping (address => bool) public whitelist;\n\n  // events\n\n  event TokensPurchased(\n    address indexed account,\n    uint256 tokensPrice,\n    uint256 tokensAmount\n  );\n\n  event SettingsUpdated(\n    uint256 tokensAmountPerNative,\n    uint256 maxPurchasePrice\n  );\n\n  event DeadlineUpdated(\n    uint256 deadline\n  );\n\n  event AccountAdded(\n    address indexed account\n  );\n\n  event AccountRemoved(\n    address indexed account\n  );\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    Owned()\n    Initializable()\n  {\n    //\n  }\n\n  // external functions\n\n  receive()\n    external\n    payable\n  {\n    require(\n      block.timestamp < deadline, // solhint-disable-line not-rely-on-time\n      \"HEROPresale#1\"\n    );\n\n    require(\n      whitelist[msg.sender],\n      \"HEROPresale#2\"\n    );\n\n    require(\n      msg.value != 0,\n      \"HEROPresale#3\"\n    );\n\n    require(\n      msg.value <= settings.maxPurchasePrice,\n      \"HEROPresale#4\"\n    );\n\n    uint256 tokensAmount = msg.value.mul(settings.tokensAmountPerNative);\n\n    require(\n      tokensAmount <= summary.totalTokens,\n      \"HEROPresale#5\"\n    );\n\n    whitelist[msg.sender] = false;\n\n    summary.totalAccounts = summary.totalAccounts.sub(1);\n    summary.totalTokens = summary.totalTokens.sub(tokensAmount);\n\n    token.transfer(\n      msg.sender,\n      tokensAmount\n    );\n\n    emit TokensPurchased(\n      msg.sender,\n      msg.value,\n      tokensAmount\n    );\n  }\n\n  function initialize(\n    address payable token_,\n    uint256 tokensAmountPerNative,\n    uint256 maxPurchasePrice,\n    uint256 deadlineIn // in seconds\n  )\n    external\n    onlyInitializer\n  {\n    require(\n      token_ != address(0),\n      \"HEROPresale#6\"\n    );\n\n    token = HEROToken(token_);\n\n    summary.totalTokens = token.balanceOf(address(this));\n\n    _updateSettings(\n      tokensAmountPerNative,\n      maxPurchasePrice\n    );\n\n    _updateDeadline(deadlineIn);\n  }\n\n  function updateSettings(\n    uint256 tokensAmountPerNative,\n    uint256 maxPurchasePrice\n  )\n    external\n    onlyOwner\n  {\n    _updateSettings(\n      tokensAmountPerNative,\n      maxPurchasePrice\n    );\n  }\n\n  function updateDeadline(\n    uint256 deadlineIn_ // in seconds\n  )\n    external\n    onlyOwner\n  {\n    _updateDeadline(deadlineIn_);\n  }\n\n  function syncTotalTokens()\n    external\n  {\n    summary.totalTokens = token.balanceOf(address(this));\n  }\n\n  function addAccounts(\n    address[] calldata accounts\n  )\n    external\n    onlyOwner\n  {\n    _addAccounts(accounts);\n  }\n\n  function removeAccounts(\n    address[] calldata accounts\n  )\n    external\n    onlyOwner\n  {\n    uint256 totalRemoved;\n    uint256 accountsLen = accounts.length;\n\n    for (uint256 index ; index < accountsLen ; index++) {\n      require(\n        accounts[index] != address(0),\n        \"HEROPresale#7\"\n      );\n\n      if (whitelist[accounts[index]]) {\n        whitelist[accounts[index]] = false;\n\n        totalRemoved = totalRemoved.add(1);\n\n        emit AccountRemoved(\n          accounts[index]\n        );\n      }\n    }\n\n    require(\n      totalRemoved != 0,\n      \"HEROPresale#8\"\n    );\n\n    summary.totalAccounts = summary.totalAccounts.sub(totalRemoved);\n  }\n\n  function finishPresale()\n    external\n    onlyOwner\n  {\n    require(\n      block.timestamp >= deadline, // solhint-disable-line not-rely-on-time\n      \"HEROPresale#9\"\n    );\n\n    uint256 totalTokens = token.balanceOf(address(this));\n\n    if (totalTokens != 0) {\n      token.burn(\n        totalTokens\n      );\n    }\n\n    selfdestruct(msg.sender);\n  }\n\n  // private functions\n\n  function _updateSettings(\n    uint256 tokensAmountPerNative,\n    uint256 maxPurchasePrice\n  )\n    private\n  {\n    require(\n      tokensAmountPerNative != 0,\n      \"HEROPresale#10\"\n    );\n\n    require(\n      maxPurchasePrice != 0,\n      \"HEROPresale#11\"\n    );\n\n    settings.tokensAmountPerNative = tokensAmountPerNative;\n    settings.maxPurchasePrice = maxPurchasePrice;\n\n    emit SettingsUpdated(\n      tokensAmountPerNative,\n      maxPurchasePrice\n    );\n  }\n\n  function _updateDeadline(\n    uint256 deadlineIn\n  )\n    private\n  {\n    deadline = block.timestamp.add(deadlineIn); // solhint-disable-line not-rely-on-time\n\n    emit DeadlineUpdated(\n      deadline\n    );\n  }\n\n  function _addAccounts(\n    address[] memory accounts\n  )\n    private\n  {\n    uint256 totalAdded;\n    uint256 accountsLen = accounts.length;\n\n    for (uint256 index ; index < accountsLen ; index++) {\n      require(\n        accounts[index] != address(0),\n        \"HEROPresale#12\"\n      );\n\n      if (!whitelist[accounts[index]]) {\n        whitelist[accounts[index]] = true;\n\n        totalAdded = totalAdded.add(1);\n\n        emit AccountAdded(\n          accounts[index]\n        );\n      }\n    }\n\n    require(\n      totalAdded != 0,\n      \"HEROPresale#13\"\n    );\n\n    summary.totalAccounts = summary.totalAccounts.add(totalAdded);\n  }\n}\n"
    },
    "src/HEROLPManagerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./HEROLPManager.sol\";\n\n\n/**\n * @title HERO liquidity pool manager mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract HEROLPManagerMock is HEROLPManager {\n  uint256 public syncedBalance;\n\n  bool private shouldSyncLPBefore;\n  bool private shouldSyncLPAfter;\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    HEROLPManager()\n  {\n    //\n  }\n\n  // external functions\n\n  function initialize(\n    address token_\n  )\n    external\n  {\n    _initialize(token_);\n  }\n\n  function setLocked(\n    bool locked_\n  )\n    external\n  {\n    locked = locked_;\n  }\n\n  function allowSyncLP(\n    bool shouldSyncLPBefore_,\n    bool shouldSyncLPAfter_\n  )\n    external\n  {\n    shouldSyncLPBefore = shouldSyncLPBefore_;\n    shouldSyncLPAfter = shouldSyncLPAfter_;\n  }\n\n  // external functions (views)\n\n  function canSyncLP(\n    address,\n    address\n  )\n    external\n    view\n    override\n    returns (bool, bool)\n  {\n    return (shouldSyncLPBefore, shouldSyncLPAfter);\n  }\n\n  // internal functions\n\n  function _syncLP()\n    internal\n    override\n  {\n    syncedBalance = token.balanceOf(address(this));\n  }\n\n  function _burnLP(\n    uint256 amount\n  )\n    internal\n    override\n  {\n    token.burn(\n      amount\n    );\n\n    _syncLP();\n  }\n}\n"
    },
    "src/HEROLPManagerForUniswapV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./erc20/WrappedNative.sol\";\nimport \"./uniswapV2/UniswapV2Factory.sol\";\nimport \"./uniswapV2/UniswapV2Pair.sol\";\nimport \"./uniswapV2/UniswapV2Router02.sol\";\nimport \"./HEROLPManager.sol\";\n\n\n/**\n * @title HERO liquidity pool manager for Uniswap v2\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract HEROLPManagerForUniswapV2 is HEROLPManager {\n  struct Settings {\n    uint256 enableBurnLPAtValue;\n    address stableCoin;\n  }\n\n  Settings public settings;\n  UniswapV2Factory public uniswapFactory;\n  UniswapV2Pair public uniswapPair;\n  UniswapV2Router02 public uniswapRouter;\n\n  WrappedNative private wrappedNative;\n  bool private correctPairOrder;\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    HEROLPManager()\n  {\n    //\n  }\n\n  // external functions\n\n  receive()\n    external\n    payable\n  {\n    require(\n      msg.value != 0,\n      \"HEROLPManagerUniswapV2#1\"\n    );\n\n    wrappedNative.deposit{value: msg.value}();\n  }\n\n  function initialize(\n    uint256 enableBurnLPAtValue,\n    address stableCoin,\n    address token_,\n    address uniswapRouter_\n  )\n    external\n    onlyInitializer\n  {\n    _initialize(token_);\n\n    if (enableBurnLPAtValue != 0) {\n      require(\n        stableCoin != address(0),\n        \"HEROLPManagerUniswapV2#2\"\n      );\n\n      settings.enableBurnLPAtValue = enableBurnLPAtValue;\n      settings.stableCoin = stableCoin;\n    }\n\n    require(\n      uniswapRouter_ != address(0),\n      \"HEROLPManagerUniswapV2#3\"\n    );\n\n    uniswapRouter = UniswapV2Router02(uniswapRouter_);\n    uniswapFactory = UniswapV2Factory(uniswapRouter.factory());\n\n    wrappedNative = WrappedNative(uniswapRouter.WETH());\n\n    uniswapPair = UniswapV2Pair(uniswapFactory.createPair(\n      address(token),\n      address(wrappedNative)\n    ));\n\n    correctPairOrder = address(token) < address(wrappedNative);\n  }\n\n  // external functions (views)\n\n  function canSyncLP(\n    address sender,\n    address recipient\n  )\n    external\n    view\n    override\n    returns (\n      bool shouldSyncLPBefore,\n      bool shouldSyncLPAfter\n    )\n  {\n    if (sender != address(uniswapPair)) {\n      if (recipient == address(uniswapPair)) {\n        shouldSyncLPBefore = true;\n      } else {\n        shouldSyncLPAfter = true;\n      }\n    }\n\n    return (shouldSyncLPBefore, shouldSyncLPAfter);\n  }\n\n  // internal functions\n\n  function _syncLP()\n    internal\n    override\n  {\n    uint256 totalAmount = token.balanceOf(address(this));\n\n    if (totalAmount != 0) {\n      uint256 swapAmount = totalAmount.div(2);\n      uint256 liquidityAmount = totalAmount.sub(swapAmount);\n\n      _swapTokens(swapAmount);\n\n      _addTokensToLiquidity(liquidityAmount);\n    }\n  }\n\n  function _burnLP(\n    uint256 amount\n  )\n    internal\n    override\n  {\n    if (settings.enableBurnLPAtValue != 0) {\n      (uint256 tokenReserve, ) = _getLiquidityReserves();\n\n      require(\n        tokenReserve != 0,\n        \"HEROLPManagerUniswapV2#4\"\n      );\n\n      require(\n        amount <= tokenReserve,\n        \"HEROLPManagerUniswapV2#5\"\n      );\n\n      address[] memory path = new address[](3);\n\n      path[0] = address(token);\n      path[1] = address(wrappedNative);\n      path[2] = settings.stableCoin;\n\n      uint256[] memory amounts = uniswapRouter.getAmountsOut(amount, path);\n\n      uint256 tokensValue = amounts[2];\n\n      require(\n        tokensValue > settings.enableBurnLPAtValue,\n        \"HEROLPManagerUniswapV2#6\"\n      );\n\n      uint256 amountValue = amount.mul(tokensValue).div(amount);\n      uint256 maxValue = tokensValue.div(settings.enableBurnLPAtValue);\n\n      require(\n        maxValue >= amountValue,\n        \"HEROLPManagerUniswapV2#7\"\n      );\n    }\n\n    _removeLiquidity();\n\n    uint256 totalAmount = token.balanceOf(address(this));\n\n    require(\n      totalAmount >= amount,\n      \"HEROLPManagerUniswapV2#8\"\n    );\n\n    token.burn(amount);\n\n    _addTokensToLiquidity(\n      totalAmount.sub(amount)\n    );\n  }\n\n  function _swapTokens(\n    uint256 amount\n  )\n    private\n  {\n    if (amount != 0) {\n      token.approve(\n        address(uniswapRouter),\n        amount\n      );\n\n      address[] memory path = new address[](2);\n\n      path[0] = address(token);\n      path[1] = address(wrappedNative);\n\n      uniswapRouter.swapExactTokensForTokens(\n        amount,\n        0,\n        path,\n        address(this),\n        block.timestamp // solhint-disable-line not-rely-on-time\n      );\n    }\n  }\n\n  function _addTokensToLiquidity(\n    uint256 tokensAmount\n  )\n    private\n  {\n    uint256 wrappedNativeAmount = wrappedNative.balanceOf(address(this));\n\n    if (\n      tokensAmount != 0 &&\n      wrappedNativeAmount != 0\n    ) {\n      token.approve(\n        address(uniswapRouter),\n        tokensAmount\n      );\n\n      wrappedNative.approve(\n        address(uniswapRouter),\n        wrappedNativeAmount\n      );\n\n      (\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired\n      ) = correctPairOrder\n        ? (address(token), address(wrappedNative), tokensAmount, wrappedNativeAmount)\n        : (address(wrappedNative), address(token), wrappedNativeAmount, tokensAmount);\n\n      uniswapRouter.addLiquidity(\n        tokenA,\n        tokenB,\n        amountADesired,\n        amountBDesired,\n        0,\n        0,\n        address(this),\n        block.timestamp // solhint-disable-line not-rely-on-time\n      );\n    }\n  }\n\n  function _removeLiquidity()\n    private\n  {\n    uint256 liquidity = uniswapPair.balanceOf(address(this));\n\n    if (liquidity != 0) {\n      uniswapPair.approve(\n        address(uniswapRouter),\n        liquidity\n      );\n\n      (\n        address tokenA,\n        address tokenB\n      ) = correctPairOrder\n        ? (address(token), address(wrappedNative))\n        : (address(wrappedNative), address(token));\n\n      uniswapRouter.removeLiquidity(\n        tokenA,\n        tokenB,\n        liquidity,\n        0,\n        0,\n        address(this),\n        block.timestamp // solhint-disable-line not-rely-on-time\n      );\n    }\n  }\n\n  // private functions (views)\n\n  function _getLiquidityReserves()\n    private\n    view\n    returns (\n      uint256 tokenReserve,\n      uint256 wrappedNativeReserve\n    )\n  {\n    (\n      uint112 reserve0,\n      uint112 reserve1,\n    ) = uniswapPair.getReserves();\n\n    (tokenReserve, wrappedNativeReserve) = correctPairOrder\n      ? (reserve0, reserve1)\n      : (reserve1, reserve0);\n\n    return (tokenReserve, wrappedNativeReserve);\n  }\n}\n"
    },
    "src/erc20/WrappedNative.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\nimport \"./ERC20Standard.sol\";\n\n\n/**\n * @title Wrapped native token interface\n *\n * @notice Based on https://github.com/Uniswap/uniswap-v2-periphery/blob/dda62473e2da448bc9cb8f4514dadda4aeede5f4/contracts/interfaces/IWETH.sol\n */\ninterface WrappedNative is ERC20Standard {\n  // external functions\n\n  function deposit()\n    external payable;\n\n  function withdraw(\n    uint256 amount\n  )\n    external;\n}\n"
    },
    "src/uniswapV2/UniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\n/**\n * @title Uniswap v2 factory interface\n *\n * @notice Based on https://github.com/Uniswap/uniswap-v2-core/blob/4dd59067c76dea4a0e8e4bfdda41877a6b16dedc/contracts/interfaces/IUniswapV2Factory.sol\n */\ninterface UniswapV2Factory {\n  // events\n\n  event PairCreated(\n    address indexed token0,\n    address indexed token1,\n    address pair,\n    uint256\n  );\n\n  // external functions\n\n  function createPair(\n    address tokenA,\n    address tokenB\n  )\n    external\n    returns (address);\n\n  function setFeeTo(\n    address\n  )\n    external;\n\n  function setFeeToSetter(\n    address\n  )\n    external;\n\n  // external functions (views)\n\n  function feeTo()\n    external\n    view\n    returns (address);\n\n  function feeToSetter()\n    external\n    view\n    returns (address);\n\n  function getPair(\n    address tokenA,\n    address tokenB\n  )\n    external\n    view\n    returns (address);\n\n  function allPairs(\n    uint256\n  )\n    external\n    view\n    returns (address);\n\n  function allPairsLength()\n    external\n    view\n    returns (uint256);\n}\n\n"
    },
    "src/uniswapV2/UniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/* solhint-disable func-name-mixedcase */\npragma solidity ^0.6.12;\n\nimport \"../erc20/ERC20Standard.sol\";\n\n\n/**\n * @title Uniswap V2 pair interface\n *\n * @notice Based on https://github.com/Uniswap/uniswap-v2-core/blob/4dd59067c76dea4a0e8e4bfdda41877a6b16dedc/contracts/interfaces/IUniswapV2Pair.sol\n */\ninterface UniswapV2Pair is ERC20Standard {\n  // events\n\n  event Mint(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1\n  );\n\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n\n  event Sync(\n    uint112 reserve0,\n    uint112 reserve1\n  );\n\n  // external functions\n\n  function initialize(\n    address,\n    address\n  )\n    external;\n\n  function mint(\n    address to\n  )\n    external\n    returns (uint256);\n\n  function burn(\n    address to\n  )\n    external\n    returns (uint256, uint256);\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  )\n    external;\n\n  function skim(\n    address to\n  )\n    external;\n\n  function sync()\n    external;\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external;\n\n  // external functions (views)\n\n  function DOMAIN_SEPARATOR()\n    external\n    view\n    returns (bytes32);\n\n  function nonces(\n    address owner\n  )\n    external\n    view\n    returns (uint256);\n\n  function factory()\n    external\n    view\n    returns (address);\n\n  function token0()\n    external\n    view\n    returns (address);\n\n  function token1()\n    external\n    view\n    returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (uint112, uint112, uint32);\n\n  function price0CumulativeLast()\n    external\n    view\n    returns (uint256);\n\n  function price1CumulativeLast()\n    external\n    view\n    returns (uint256);\n\n  function kLast()\n    external\n    view\n    returns (uint256);\n\n  // external functions (pure)\n\n  function PERMIT_TYPEHASH()\n    external\n    pure\n    returns (bytes32);\n\n  function MINIMUM_LIQUIDITY()\n    external\n    pure\n    returns (uint256);\n}\n"
    },
    "src/uniswapV2/UniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\nimport \"./UniswapV2Router01.sol\";\n\n\n/**\n * @title Uniswap V2 router02 interface\n *\n * @notice Based on https://github.com/Uniswap/uniswap-v2-periphery/blob/dda62473e2da448bc9cb8f4514dadda4aeede5f4/contracts/interfaces/IUniswapV2Router02.sol\n */\ninterface UniswapV2Router02 is UniswapV2Router01 {\n  // external functions\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable;\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (uint256);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external\n    returns (uint256);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external;\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external;\n}\n"
    },
    "src/uniswapV2/UniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/* solhint-disable func-name-mixedcase */\npragma solidity ^0.6.12;\n\n/**\n * @title Uniswap V2 router01 interface\n *\n * @notice Based on https://github.com/Uniswap/uniswap-v2-periphery/blob/dda62473e2da448bc9cb8f4514dadda4aeede5f4/contracts/interfaces/IUniswapV2Router01.sol\n */\ninterface UniswapV2Router01 {\n  // external functions\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable\n    returns (uint256, uint256, uint256);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable\n    returns (uint256[] memory);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (uint256, uint256, uint256);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (uint256, uint256);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (uint256, uint256);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external\n    returns (uint256, uint256);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external\n    returns (uint256, uint256);\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (uint256[] memory);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (uint256[] memory);\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (uint256[] memory);\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (uint256[] memory);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable\n    returns (uint256[] memory);\n\n  // external functions (views)\n\n  function getAmountsOut(\n    uint256 amountIn,\n    address[] calldata path\n  )\n    external\n    view\n    returns (uint256[] memory);\n\n  function getAmountsIn(\n    uint256 amountOut,\n    address[] calldata path\n  )\n    external\n    view\n    returns (uint256[] memory);\n\n  // external functions (pure)\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  )\n    external\n    pure\n    returns (uint256);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  )\n    external\n    pure\n    returns (uint256);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  )\n    external\n    pure\n    returns (uint256);\n\n  function factory()\n    external\n    pure\n    returns (address);\n\n  function WETH()\n    external\n    pure\n    returns (address);\n}\n"
    }
  },
  "settings": {
    "evmVersion": "istanbul",
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}