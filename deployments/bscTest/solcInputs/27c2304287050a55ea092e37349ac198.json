{
  "language": "Solidity",
  "sources": {
    "src/HEROPresale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./components/Controlled.sol\";\nimport \"./components/Initializable.sol\";\nimport \"./libs/MathLib.sol\";\nimport \"./HEROToken.sol\";\n\n\n/**\n * @title HERO presale\n */\ncontract HEROPresale is Controlled, Initializable {\n  using MathLib for uint256;\n\n  // defaults\n  uint256 private constant DEFAULT_DEADLINE_IN = 7 * 24 * 60 * 60; // 7 days\n\n  HEROToken public token;\n\n  mapping (address => bool) public whitelist;\n\n  uint256 public deadline;\n  uint256 public unitPrice;\n  uint256 public unitTokens;\n  uint256 public pendingAccounts;\n  uint256 public pendingTokens;\n\n  // events\n\n  event DeadlineUpdated(\n    uint256 deadline\n  );\n\n  event AccountAdded(\n    address indexed account\n  );\n\n  event UnitBought(\n    address indexed account\n  );\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    Controlled()\n    Initializable()\n  {}\n\n  // external functions (payable)\n\n  function buyUnit()\n    external\n    payable\n  {\n    require(\n      block.timestamp < deadline, // solhint-disable-line not-rely-on-time\n      \"HEROPresale: can not buy after deadline\"\n    );\n\n    require(\n      whitelist[msg.sender],\n      \"HEROPresale: msg.sender not on the whitelist\"\n    );\n    require(\n      msg.value == unitPrice,\n      \"HEROPresale: invalid msg.value\"\n    );\n\n    whitelist[msg.sender] = false;\n\n    pendingAccounts = pendingAccounts.sub(1);\n    pendingTokens = pendingTokens.sub(unitTokens);\n\n    token.transfer(\n      msg.sender,\n      unitTokens\n    );\n\n    emit UnitBought(\n      msg.sender\n    );\n  }\n\n  // external functions\n\n  function initialize(\n    address payable token_,\n    uint256 deadlineIn_, // in seconds\n    uint256 unitPrice_,\n    uint256 unitTokens_,\n    address[] calldata accounts\n  )\n    external\n    onlyInitializer\n  {\n    require(\n      token_ != address(0),\n      \"HEROPresale: token is the zero address\"\n    );\n    require(\n      unitPrice_ != 0,\n      \"HEROPresale: invalid unit price\"\n    );\n    require(\n      unitTokens_ != 0,\n      \"HEROPresale: invalid unit tokens\"\n    );\n\n    token = HEROToken(token_);\n\n    unitPrice = unitPrice_;\n    unitTokens = unitTokens_;\n\n    _updateDeadline(deadlineIn_ != 0\n      ? deadlineIn_\n      : DEFAULT_DEADLINE_IN\n    );\n\n    _addAccounts(accounts);\n  }\n\n  function updateDeadline(\n    uint256 deadlineIn_ // in seconds\n  )\n    external\n    onlyController\n  {\n    _updateDeadline(deadlineIn_);\n  }\n\n  function addAccounts(\n    address[] calldata accounts\n  )\n    external\n    onlyController\n  {\n    _addAccounts(accounts);\n  }\n\n  function destroy()\n    external\n    onlyController\n  {\n    require(\n      block.timestamp >= deadline, // solhint-disable-line not-rely-on-time\n      \"HEROPresale: can not destroy before deadline\"\n    );\n\n    uint256 pendingTokens_ = token.balanceOf(address(this));\n\n    if (pendingTokens_ != 0) {\n      token.burn(\n        pendingTokens_\n      );\n    }\n\n    selfdestruct(msg.sender);\n  }\n\n  // private functions\n\n  function _updateDeadline(\n    uint256 deadlineIn_\n  )\n    private\n  {\n    deadline = block.timestamp.add(deadlineIn_); // solhint-disable-line not-rely-on-time\n\n    emit DeadlineUpdated(\n      deadline\n    );\n  }\n\n  function _addAccounts(\n    address[] memory accounts\n  )\n    private\n  {\n    uint256 pendingAccounts_;\n    uint256 pendingTokens_;\n\n    uint256 accountsLen = accounts.length;\n\n    for (uint256 index = 0 ; index < accountsLen ; index += 1) {\n      require(\n        accounts[index] != address(0),\n        \"HEROPresale: account is the zero address\"\n      );\n\n      if (!whitelist[accounts[index]]) {\n        whitelist[accounts[index]] = true;\n\n        pendingAccounts_ = pendingAccounts_.add(1);\n        pendingTokens_ = pendingTokens_.add(unitTokens);\n\n        emit AccountAdded(\n          accounts[index]\n        );\n      }\n    }\n\n    require(\n      pendingAccounts_ != 0,\n      \"HEROPresale: empty accounts\"\n    );\n\n    pendingAccounts = pendingAccounts.add(pendingAccounts_);\n    pendingTokens = pendingTokens.add(pendingTokens_);\n\n    require(\n      pendingTokens <= token.balanceOf(address(this)),\n      \"HEROPresale: pending tokens exceeds balance\"\n    );\n  }\n}\n"
    },
    "src/components/Controlled.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Controlled\n */\ncontract Controlled {\n  address public controller;\n\n  // modifiers\n\n  modifier onlyController() {\n    require(\n      msg.sender == controller,\n      \"Controlled: msg.sender is not the controller\"\n    );\n\n    _;\n  }\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor()\n    internal\n  {\n    controller = msg.sender;\n  }\n\n  // external functions\n\n  function setController(\n    address controller_\n  )\n    external\n    onlyController\n  {\n    require(\n      controller_ != address(0) &&\n      controller_ != controller,\n      \"Controlled: invalid controller\"\n    );\n\n    controller = controller_;\n  }\n}\n"
    },
    "src/components/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Initializable\n */\ncontract Initializable {\n  address private initializer;\n\n  // events\n\n  event Initialized();\n\n  // modifiers\n\n  modifier onlyInitializer() {\n    require(\n      initializer != address(0),\n      \"Initializable: already initialized\"\n    );\n\n    require(\n      msg.sender == initializer,\n      \"Initializable: msg.sender is not the initializer\"\n    );\n\n    initializer = address(0);\n\n    _;\n\n    emit Initialized();\n  }\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor()\n    internal\n  {\n    initializer = msg.sender;\n  }\n\n  // external functions (views)\n\n  function initialized()\n    external\n    view\n    returns (bool)\n  {\n    return initializer == address(0);\n  }\n}\n"
    },
    "src/libs/MathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Math library\n */\nlibrary MathLib {\n  function add(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    uint256 c = a + b;\n\n    require(c >= a, \"MathLib: addition overflow\");\n\n    return c;\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    require(b <= a, \"MathLib: subtraction overflow\");\n\n    return a - b;\n  }\n\n  function mul(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    if (a == 0 || b == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n\n    require(c / a == b, \"MathLib: multiplication overflow\");\n\n    return c;\n  }\n\n  function div(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    require(b != 0, \"MathLib: division by zero\");\n\n    return a / b;\n  }\n\n  function percent(\n    uint256 a,\n    uint256 p\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    uint256 result;\n\n    if (a != 0 && p != 0) {\n      result = div(mul(a, p), 100);\n    }\n\n    return result;\n  }\n}\n"
    },
    "src/HEROToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./components/erc20/ERC20Metadata.sol\";\nimport \"./components/Initializable.sol\";\nimport \"./HEROTokenLP.sol\";\n\n\n/**\n * @title HERO token\n */\ncontract HEROToken is ERC20Metadata, Initializable, HEROTokenLP {\n  // metadata\n  string private constant TOKEN_NAME = \"METAHERO\";\n  string private constant TOKEN_SYMBOL = \"HERO\";\n  uint8 private constant TOKEN_DECIMALS = 9; // 0.000000000\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    Initializable()\n    ERC20Metadata(\n      Metadata(TOKEN_NAME, TOKEN_SYMBOL, TOKEN_DECIMALS)\n    )\n  {\n    //\n  }\n\n  // external functions\n\n  function initialize(\n    Fees calldata lpFees,\n    Fees calldata rewardsFees,\n    uint256 totalSupply_,\n    address[] calldata excluded_,\n    address swapRouter_\n  )\n    external\n    onlyInitializer\n  {\n    _initializeEconomy(\n      lpFees,\n      rewardsFees,\n      totalSupply_,\n      excluded_\n    );\n\n    _initializeLP(\n      swapRouter_\n    );\n  }\n}\n"
    },
    "src/components/erc20/ERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\ncontract ERC20Metadata {\n  struct Metadata {\n    string name;\n    string symbol;\n    uint8 decimals;\n  }\n\n  Metadata private metadata;\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor (\n    Metadata memory metadata_\n  )\n    internal\n  {\n    metadata = metadata_;\n  }\n\n  // external functions (views)\n\n  function name()\n    external\n    view\n    virtual\n    returns (string memory)\n  {\n    return metadata.name;\n  }\n\n  function symbol()\n    external\n    view\n    virtual\n    returns (string memory)\n  {\n    return metadata.symbol;\n  }\n\n  function decimals()\n    external\n    view\n    virtual\n    returns (uint8)\n  {\n    return metadata.decimals;\n  }\n}\n"
    },
    "src/HEROTokenLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./external/UniswapV2Factory.sol\";\nimport \"./external/UniswapV2Router02.sol\";\nimport \"./HEROTokenEconomy.sol\";\n\n\n/**\n * @title HERO token liquidity pool module\n */\ncontract HEROTokenLP is HEROTokenEconomy {\n  UniswapV2Router02 public swapRouter;\n  address public swapPair;\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor ()\n    internal\n  {\n    //\n  }\n\n  // external functions\n\n  receive()\n    external\n    payable\n  {\n    //\n  }\n\n  // internal functions\n\n  function _initializeLP(\n    address swapRouter_\n  )\n    internal\n  {\n    swapRouter = UniswapV2Router02(swapRouter_);\n\n    swapPair = UniswapV2Factory(swapRouter.factory())\n    .createPair(\n      address(this),\n        swapRouter.WETH()\n    );\n\n    _exclude(address(this));\n    _exclude(address(swapRouter));\n    _exclude(swapPair);\n  }\n\n  function _increaseTotalLP(\n    uint256 amount\n  )\n    internal\n    override\n  {\n    balances[address(this)] = balances[address(this)].add(amount);\n    summary.totalLP = summary.totalLP.add(amount);\n\n    swapAndLiquify(amount);\n  }\n\n  // private functions\n\n  function swapAndLiquify(\n    uint256 amount\n  )\n    private\n  {\n    uint256 half = amount.div(2);\n    uint256 otherHalf = amount.sub(half);\n\n    uint256 initialBalance = address(this).balance;\n\n    swapTokensForEth(half);\n\n    uint256 newBalance = address(this).balance.sub(initialBalance);\n\n    addLiquidity(otherHalf, newBalance);\n  }\n\n  function swapTokensForEth(\n    uint256 tokenAmount\n  )\n    private\n  {\n    address[] memory path = new address[](2);\n\n    path[0] = address(this);\n    path[1] = swapRouter.WETH();\n\n    _approve(\n      address(this),\n      address(swapRouter),\n      tokenAmount\n    );\n\n    swapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\n      tokenAmount,\n      0,\n      path,\n      address(this),\n      block.timestamp // solhint-disable-line not-rely-on-time\n    );\n  }\n\n  function addLiquidity(\n    uint256 tokenAmount,\n    uint256 ethAmount\n  )\n    private\n  {\n    _approve(\n      address(this),\n      address(swapRouter),\n      tokenAmount\n    );\n\n    swapRouter.addLiquidityETH{value : ethAmount}(\n      address(this),\n      tokenAmount,\n      0, // slippage is unavoidable\n      0, // slippage is unavoidable\n      address(this),\n      block.timestamp // solhint-disable-line not-rely-on-time\n    );\n  }\n}\n"
    },
    "src/external/UniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\ninterface UniswapV2Factory {\n  // events\n\n  event PairCreated(\n    address indexed token0,\n    address indexed token1,\n    address pair,\n    uint256\n  );\n\n  // external functions\n\n  function createPair(\n    address tokenA,\n    address tokenB\n  )\n    external\n    returns (address);\n\n  function setFeeTo(\n    address\n  )\n    external;\n\n  function setFeeToSetter(\n    address\n  )\n    external;\n\n  // external functions (views)\n\n  function feeTo()\n    external\n    view\n    returns (address);\n\n  function feeToSetter()\n    external\n    view\n    returns (address);\n\n  function getPair(\n    address tokenA,\n    address tokenB\n  )\n    external\n    view\n    returns (address);\n\n  function allPairs(\n    uint256\n  )\n    external\n    view\n    returns (address);\n\n  function allPairsLength()\n    external\n    view\n    returns (uint256);\n}\n\n"
    },
    "src/external/UniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./UniswapV2Router01.sol\";\n\n\ninterface UniswapV2Router02 is UniswapV2Router01 {\n  // external functions (payable)\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    payable;\n\n  // external functions\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  )\n    external\n    returns (uint);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external\n    returns (uint);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external;\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external;\n}\n"
    },
    "src/HEROTokenEconomy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./components/erc20/ERC20.sol\";\nimport \"./components/Lockable.sol\";\nimport \"./components/Lockable.sol\";\nimport \"./libs/MathLib.sol\";\n\n\n/**\n * @title HERO token economy module\n */\ncontract HEROTokenEconomy is ERC20, Lockable {\n  using MathLib for uint256;\n\n  struct Fees {\n    uint256 sender; // percent\n    uint256 recipient; // percent\n  }\n\n  struct Settings {\n    Fees lpFees;\n    Fees rewardsFees;\n  }\n\n  struct Summary {\n    uint256 totalExcluded;\n    uint256 totalHolding;\n    uint256 totalLP;\n    uint256 totalRewards;\n    uint256 totalSupply;\n  }\n\n  // defaults\n  uint256 private constant DEFAULT_TOTAL_SUPPLY = 10000000000 * 10 ** 9; // 10,000,000,000.000000000\n\n  Settings public settings;\n  Summary public summary;\n\n  mapping (address => uint256) internal balances;\n  mapping (address => mapping (address => uint256)) private allowances;\n  mapping (address => bool) private excluded;\n\n  // events\n\n  event Excluded(\n    address indexed account\n  );\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor ()\n    internal\n  {\n    //\n  }\n\n  // external functions\n\n  function transfer(\n    address recipient,\n    uint256 amount\n  )\n    external\n    override\n    returns (bool)\n  {\n    _transfer(\n      msg.sender,\n      recipient,\n      amount\n    );\n\n    return true;\n  }\n\n  function burn(\n    uint256 amount\n  )\n    external\n    returns (bool)\n  {\n    _burn(\n      msg.sender,\n      amount\n    );\n\n    return true;\n  }\n\n  function approve(\n    address spender,\n    uint256 amount\n  )\n    external\n    override\n    returns (bool)\n  {\n    _approve(\n      msg.sender,\n      spender,\n      amount\n    );\n\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    external\n    override\n    returns (bool)\n  {\n    _transfer(\n      sender,\n      recipient,\n      amount\n    );\n\n    uint256 currentAllowance = allowances[sender][msg.sender];\n\n    require(\n      currentAllowance >= amount,\n      \"HEROTokenEconomy: amount exceeds allowance\"\n    );\n\n    _approve(\n      sender,\n      msg.sender,\n      currentAllowance.sub(amount)\n    );\n\n    return true;\n  }\n\n  // external functions (views)\n\n  function totalSupply()\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return summary.totalSupply;\n  }\n\n  function allowance(\n    address owner,\n    address spender\n  )\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return allowances[owner][spender];\n  }\n\n  function balanceOf(\n    address account\n  )\n    external\n    view\n    override\n    returns (uint256 result)\n  {\n    result = balances[account];\n\n    if (\n      !excluded[account] &&\n      summary.totalRewards != 0\n    ) {\n      result = result.add(\n        summary.totalRewards\n        .mul(result)\n        .div(summary.totalHolding)\n      );\n    }\n\n\n    return result;\n  }\n\n  // internal functions\n\n  function _initializeEconomy(\n    Fees memory lpFees,\n    Fees memory rewardsFees,\n    uint256 totalSupply_,\n    address[] calldata excluded_\n  )\n    internal\n  {\n    settings = Settings(\n      lpFees,\n      rewardsFees\n    );\n\n    _mint(\n      msg.sender,\n      totalSupply_ == 0\n      ? DEFAULT_TOTAL_SUPPLY\n      : totalSupply_\n    );\n\n    {\n      uint256 excludedLen = excluded_.length;\n\n      for (uint256 index = 0; index < excludedLen; index += 1) {\n        _exclude(excluded_[index]);\n      }\n    }\n  }\n\n  function _exclude(\n    address account\n  )\n    internal\n  {\n    require(\n      account != address(0),\n      \"HEROTokenEconomy: account is the zero address\"\n    );\n\n    require(\n      !excluded[account],\n      \"HEROTokenEconomy: account already excluded\"\n    );\n\n    require(\n      balances[account] == 0,\n      \"HEROTokenEconomy: can not exclude holder account\"\n    );\n\n    excluded[account] = true;\n\n    emit Excluded(\n      account\n    );\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  )\n    internal\n  {\n    require(\n      owner != address(0),\n      \"HEROTokenEconomy: owner is the zero address\"\n    );\n\n    require(\n      spender != address(0),\n      \"HEROTokenEconomy: spender is the zero address\"\n    );\n\n    allowances[owner][spender] = amount;\n\n    emit Approval(\n      owner,\n      spender,\n      amount\n    );\n  }\n\n  function _mint(\n    address account,\n    uint256 amount\n  )\n    internal\n    lock\n  {\n    require(\n      account != address(0),\n      \"HEROTokenEconomy: account is the zero address\"\n    );\n\n    require(\n      amount != 0,\n      \"HEROTokenEconomy: invalid amount\"\n    );\n\n    summary.totalSupply = summary.totalSupply.add(amount);\n    summary.totalExcluded = summary.totalExcluded.add(amount);\n\n    _exclude(account);\n\n    balances[account] = balances[account].add(amount);\n\n    emit Transfer(\n      address(0),\n      account,\n      amount\n    );\n  }\n\n  function _burn(\n    address account,\n    uint256 amount\n  )\n    internal\n    lock\n  {\n    require(\n      account != address(0),\n      \"HEROTokenEconomy: account is the zero address\"\n    );\n\n    require(\n      amount != 0,\n      \"HEROTokenEconomy: invalid amount\"\n    );\n\n    require(\n      balances[account] >= amount,\n      \"HEROTokenEconomy: amount exceeds balance\"\n    );\n\n    require(\n      excluded[account],\n      \"HEROTokenEconomy: can not burn from holder account\"\n    );\n\n    summary.totalSupply = summary.totalSupply.sub(amount);\n    summary.totalExcluded = summary.totalExcluded.sub(amount);\n\n    balances[account] = balances[account].sub(amount);\n\n    emit Transfer(\n      account,\n      address(0),\n      amount\n    );\n  }\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    internal\n    lock\n  {\n    require(\n      sender != address(0),\n      \"HEROTokenEconomy: sender is the zero address\"\n    );\n\n    require(\n      recipient != address(0),\n      \"HEROTokenEconomy: recipient is the zero address\"\n    );\n\n    require(\n      sender != recipient,\n      \"HEROTokenEconomy: invalid recipient\"\n    );\n\n    require(\n      amount != 0,\n      \"HEROTokenEconomy: invalid amount\"\n    );\n\n    if (\n      !excluded[sender] && !excluded[recipient]\n    ) {\n      _transferBetweenHolders(\n        sender,\n        recipient,\n        amount\n      );\n    } else if (\n      excluded[sender] && !excluded[recipient]\n    ) {\n      _transferFromExcluded(\n        sender,\n        recipient,\n        amount\n      );\n    } else if (\n      !excluded[sender] && excluded[recipient]\n    ) {\n      _transferToExcluded(\n        sender,\n        recipient,\n        amount\n      );\n    } else {\n      _transferBetweenExcluded(\n        sender,\n        recipient,\n        amount\n      );\n    }\n\n    emit Transfer(\n      sender,\n      recipient,\n      amount\n    );\n  }\n\n  function _transferBetweenHolders(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    internal\n  {\n    (\n      uint256 senderFee,\n      uint256 lpFee\n    ) = _calcTransferSenderFees(amount);\n\n    uint256 recipientFee;\n    uint256 totalFee = senderFee;\n\n    {\n      uint256 recipientLPFee;\n\n      (\n        recipientFee,\n        recipientLPFee\n      ) = _calcTransferRecipientFees(amount);\n\n      lpFee = lpFee.add(recipientLPFee);\n      totalFee = totalFee.add(recipientFee);\n    }\n\n    uint256 senderAmount = amount.add(senderFee);\n    uint256 recipientAmount = amount.sub(recipientFee);\n\n    if (summary.totalRewards != 0) {\n      uint256 totalHoldingWithRewards = summary.totalHolding.add(\n        summary.totalRewards\n      );\n\n      senderAmount = senderAmount.mul(summary.totalHolding).div(\n        totalHoldingWithRewards\n      );\n      recipientAmount = recipientAmount.mul(summary.totalHolding).div(\n        totalHoldingWithRewards\n      );\n      totalFee = totalFee.mul(summary.totalHolding).div(\n        totalHoldingWithRewards\n      );\n    }\n\n    require(\n      balances[sender] >= senderAmount,\n      \"HEROTokenEconomy: amount exceeds balance\"\n    );\n\n    balances[sender] = balances[sender].sub(senderAmount);\n    balances[recipient] = balances[recipient].add(recipientAmount);\n\n    summary.totalHolding = summary.totalHolding.sub(totalFee);\n\n    _increaseTotalLP(lpFee);\n    _updateTotalRewards();\n  }\n\n  function _transferFromExcluded(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    internal\n  {\n    require(\n      balances[sender] >= amount,\n      \"HEROTokenEconomy: amount exceeds balance\"\n    );\n\n    (\n      uint256 recipientFee,\n      uint256 lpFee\n    ) = _calcTransferSenderFees(amount);\n\n    uint256 recipientAmount = amount.sub(recipientFee);\n\n    balances[sender] = balances[sender].sub(amount);\n    balances[recipient] = balances[recipient].add(recipientAmount);\n\n    summary.totalExcluded = summary.totalExcluded.sub(amount);\n    summary.totalHolding = summary.totalHolding.add(recipientAmount);\n\n    _increaseTotalLP(lpFee);\n    _updateTotalRewards();\n  }\n\n  function _transferToExcluded(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    internal\n  {\n    (\n      uint256 senderFee,\n      uint256 lpFee\n    ) = _calcTransferSenderFees(amount);\n\n    uint256 senderAmount = amount.add(senderFee);\n\n    if (summary.totalRewards != 0) {\n      uint256 totalHoldingWithRewards = summary.totalHolding.add(\n        summary.totalRewards\n      );\n\n      senderAmount = senderAmount.mul(summary.totalHolding).div(\n        totalHoldingWithRewards\n      );\n    }\n\n    require(\n      balances[sender] >= senderAmount,\n      \"HEROTokenEconomy: amount exceeds balance\"\n    );\n\n    balances[sender] = balances[sender].sub(senderAmount);\n    balances[recipient] = balances[recipient].add(amount);\n\n    summary.totalExcluded = summary.totalExcluded.add(amount);\n    summary.totalHolding = summary.totalHolding.sub(senderAmount);\n\n    _increaseTotalLP(lpFee);\n    _updateTotalRewards();\n  }\n\n  function _transferBetweenExcluded(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    internal\n  {\n    require(\n      balances[sender] >= amount,\n      \"HEROTokenEconomy: amount exceeds balance\"\n    );\n\n    balances[sender] = balances[sender].sub(amount);\n    balances[recipient] = balances[recipient].add(amount);\n  }\n\n  function _increaseTotalLP(\n    uint256 amount\n  )\n    internal\n    virtual\n  {\n    summary.totalLP = summary.totalLP.add(amount);\n  }\n\n  // private functions\n\n  function _updateTotalRewards()\n    private\n  {\n    summary.totalRewards = summary.totalSupply\n    .sub(summary.totalExcluded)\n    .sub(summary.totalHolding)\n    .sub(summary.totalLP);\n  }\n\n  // private functions (views)\n\n  function _calcTransferSenderFees(\n    uint256 amount\n  )\n    private\n    view\n    returns (\n      uint256 totalFee,\n      uint256 lpFee\n    )\n  {\n    uint256 rewardsFee = amount.percent(settings.rewardsFees.sender);\n\n    lpFee = amount.percent(settings.lpFees.sender);\n    totalFee = lpFee.add(rewardsFee);\n\n    return (totalFee, lpFee);\n  }\n\n  function _calcTransferRecipientFees(\n    uint256 amount\n  )\n    private\n    view\n    returns (\n      uint256 totalFee,\n      uint256 lpFee\n    )\n  {\n    uint256 rewardsFee = amount.percent(settings.rewardsFees.recipient);\n\n    lpFee = amount.percent(settings.lpFees.recipient);\n    totalFee = lpFee.add(rewardsFee);\n\n    return (totalFee, lpFee);\n  }\n}\n"
    },
    "src/external/UniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable func-name-mixedcase */\npragma solidity ^0.6.12;\n\ninterface UniswapV2Router01 {\n  // external functions (payable)\n\n  function addLiquidityETH(\n    address token,\n    uint amountTokenDesired,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  )\n    external\n    payable\n    returns (uint, uint, uint);\n\n  function swapExactETHForTokens(\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    payable\n    returns (uint[] memory);\n\n  // external functions\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n  )\n    external\n    returns (uint, uint, uint);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n  )\n    external\n    returns (uint, uint);\n\n  function removeLiquidityETH(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  )\n    external\n    returns (uint, uint);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external\n    returns (uint, uint);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external\n    returns (uint, uint);\n\n  function swapExactTokensForTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    returns (uint[] memory);\n\n  function swapTokensForExactTokens(\n    uint amountOut,\n    uint amountInMax,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    returns (uint[] memory);\n\n  function swapTokensForExactETH(\n    uint amountOut,\n    uint amountInMax,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    returns (uint[] memory);\n\n  function swapExactTokensForETH(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    returns (uint[] memory);\n\n  function swapETHForExactTokens(\n    uint amountOut,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    payable\n    returns (uint[] memory);\n\n  // external functions (views)\n\n  function getAmountsOut(\n    uint amountIn,\n    address[] calldata path\n  )\n    external\n    view\n    returns (uint[] memory);\n\n  function getAmountsIn(\n    uint amountOut,\n    address[] calldata path\n  )\n    external\n    view\n    returns (uint[] memory);\n\n  // external functions (pure)\n\n  function quote(\n    uint amountA,\n    uint reserveA,\n    uint reserveB\n  )\n    external\n    pure\n    returns (uint);\n\n  function getAmountOut(\n    uint amountIn,\n    uint reserveIn,\n    uint reserveOut\n  )\n    external\n    pure\n    returns (uint);\n\n  function getAmountIn(\n    uint amountOut,\n    uint reserveIn,\n    uint reserveOut\n  )\n    external\n    pure\n    returns (uint);\n\n  function factory()\n    external\n    pure\n    returns (address);\n\n  function WETH()\n    external\n    pure\n    returns (address);\n}\n"
    },
    "src/components/erc20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nabstract contract ERC20 {\n  // events\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  // external functions\n\n  function approve(\n    address spender,\n    uint256 value\n  )\n    external\n    virtual\n    returns (bool);\n\n  function transfer(\n    address to,\n    uint256 value\n  )\n    external\n    virtual\n    returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  )\n    external\n    virtual\n    returns (bool);\n\n  // external functions (views)\n\n  function totalSupply()\n    external\n    view\n    virtual\n    returns (uint256);\n\n  function balanceOf(\n    address owner\n  )\n    external\n    view\n    virtual\n    returns (uint256);\n\n  function allowance(\n    address owner,\n    address spender\n  )\n    external\n    view\n    virtual\n    returns (uint256);\n}\n"
    },
    "src/components/Lockable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Lockable\n */\ncontract Lockable {\n  bool private locked;\n\n  // modifiers\n\n  modifier lock() {\n    require(\n      !locked,\n      \"Lockable: locked\"\n    );\n\n    locked = true;\n\n    _;\n\n    locked = false;\n  }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "istanbul",
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}