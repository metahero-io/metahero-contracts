{
  "language": "Solidity",
  "sources": {
    "src/core/access/Controlled.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Controlled\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract Controlled {\n  /**\n   * @return controller address\n   */\n  address public controller;\n\n  // modifiers\n\n  /**\n   * @dev Throws if msg.sender is not the controller\n   */\n  modifier onlyController() {\n    require(\n      msg.sender == controller,\n      \"Controlled#1\" // msg.sender is not the controller\n    );\n\n    _;\n  }\n\n  // events\n\n  /**\n   * @dev Emitted when the controller is updated\n   * @param controller new controller address\n   */\n  event ControllerUpdated(\n    address controller\n  );\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor()\n    internal\n  {\n    //\n  }\n\n  // internal functions\n\n  function _initializeController(\n    address controller_\n  )\n    internal\n  {\n    controller = controller_;\n  }\n\n  function _setController(\n    address controller_\n  )\n    internal\n  {\n    require(\n      controller_ != address(0),\n      \"Controlled#2\" // controller is the zero address\n    );\n\n    require(\n      controller_ != controller,\n      \"Controlled#3\" // does not update the controller\n    );\n\n    controller = controller_;\n\n    emit ControllerUpdated(\n      controller_\n    );\n  }\n\n  function _removeController()\n    internal\n  {\n    require(\n      controller != address(0),\n      \"Controlled#4\" // controller is the zero address\n    );\n\n    controller = address(0);\n\n    emit ControllerUpdated(\n      address(0)\n    );\n  }\n}\n"
    },
    "src/MetaheroToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./core/access/Controlled.sol\";\nimport \"./core/access/Owned.sol\";\nimport \"./core/erc20/ERC20.sol\";\nimport \"./core/lifecycle/Initializable.sol\";\nimport \"./core/math/MathLib.sol\";\nimport \"./core/math/SafeMathLib.sol\";\nimport \"./IMetaheroDAO.sol\";\nimport \"./MetaheroLPM.sol\";\n\n\n/**\n * @title Metahero token\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract MetaheroToken is Controlled, Owned, ERC20, Initializable {\n  using MathLib for uint256;\n  using SafeMathLib for uint256;\n\n  struct Fees {\n    uint256 sender; // percent from sender\n    uint256 recipient; // percent from recipient\n  }\n\n  struct Settings {\n    Fees burnFees; // fee taken and burned\n    Fees lpFees; // fee taken and added to the liquidity pool manager\n    Fees rewardsFees; // fee taken and added to rewards\n    uint256 minTotalSupply; // min amount of tokens total supply\n  }\n\n  struct Summary {\n    uint256 totalExcluded; // total held by excluded accounts\n    uint256 totalHolding; // total held by holder accounts\n    uint256 totalRewards; // total rewards\n    uint256 totalSupply; // total supply\n  }\n\n  struct ExcludedAccount {\n    bool exists; // true if exists\n    bool excludeSenderFromFee; // removes the fee from all sender accounts on incoming transfers\n    bool excludeRecipientFromFee; // removes the fee from all recipient accounts on outgoing transfers\n  }\n\n  // globals\n\n  uint256 private constant MAX_FEE = 30; // max sum of all fees - 30%\n\n  // metadata\n\n  string private constant TOKEN_NAME = \"Metahero\";\n  string private constant TOKEN_SYMBOL = \"HERO\";\n  uint8 private constant TOKEN_DECIMALS = 18; // 0.000000000000000000\n\n  /**\n   * @return dao address\n   */\n  IMetaheroDAO public dao;\n\n  /**\n   * @return liquidity pool manager address\n   */\n  MetaheroLPM public lpm;\n\n  /**\n   * @return settings object\n   */\n  Settings public settings;\n\n  /**\n   * @return summary object\n   */\n  Summary public summary;\n\n  /**\n   * @return return true when presale is finished\n   */\n  bool public presaleFinished;\n\n  mapping (address => uint256) private accountBalances;\n  mapping (address => mapping (address => uint256)) private accountAllowances;\n  mapping (address => ExcludedAccount) private excludedAccounts;\n\n  // events\n\n  /**\n   * @dev Emitted when the contract is initialized\n   * @param burnFees burn fees\n   * @param lpFees liquidity pool fees\n   * @param rewardsFees rewards fees\n   * @param minTotalSupply min total supply\n   * @param lpm liquidity pool manager address\n   * @param controller controller address\n   */\n  event Initialized(\n    Fees burnFees,\n    Fees lpFees,\n    Fees rewardsFees,\n    uint256 minTotalSupply,\n    address lpm,\n    address controller\n  );\n\n  /**\n   * @dev Emitted when the dao is updated\n   * @param dao dao address\n   */\n  event DAOUpdated(\n    address dao\n  );\n\n  /**\n   * @dev Emitted when fees are updated\n   * @param burnFees burn fees\n   * @param lpFees liquidity pool fees\n   * @param rewardsFees rewards fees\n   */\n  event FeesUpdated(\n    Fees burnFees,\n    Fees lpFees,\n    Fees rewardsFees\n  );\n\n  /**\n   * @dev Emitted when the presale is finished\n   */\n  event PresaleFinished();\n\n  /**\n   * @dev Emitted when account is excluded\n   * @param account account address\n   * @param excludeSenderFromFee exclude sender from fee\n   * @param excludeRecipientFromFee exclude recipient from fee\n   */\n  event AccountExcluded(\n    address indexed account,\n    bool excludeSenderFromFee,\n    bool excludeRecipientFromFee\n  );\n\n  /**\n   * @dev Emitted when total rewards amount is updated\n   * @param totalRewards total rewards amount\n   */\n  event TotalRewardsUpdated(\n    uint256 totalRewards\n  );\n\n  // modifiers\n\n  /**\n   * @dev Throws if msg.sender is not the dao\n   */\n  modifier onlyDAO() {\n    require(\n      msg.sender == address(dao),\n      \"MetaheroToken#1\" // msg.sender is not the dao\n    );\n\n    _;\n  }\n\n  /**\n   * @dev Throws if msg.sender is not the excluded account\n   */\n  modifier onlyExcludedAccount() {\n    require(\n      excludedAccounts[msg.sender].exists,\n      \"MetaheroToken#2\" // msg.sender is not the excluded account\n    );\n\n    _;\n  }\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    Controlled()\n    Owned()\n    ERC20(TOKEN_NAME, TOKEN_SYMBOL, TOKEN_DECIMALS) // sets metadata\n    Initializable()\n  {\n    //\n  }\n\n  // external functions\n\n  /**\n   * @dev Initializes the contract\n   * @param burnFees burn fees\n   * @param lpFees liquidity pool fees\n   * @param rewardsFees rewards fees\n   * @param minTotalSupply min total supply\n   * @param lpm_ liquidity pool manager address\n   * @param controller_ controller address\n   * @param totalSupply_ total supply\n   */\n  function initialize(\n    Fees memory burnFees,\n    Fees memory lpFees,\n    Fees memory rewardsFees,\n    uint256 minTotalSupply,\n    address payable lpm_,\n    address controller_,\n    uint256 totalSupply_,\n    address[] calldata excludedAccounts_\n  )\n    external\n    onlyInitializer\n  {\n    _verifyFees(burnFees, lpFees, rewardsFees);\n\n    settings.burnFees = burnFees;\n    settings.lpFees = lpFees;\n    settings.rewardsFees = rewardsFees;\n    settings.minTotalSupply = minTotalSupply;\n\n    if (\n      lpFees.sender != 0 ||\n      lpFees.recipient != 0\n    ) {\n      require(\n        lpm_ != address(0),\n        \"MetaheroToken#3\" // lpm is the zero address\n      );\n\n      lpm = MetaheroLPM(lpm_);\n    }\n\n    _initializeController(controller_);\n\n    emit Initialized(\n      burnFees,\n      lpFees,\n      rewardsFees,\n      minTotalSupply,\n      lpm_,\n      controller_\n    );\n\n    // excludes owner account\n    _excludeAccount(msg.sender, true, true);\n\n    if (totalSupply_ != 0) {\n      _mint(\n        msg.sender,\n        totalSupply_\n      );\n    }\n\n    // adds predefined excluded accounts\n    uint256 excludedAccountsLen = excludedAccounts_.length;\n\n    for (uint256 index; index < excludedAccountsLen; index++) {\n      _excludeAccount(excludedAccounts_[index], false, false);\n    }\n  }\n\n  /**\n   * @dev Sets the dao\n   * @param dao_ dao address\n   */\n  function setDAO(\n    address dao_\n  )\n    external\n    onlyOwner\n  {\n    require(\n      dao_ != address(0),\n      \"MetaheroToken#4\" // dao is the zero address\n    );\n\n    dao = IMetaheroDAO(dao_);\n\n    emit DAOUpdated(\n      dao_\n    );\n\n    // makes a dao an owner\n    _setOwner(dao_);\n  }\n\n  /**\n   * @dev Updates fees\n   * @param burnFees burn fees\n   * @param lpFees liquidity pool fees\n   * @param rewardsFees rewards fees\n   */\n  function updateFees(\n    Fees memory burnFees,\n    Fees memory lpFees,\n    Fees memory rewardsFees\n  )\n    external\n    onlyDAO // only for dao\n  {\n    _verifyFees(burnFees, lpFees, rewardsFees);\n\n    settings.burnFees = burnFees;\n    settings.lpFees = lpFees;\n    settings.rewardsFees = rewardsFees;\n\n    emit FeesUpdated(\n      burnFees,\n      lpFees,\n      rewardsFees\n    );\n  }\n\n  /**\n   * @dev Set the presale as finished\n   */\n  function setPresaleAsFinished()\n    external\n    onlyOwner\n  {\n    require(\n      !presaleFinished,\n      \"MetaheroToken#5\" // the presale is already finished\n    );\n\n    presaleFinished = true;\n\n    emit PresaleFinished();\n  }\n\n  /**\n   * @dev Excludes account\n   * @param account account address\n   * @param excludeSenderFromFee exclude sender from fee\n   * @param excludeRecipientFromFee exclude recipient from fee\n   */\n  function excludeAccount(\n    address account,\n    bool excludeSenderFromFee,\n    bool excludeRecipientFromFee\n  )\n    external\n    onlyOwner\n  {\n    _excludeAccount(\n      account,\n      excludeSenderFromFee,\n      excludeRecipientFromFee\n    );\n  }\n\n  /**\n   * @dev Approve spending limit\n   * @param spender spender address\n   * @param amount spending limit\n   */\n  function approve(\n    address spender,\n    uint256 amount\n  )\n    external\n    override\n    returns (bool)\n  {\n    _approve(\n      msg.sender,\n      spender,\n      amount\n    );\n\n    return true;\n  }\n\n  /**\n   * @dev Mints tokens to recipient\n   * @param recipient recipient address\n   * @param amount tokens amount\n   */\n  function mintTo(\n    address recipient,\n    uint256 amount\n  )\n    external\n    onlyController\n  {\n    _mint(\n      recipient,\n      amount\n    );\n  }\n\n  /**\n   * @dev Burns tokens from msg.sender\n   * @param amount tokens amount\n   */\n  function burn(\n    uint256 amount\n  )\n    external\n    onlyExcludedAccount\n  {\n    _burn(\n      msg.sender,\n      amount\n    );\n  }\n\n  /**\n   * @dev Burns tokens from sender\n   * @param sender sender address\n   * @param amount tokens amount\n   */\n  function burnFrom(\n    address sender,\n    uint256 amount\n  )\n    external\n    onlyController\n  {\n    _burn(\n      sender,\n      amount\n    );\n  }\n\n  /**\n   * @dev Transfers tokens to recipient\n   * @param recipient recipient address\n   * @param amount tokens amount\n   */\n  function transfer(\n    address recipient,\n    uint256 amount\n  )\n    external\n    override\n    returns (bool)\n  {\n    _transfer(\n      msg.sender,\n      recipient,\n      amount\n    );\n\n    return true;\n  }\n\n  /**\n   * @dev Transfers tokens from sender to recipient\n   * @param sender sender address\n   * @param recipient recipient address\n   * @param amount tokens amount\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    external\n    override\n    returns (bool)\n  {\n    _transfer(\n      sender,\n      recipient,\n      amount\n    );\n\n    uint256 allowance = accountAllowances[sender][msg.sender];\n\n    require(\n      allowance >= amount,\n      \"MetaheroToken#6\"  // amount exceeds allowance\n    );\n\n    _approve( // update allowance\n      sender,\n      msg.sender,\n      allowance.sub(amount)\n    );\n\n    return true;\n  }\n\n  // external functions (views)\n\n  /**\n   * @dev Gets excluded account\n   * @param account account address\n   */\n  function getExcludedAccount(\n    address account\n  )\n    external\n    view\n    returns (\n      bool exists,\n      bool excludeSenderFromFee,\n      bool excludeRecipientFromFee\n    )\n  {\n    return (\n      excludedAccounts[account].exists,\n      excludedAccounts[account].excludeSenderFromFee,\n      excludedAccounts[account].excludeRecipientFromFee\n    );\n  }\n\n  /**\n   * @dev Gets total supply\n   * @return total supply\n   */\n  function totalSupply()\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return summary.totalSupply;\n  }\n\n  /**\n   * @dev Gets allowance\n   * @param owner owner address\n   * @param spender spender address\n   * @return allowance\n   */\n  function allowance(\n    address owner,\n    address spender\n  )\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return accountAllowances[owner][spender];\n  }\n\n  /**\n   * @dev Gets balance of\n   * @param account account address\n   * @return result account balance\n   */\n  function balanceOf(\n    address account\n  )\n    external\n    view\n    override\n    returns (uint256 result)\n  {\n    result = accountBalances[account].add(\n      _calcRewards(account)\n    );\n\n    return result;\n  }\n\n  /**\n   * @dev Gets balance summary\n   * @param account account address\n   */\n  function getBalanceSummary(\n    address account\n  )\n    external\n    view\n    returns (\n      uint256 totalBalance,\n      uint256 holdingBalance,\n      uint256 totalRewards\n    )\n  {\n    holdingBalance = accountBalances[account];\n    totalRewards = _calcRewards(account);\n    totalBalance = holdingBalance.add(totalRewards);\n\n    return (totalBalance, holdingBalance, totalRewards);\n  }\n\n  // private functions\n\n  function _excludeAccount(\n    address account,\n    bool excludeSenderFromFee,\n    bool excludeRecipientFromFee\n  )\n    private\n  {\n    require(\n      account != address(0),\n      \"MetaheroToken#7\" // account is the zero address\n    );\n\n    // if already excluded\n    if (excludedAccounts[account].exists) {\n      require(\n        excludedAccounts[account].excludeSenderFromFee != excludeSenderFromFee ||\n        excludedAccounts[account].excludeRecipientFromFee != excludeRecipientFromFee,\n        \"MetaheroToken#8\" // does not update exclude account\n      );\n\n      excludedAccounts[account].excludeSenderFromFee = excludeSenderFromFee;\n      excludedAccounts[account].excludeRecipientFromFee = excludeRecipientFromFee;\n    } else {\n      require(\n        accountBalances[account] == 0,\n        \"MetaheroToken#9\" // can not exclude holder account\n      );\n\n      excludedAccounts[account].exists = true;\n      excludedAccounts[account].excludeSenderFromFee = excludeSenderFromFee;\n      excludedAccounts[account].excludeRecipientFromFee = excludeRecipientFromFee;\n    }\n\n    emit AccountExcluded(\n      account,\n      excludeSenderFromFee,\n      excludeRecipientFromFee\n    );\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      spender != address(0),\n      \"MetaheroToken#11\" // spender is the zero address\n    );\n\n    accountAllowances[owner][spender] = amount;\n\n    emit Approval(\n      owner,\n      spender,\n      amount\n    );\n  }\n\n  function _mint(\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      recipient != address(0),\n      \"MetaheroToken#12\" // recipient is the zero address\n    );\n\n    require(\n      amount != 0,\n      \"MetaheroToken#13\" // amount is zero\n    );\n\n    summary.totalSupply = summary.totalSupply.add(amount);\n\n    // if exclude account\n    if (excludedAccounts[recipient].exists) {\n      summary.totalExcluded = summary.totalExcluded.add(amount);\n\n      accountBalances[recipient] = accountBalances[recipient].add(amount);\n    } else {\n      _updateHoldingBalance(\n        recipient,\n        accountBalances[recipient].add(amount),\n        summary.totalHolding.add(amount)\n      );\n    }\n\n    _emitTransfer(\n      address(0),\n      recipient,\n      amount\n    );\n  }\n\n  function _burn(\n    address sender,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      sender != address(0),\n      \"MetaheroToken#14\" // sender is the zero address\n    );\n\n    require(\n      amount != 0,\n      \"MetaheroToken#15\" // amount is zero\n    );\n\n    require(\n      accountBalances[sender] >= amount,\n      \"MetaheroToken#16\" // amount exceeds sender balance\n    );\n\n    uint256 totalSupply_ = summary.totalSupply.sub(amount);\n\n    if (settings.minTotalSupply != 0) {\n      require(\n        totalSupply_ >= settings.minTotalSupply,\n        \"MetaheroToken#17\" // new total supply exceeds min total supply\n      );\n    }\n\n    summary.totalSupply = totalSupply_;\n\n    // if exclude account\n    if (excludedAccounts[sender].exists) {\n      summary.totalExcluded = summary.totalExcluded.sub(amount);\n\n      accountBalances[sender] = accountBalances[sender].sub(amount);\n    } else {\n      _updateHoldingBalance(\n        sender,\n        accountBalances[sender].sub(amount),\n        summary.totalHolding.sub(amount)\n      );\n    }\n\n    _emitTransfer(\n      sender,\n      address(0),\n      amount\n    );\n  }\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      sender != address(0),\n      \"MetaheroToken#18\" // sender is the zero address\n    );\n\n    require(\n      recipient != address(0),\n      \"MetaheroToken#19\" // recipient is the zero address\n    );\n\n    if (sender == recipient) { // special transfer type\n      _syncLP(); // sync only LP\n\n      _emitTransfer(\n        sender,\n        recipient,\n        0\n      );\n    } else {\n      require(\n        excludedAccounts[sender].exists ||\n        presaleFinished,\n        \"MetaheroToken#20\" // presale not finished yet\n      );\n\n      require(\n        amount != 0,\n        \"MetaheroToken#21\" // amount is zero\n      );\n\n      if (\n        !excludedAccounts[sender].exists &&\n        !excludedAccounts[recipient].exists\n      ) {\n        _transferBetweenHolderAccounts(\n          sender,\n          recipient,\n          amount\n        );\n      } else if (\n        excludedAccounts[sender].exists &&\n        !excludedAccounts[recipient].exists\n      ) {\n        _transferFromExcludedAccount(\n          sender,\n          recipient,\n          amount\n        );\n      } else if (\n        !excludedAccounts[sender].exists &&\n        excludedAccounts[recipient].exists\n      ) {\n        _transferToExcludedAccount(\n          sender,\n          recipient,\n          amount\n        );\n      } else {\n        _transferBetweenExcludedAccounts(\n          sender,\n          recipient,\n          amount\n        );\n      }\n    }\n  }\n\n  function _transferBetweenHolderAccounts(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    uint256 senderAmount;\n    uint256 senderBurnFee;\n    uint256 senderLpFee;\n\n    uint256 recipientAmount;\n    uint256 recipientBurnFee;\n    uint256 recipientLpFee;\n\n    uint256 totalFee;\n\n    {\n      uint256 totalSupply_ = summary.totalSupply;\n\n      // calc fees for sender and recipient\n      {\n        uint256 senderTotalFee;\n        uint256 recipientTotalFee;\n\n        (\n          senderTotalFee,\n          senderBurnFee,\n          senderLpFee\n        ) = _calcTransferSenderFees(amount);\n\n        (\n          totalSupply_,\n          senderTotalFee,\n          senderBurnFee\n        ) = _matchTotalSupplyWithFees(totalSupply_, senderTotalFee, senderBurnFee);\n\n        (\n          recipientTotalFee,\n          recipientBurnFee,\n          recipientLpFee\n        ) = _calcTransferRecipientFees(amount);\n\n        (\n          totalSupply_,\n          recipientTotalFee,\n          recipientBurnFee\n        ) = _matchTotalSupplyWithFees(totalSupply_, recipientTotalFee, recipientBurnFee);\n\n        totalFee = senderTotalFee.add(recipientTotalFee);\n        senderAmount = amount.add(senderTotalFee);\n        recipientAmount = amount.sub(recipientTotalFee);\n      }\n\n      // appends total rewards\n      if (summary.totalRewards != 0) {\n        uint256 totalHoldingWithRewards = summary.totalHolding.add(\n          summary.totalRewards\n        );\n\n        senderAmount = senderAmount.mul(summary.totalHolding).div(\n          totalHoldingWithRewards\n        );\n        recipientAmount = recipientAmount.mul(summary.totalHolding).div(\n          totalHoldingWithRewards\n        );\n        totalFee = totalFee.mul(summary.totalHolding).div(\n          totalHoldingWithRewards\n        );\n      }\n\n      require(\n        accountBalances[sender] >= senderAmount,\n        \"MetaheroToken#22\" // amount exceeds sender balance\n      );\n\n      summary.totalSupply = totalSupply_;\n\n      // reduce local vars\n      senderAmount = accountBalances[sender].sub(senderAmount);\n      recipientAmount = accountBalances[recipient].add(recipientAmount);\n\n      _updateHoldingBalances(\n        sender,\n        senderAmount,\n        recipient,\n        recipientAmount,\n        summary.totalHolding.sub(totalFee)\n      );\n\n      _increaseTotalLP(senderLpFee.add(recipientLpFee));\n    }\n\n    // emits events\n\n    {\n      _emitTransfer(\n        sender,\n        recipient,\n        amount\n      );\n\n      _emitTransfer(\n        sender,\n        address(0),\n        senderBurnFee\n      );\n\n      _emitTransfer(\n        sender,\n        address(lpm),\n        senderLpFee\n      );\n\n      _emitTransfer(\n        recipient,\n        address(0),\n        recipientBurnFee\n      );\n\n      _emitTransfer(\n        recipient,\n        address(lpm),\n        recipientLpFee\n      );\n\n      _updateTotalRewards();\n\n      _syncLP();\n    }\n  }\n\n  function _transferFromExcludedAccount(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      accountBalances[sender] >= amount,\n      \"MetaheroToken#23\" // amount exceeds sender balance\n    );\n\n    (\n      bool shouldSyncLPBefore,\n      bool shouldSyncLPAfter\n    ) = _canSyncLP(\n      sender,\n      address(0)\n    );\n\n    if (shouldSyncLPBefore) {\n      lpm.syncLP();\n    }\n\n    uint256 recipientTotalFee;\n    uint256 recipientBurnFee;\n    uint256 recipientLPFee;\n\n    uint256 totalSupply_ = summary.totalSupply;\n\n    // when sender does not remove the fee from the recipient\n    if (!excludedAccounts[sender].excludeRecipientFromFee) {\n      (\n        recipientTotalFee,\n        recipientBurnFee,\n        recipientLPFee\n      ) = _calcTransferRecipientFees(amount);\n\n      (\n        totalSupply_,\n        recipientTotalFee,\n        recipientBurnFee\n      ) = _matchTotalSupplyWithFees(totalSupply_, recipientTotalFee, recipientBurnFee);\n    }\n\n    uint256 recipientAmount = amount.sub(recipientTotalFee);\n\n    summary.totalSupply = totalSupply_;\n    summary.totalExcluded = summary.totalExcluded.sub(amount);\n\n    accountBalances[sender] = accountBalances[sender].sub(amount);\n\n    _updateHoldingBalance(\n      recipient,\n      accountBalances[recipient].add(recipientAmount),\n      summary.totalHolding.add(recipientAmount)\n    );\n\n    _increaseTotalLP(recipientLPFee);\n\n    // emits events\n\n    _emitTransfer(\n      sender,\n      recipient,\n      amount\n    );\n\n    _emitTransfer(\n      recipient,\n      address(0),\n      recipientBurnFee\n    );\n\n    _emitTransfer(\n      recipient,\n      address(lpm),\n      recipientLPFee\n    );\n\n    _updateTotalRewards();\n\n    if (shouldSyncLPAfter) {\n      lpm.syncLP();\n    }\n  }\n\n  function _transferToExcludedAccount(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    (\n      bool shouldSyncLPBefore,\n      bool shouldSyncLPAfter\n    ) = _canSyncLP(\n      address(0),\n      recipient\n    );\n\n    if (shouldSyncLPBefore) {\n      lpm.syncLP();\n    }\n\n    uint256 senderTotalFee;\n    uint256 senderBurnFee;\n    uint256 senderLpFee;\n\n    uint256 totalSupply_ = summary.totalSupply;\n\n    // when recipient does not remove the fee from the sender\n    if (!excludedAccounts[recipient].excludeSenderFromFee) {\n      (\n        senderTotalFee,\n        senderBurnFee,\n        senderLpFee\n      ) = _calcTransferSenderFees(amount);\n\n      (\n        totalSupply_,\n        senderTotalFee,\n        senderBurnFee\n      ) = _matchTotalSupplyWithFees(totalSupply_, senderTotalFee, senderBurnFee);\n    }\n\n    uint256 senderAmount = amount.add(senderTotalFee);\n\n    // append total rewards\n    if (summary.totalRewards != 0) {\n      uint256 totalHoldingWithRewards = summary.totalHolding.add(\n        summary.totalRewards\n      );\n\n      senderAmount = senderAmount.mul(summary.totalHolding).div(\n        totalHoldingWithRewards\n      );\n    }\n\n    require(\n      accountBalances[sender] >= senderAmount,\n      \"MetaheroToken#24\" // amount exceeds sender balance\n    );\n\n    summary.totalSupply = totalSupply_;\n    summary.totalExcluded = summary.totalExcluded.add(amount);\n\n    accountBalances[recipient] = accountBalances[recipient].add(amount);\n\n    _updateHoldingBalance(\n      sender,\n      accountBalances[sender].sub(senderAmount),\n      summary.totalHolding.sub(senderAmount)\n    );\n\n    _increaseTotalLP(senderLpFee);\n\n    // emits events\n\n    _emitTransfer(\n      sender,\n      recipient,\n      amount\n    );\n\n    _emitTransfer(\n      sender,\n      address(0),\n      senderBurnFee\n    );\n\n    _emitTransfer(\n      sender,\n      address(lpm),\n      senderLpFee\n    );\n\n    _updateTotalRewards();\n\n    if (shouldSyncLPAfter) {\n      lpm.syncLP();\n    }\n  }\n\n  function _transferBetweenExcludedAccounts(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      accountBalances[sender] >= amount,\n      \"MetaheroToken#25\" // amount exceeds sender balance\n    );\n\n    (\n      bool shouldSyncLPBefore,\n      bool shouldSyncLPAfter\n    ) = _canSyncLP(\n      address(0),\n      recipient\n    );\n\n    if (shouldSyncLPBefore) {\n      lpm.syncLP();\n    }\n\n    accountBalances[sender] = accountBalances[sender].sub(amount);\n    accountBalances[recipient] = accountBalances[recipient].add(amount);\n\n    _emitTransfer(\n      sender,\n      recipient,\n      amount\n    );\n\n    if (shouldSyncLPAfter) {\n      lpm.syncLP();\n    }\n  }\n\n  function _updateHoldingBalance(\n    address holder,\n    uint256 holderBalance,\n    uint256 totalHolding\n  )\n    private\n  {\n    accountBalances[holder] = holderBalance;\n    summary.totalHolding = totalHolding;\n\n    if (address(dao) != address(0)) { // if dao is not the zero address\n      dao.syncMember(\n        holder,\n        holderBalance,\n        totalHolding\n      );\n    }\n  }\n\n  function _updateHoldingBalances(\n    address holderA,\n    uint256 holderABalance,\n    address holderB,\n    uint256 holderBBalance,\n    uint256 totalHolding\n  )\n    private\n  {\n    accountBalances[holderA] = holderABalance;\n    accountBalances[holderB] = holderBBalance;\n    summary.totalHolding = totalHolding;\n\n    if (address(dao) != address(0)) { // if dao is not the zero address\n      dao.syncMembers(\n        holderA,\n        holderABalance,\n        holderB,\n        holderBBalance,\n        totalHolding\n      );\n    }\n  }\n\n  function _emitTransfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    if (amount != 0) { // when amount is not zero\n      emit Transfer(\n        sender,\n        recipient,\n        amount\n      );\n    }\n  }\n\n  function _increaseTotalLP(\n    uint256 amount\n  )\n    private\n  {\n    if (amount != 0) { // when amount is not zero\n      accountBalances[address(lpm)] = accountBalances[address(lpm)].add(amount);\n\n      summary.totalExcluded = summary.totalExcluded.add(amount);\n    }\n  }\n\n  function _syncLP()\n    private\n  {\n    if (address(lpm) != address(0)) { // if lpm is not the zero address\n      lpm.syncLP();\n    }\n  }\n\n  function _updateTotalRewards()\n    private\n  {\n    // totalRewards = totalSupply - totalExcluded - totalHolding\n    uint256 totalRewards = summary.totalSupply\n    .sub(summary.totalExcluded)\n    .sub(summary.totalHolding);\n\n    if (totalRewards != summary.totalRewards) {\n      summary.totalRewards = totalRewards;\n\n      emit TotalRewardsUpdated(\n        totalRewards\n      );\n    }\n  }\n\n  // private functions (views)\n\n  function _matchTotalSupplyWithFees(\n    uint256 totalSupply_,\n    uint256 totalFee,\n    uint256 burnFee\n  )\n    private\n    view\n    returns (uint256, uint256, uint256)\n  {\n    if (burnFee != 0) {\n      uint256 newTotalSupply = totalSupply_.sub(burnFee);\n\n      if (newTotalSupply >= settings.minTotalSupply) {\n        totalSupply_ = newTotalSupply;\n      } else  { // turn of burn fee\n        totalFee = totalFee.sub(burnFee);\n        burnFee = 0;\n      }\n    }\n\n    return (totalSupply_, totalFee, burnFee);\n  }\n\n\n  function _canSyncLP(\n    address sender,\n    address recipient\n  )\n    private\n    view\n    returns (\n      bool shouldSyncLPBefore,\n      bool shouldSyncLPAfter\n    )\n  {\n    if (address(lpm) != address(0)) { // if lpm is not the zero address\n      (shouldSyncLPBefore, shouldSyncLPAfter) = lpm.canSyncLP(\n        sender,\n        recipient\n      );\n    }\n\n    return (shouldSyncLPBefore, shouldSyncLPAfter);\n  }\n\n  function _calcRewards(\n    address account\n  )\n    private\n    view\n    returns (uint256 result)\n  {\n    if (\n      !excludedAccounts[account].exists && // only for holders\n      summary.totalRewards != 0\n    ) {\n      result = summary.totalRewards\n        .mul(accountBalances[account])\n        .div(summary.totalHolding);\n    }\n\n    return result;\n  }\n\n  function _calcTransferSenderFees(\n    uint256 amount\n  )\n    private\n    view\n    returns (\n      uint256 totalFee,\n      uint256 burnFee,\n      uint256 lpFee\n    )\n  {\n    uint256 rewardsFee = amount.percent(settings.rewardsFees.sender);\n\n    lpFee = amount.percent(settings.lpFees.sender);\n    burnFee = amount.percent(settings.burnFees.sender);\n\n    totalFee = lpFee.add(rewardsFee).add(burnFee);\n\n    return (totalFee, burnFee, lpFee);\n  }\n\n  function _calcTransferRecipientFees(\n    uint256 amount\n  )\n    private\n    view\n    returns (\n      uint256 totalFee,\n      uint256 burnFee,\n      uint256 lpFee\n    )\n  {\n    uint256 rewardsFee = amount.percent(settings.rewardsFees.recipient);\n\n    lpFee = amount.percent(settings.lpFees.recipient);\n    burnFee = amount.percent(settings.burnFees.recipient);\n\n    totalFee = lpFee.add(rewardsFee).add(burnFee);\n\n    return (totalFee, burnFee, lpFee);\n  }\n\n  // private functions (pure)\n\n  function _verifyFees(\n    Fees memory burnFees,\n    Fees memory lpFees,\n    Fees memory rewardsFees\n  )\n    private\n    pure\n  {\n    uint256 totalFee = burnFees.sender.add(\n      burnFees.recipient\n    ).add(\n      lpFees.sender.add(lpFees.recipient)\n    ).add(\n      rewardsFees.sender.add(rewardsFees.recipient)\n    );\n\n    require(\n      totalFee <= MAX_FEE,\n      \"MetaheroToken#26\" // the total fee is too high\n    );\n  }\n}\n"
    },
    "src/core/access/Owned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Owned\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract Owned {\n  /**\n   * @return owner address\n   */\n  address public owner;\n\n  // modifiers\n\n  /**\n   * @dev Throws if msg.sender is not the owner\n   */\n  modifier onlyOwner() {\n    require(\n      msg.sender == owner,\n      \"Owned#1\" // msg.sender is not the owner\n    );\n\n    _;\n  }\n\n  // events\n\n  /**\n   * @dev Emitted when the owner is updated\n   * @param owner new owner address\n   */\n  event OwnerUpdated(\n    address owner\n  );\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor()\n    internal\n  {\n    owner = msg.sender;\n  }\n\n  // external functions\n\n  /**\n   * @notice Sets a new owner\n   * @param owner_ owner address\n   */\n  function setOwner(\n    address owner_\n  )\n    external\n    onlyOwner\n  {\n    _setOwner(owner_);\n  }\n\n  // internal functions\n\n  function _setOwner(\n    address owner_\n  )\n    internal\n  {\n    require(\n      owner_ != address(0),\n      \"Owned#2\" // owner is the zero address\n    );\n\n    require(\n      owner_ != owner,\n      \"Owned#3\" // does not update the owner\n    );\n\n    owner = owner_;\n\n    emit OwnerUpdated(\n      owner_\n    );\n  }\n}\n"
    },
    "src/core/erc20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./IERC20.sol\";\n\n\n/**\n * @title ERC20 abstract token\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\nabstract contract ERC20 is IERC20 {\n  string public override name;\n  string public override symbol;\n  uint8 public override decimals;\n\n  /**\n   * @dev Internal constructor\n   * @param name_ name\n   * @param symbol_ symbol\n   * @param decimals_ decimals amount\n   */\n  constructor (\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  )\n    internal\n  {\n    name = name_;\n    symbol = symbol_;\n    decimals = decimals_;\n  }\n}\n"
    },
    "src/core/lifecycle/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Initializable\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract Initializable {\n  address private initializer;\n\n  // modifiers\n\n  /**\n   * @dev Throws if msg.sender is not the initializer\n   */\n  modifier onlyInitializer() {\n    require(\n      initializer != address(0),\n      \"Initializable#1\" // already initialized\n    );\n\n    require(\n      msg.sender == initializer,\n      \"Initializable#2\" // msg.sender is not the initializer\n    );\n\n    /// @dev removes initializer\n    initializer = address(0);\n\n    _;\n  }\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor()\n    internal\n  {\n    initializer = msg.sender;\n  }\n\n  // external functions (views)\n\n  /**\n   * @notice Checks if contract is initialized\n   * @return true when contract is initialized\n   */\n  function initialized()\n    external\n    view\n    returns (bool)\n  {\n    return initializer == address(0);\n  }\n}\n"
    },
    "src/core/math/MathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./SafeMathLib.sol\";\n\n\n/**\n * @title Math library\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\nlibrary MathLib {\n  using SafeMathLib for uint256;\n\n  // internal functions (pure)\n\n  /**\n   * @notice Calcs a x p / 100\n   */\n  function percent(\n    uint256 a,\n    uint256 p\n  )\n    internal\n    pure\n    returns (uint256 result)\n  {\n    if (a != 0 && p != 0) {\n      result = a.mul(p).div(100);\n    }\n\n    return result;\n  }\n}\n"
    },
    "src/core/math/SafeMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Safe math library\n *\n * @notice Based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5fe8f4e93bd1d4f5cc9a6899d7f24f5ffe4c14aa/contracts/math/SafeMath.sol\n */\nlibrary SafeMathLib {\n  // internal functions (pure)\n\n  /**\n   * @notice Calcs a + b\n   */\n  function add(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    uint256 c = a + b;\n\n    require(\n      c >= a,\n      \"SafeMathLib#1\"\n    );\n\n    return c;\n  }\n\n  /**\n   * @notice Calcs a - b\n   */\n  function sub(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    require(\n      b <= a,\n      \"SafeMathLib#2\"\n    );\n\n    return a - b;\n  }\n\n  /**\n   * @notice Calcs a x b\n   */\n  function mul(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256 result)\n  {\n    if (a != 0 && b != 0) {\n      result = a * b;\n\n      require(\n        result / a == b,\n        \"SafeMathLib#3\"\n      );\n    }\n\n    return result;\n  }\n\n  /**\n   * @notice Calcs a / b\n   */\n  function div(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    require(\n      b != 0,\n      \"SafeMathLib#4\"\n    );\n\n    return a / b;\n  }\n}\n"
    },
    "src/IMetaheroDAO.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Metahero DAO interface\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ninterface IMetaheroDAO {\n  // external functions\n\n  /**\n   * @notice Called by a token to sync a dao member\n   * @param member member address\n   * @param memberWeight member weight\n   * @param totalWeight all members weight\n   */\n  function syncMember(\n    address member,\n    uint256 memberWeight,\n    uint256 totalWeight\n  )\n    external;\n\n  /**\n   * @notice Called by a token to sync a dao members\n   * @param memberA member A address\n   * @param memberAWeight member A weight\n   * @param memberB member B address\n   * @param memberBWeight member B weight\n   * @param totalWeight all members weight\n   */\n  function syncMembers(\n    address memberA,\n    uint256 memberAWeight,\n    address memberB,\n    uint256 memberBWeight,\n    uint256 totalWeight\n  )\n    external;\n}\n"
    },
    "src/MetaheroLPM.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./core/access/Lockable.sol\";\nimport \"./core/access/Owned.sol\";\nimport \"./core/lifecycle/Initializable.sol\";\nimport \"./core/math/SafeMathLib.sol\";\nimport \"./MetaheroToken.sol\";\n\n\n/**\n * @title Metahero abstract liquidity pool manager\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\nabstract contract MetaheroLPM is Lockable, Owned, Initializable {\n  using SafeMathLib for uint256;\n\n  /**\n   * @return token address\n   */\n  MetaheroToken public token;\n\n  // modifiers\n\n  /**\n   * @dev Throws if msg.sender is not the token\n   */\n  modifier onlyToken() {\n    require(\n      msg.sender == address(token),\n      \"MetaheroLPM#1\" // msg.sender is not the token\n    );\n\n    _;\n  }\n\n  // events\n\n  /**\n   * @dev Emitted when tokens from the liquidity pool are burned\n   * @param amount burnt amount\n   */\n  event LPBurnt(\n    uint256 amount\n  );\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor ()\n    internal\n    Lockable()\n    Owned()\n    Initializable()\n  {\n    //\n  }\n\n  // external functions\n\n  /**\n   * @notice Syncs liquidity pool\n   */\n  function syncLP()\n    external\n    onlyToken\n    lock\n  {\n    _syncLP();\n  }\n\n  /**\n   * @notice Burns tokens from the liquidity pool\n   * @param amount tokens amount\n   */\n  function burnLP(\n    uint256 amount\n  )\n    external\n    onlyOwner\n    lockOrThrowError\n  {\n    require(\n      amount != 0,\n      \"MetaheroLPM#2\" // amount is zero\n    );\n\n    _burnLP(amount);\n\n    emit LPBurnt(\n      amount\n    );\n  }\n\n  // external functions (views)\n\n  function canSyncLP(\n    address sender,\n    address recipient\n  )\n    external\n    view\n    virtual\n    returns (\n      bool shouldSyncLPBefore,\n      bool shouldSyncLPAfter\n    );\n\n  // internal functions\n\n  function _initialize(\n    address token_\n  )\n    internal\n  {\n    require(\n      token_ != address(0),\n      \"MetaheroLPM#3\" // token is the zero address\n    );\n\n    token = MetaheroToken(token_);\n  }\n\n  function _syncLP()\n    internal\n    virtual;\n\n  function _burnLP(\n    uint256 amount\n  )\n    internal\n    virtual;\n}\n"
    },
    "src/core/erc20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title ERC20 token interface\n *\n * @notice See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n */\ninterface IERC20 {\n  // events\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  // external functions\n\n  function approve(\n    address spender,\n    uint256 value\n  )\n    external\n    returns (bool);\n\n  function transfer(\n    address to,\n    uint256 value\n  )\n    external\n    returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  )\n    external\n    returns (bool);\n\n  // external functions (views)\n\n  function totalSupply()\n    external\n    view\n    returns (uint256);\n\n  function balanceOf(\n    address owner\n  )\n    external\n    view\n    returns (uint256);\n\n  function allowance(\n    address owner,\n    address spender\n  )\n    external\n    view\n    returns (uint256);\n\n  // external functions (pure)\n\n  function name()\n    external\n    pure\n    returns (string memory);\n\n  function symbol()\n    external\n    pure\n    returns (string memory);\n\n  function decimals()\n    external\n    pure\n    returns (uint8);\n}\n"
    },
    "src/core/access/Lockable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Lockable\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract Lockable {\n  /**\n   * @return true when contract is locked\n   */\n  bool public locked;\n\n  // modifiers\n\n\n  /**\n   * @dev Calls only when contract is unlocked\n   */\n  modifier lock() {\n    if (!locked) {\n      locked = true;\n\n      _;\n\n      locked = false;\n    }\n  }\n\n  /**\n   * @dev Throws if contract is locked\n   */\n  modifier lockOrThrowError() {\n    require(\n      !locked,\n      \"Lockable#1\" // contract is locked\n    );\n\n    locked = true;\n\n    _;\n\n    locked = false;\n  }\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor()\n    internal\n  {\n    //\n  }\n}\n"
    },
    "src/MetaheroSwapHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./core/erc20/IERC20.sol\";\nimport \"./core/lifecycle/Initializable.sol\";\nimport \"./core/math/SafeMathLib.sol\";\nimport \"./MetaheroToken.sol\";\n\n\n/**\n * @title Metahero swap helper\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract MetaheroSwapHelper is Initializable {\n  using SafeMathLib for uint256;\n\n  MetaheroToken public token;\n\n  // events\n\n  /**\n   * @dev Emitted when the contract is initialized\n   * @param token token address\n   */\n  event Initialized(\n    address token\n  );\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    Initializable()\n  {\n    //\n  }\n\n  // external functions\n\n  /**\n   * @dev Initializes the contract\n   * @param token_ token address\n   */\n  function initialize(\n    address token_\n  )\n    external\n    onlyInitializer\n  {\n    require(\n      token_ != address(0),\n      \"MetaheroSwapHelper#1\" // token is the zero address\n    );\n\n    token = MetaheroToken(token_);\n\n    emit Initialized(\n      token_\n    );\n  }\n\n  // external functions (views)\n\n  function getAllowances(\n    address payable account,\n    address[] calldata tokens,\n    address[] calldata spenders\n  )\n    external\n    view\n    returns (uint256[] memory result)\n  {\n    uint256 len = tokens.length;\n\n    if (len == spenders.length) {\n      result = new uint256[](len);\n\n      for (uint256 index ; index < len ; index++) {\n        address token_ = tokens[index];\n        address spender = spenders[index];\n\n        uint256 tokenCode;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly { tokenCode := extcodesize(token_) } // contract code size\n\n        if (tokenCode != 0) {\n          // solhint-disable-next-line avoid-low-level-calls\n          (bool methodExists,) = token_.staticcall(abi.encodeWithSelector(\n            IERC20(token_).allowance.selector,\n            account,\n            spender\n          ));\n\n          if (methodExists) {\n            result[index] = IERC20(token_).allowance(account, spender);\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function getBalances(\n    address payable account,\n    address[] calldata tokens\n  )\n    external\n    view\n    returns (\n      uint256 nativeBalance,\n      uint256 tokenHoldingBalance,\n      uint256 tokenTotalRewards,\n      uint256[] memory tokensBalances\n    )\n  {\n    nativeBalance = account.balance;\n\n    (\n      ,\n      tokenHoldingBalance,\n      tokenTotalRewards\n    ) = token.getBalanceSummary(account);\n\n    uint256 len = tokens.length;\n\n    if (len != 0) {\n      tokensBalances = new uint256[](len);\n\n      for (uint256 index ; index < len ; index++) {\n        address token_ = tokens[index];\n        uint256 tokenCode;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly { tokenCode := extcodesize(token_) } // contract code size\n\n        if (tokenCode != 0) {\n          // solhint-disable-next-line avoid-low-level-calls\n          (bool methodExists,) = token_.staticcall(abi.encodeWithSelector(\n            IERC20(token_).balanceOf.selector,\n            account\n          ));\n\n          if (methodExists) {\n            tokensBalances[index] = IERC20(token_).balanceOf(account);\n          }\n        }\n      }\n    }\n\n    return (\n      nativeBalance,\n      tokenHoldingBalance,\n      tokenTotalRewards,\n      tokensBalances\n    );\n  }\n}\n"
    },
    "src/pancakeswap/PancakeRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/* solhint-disable */\npragma solidity ^0.6.12;\n\nimport '../core/erc20/IERC20.sol';\nimport '../core/erc20/IWrappedNative.sol';\nimport '../core/math/SafeMathLib.sol';\nimport '../uniswapV2/IUniswapV2Factory.sol';\nimport '../uniswapV2/IUniswapV2Pair.sol';\nimport '../uniswapV2/IUniswapV2Router02.sol';\nimport './PancakeLibrary.sol';\nimport './PancakeTransferHelper.sol';\n\n\n/**\n * @title Pancake router\n *\n * @notice Based on https://github.com/pancakeswap/pancake-swap-periphery/blob/d769a6d136b74fde82502ec2f9334acc1afc0732/contracts/PancakeRouter.sol\n */\ncontract PancakeRouter is IUniswapV2Router02 {\n  using SafeMathLib for uint;\n\n  address public immutable override factory;\n  address public immutable override WETH;\n\n  // modifiers\n\n  modifier ensure(uint deadline) {\n    require(deadline >= block.timestamp, 'PancakeRouter: EXPIRED');\n    _;\n  }\n\n  constructor(address _factory, address _WETH) public {\n    factory = _factory;\n    WETH = _WETH;\n  }\n\n  // external functions\n\n  receive()\n    external\n    payable\n  {\n    assert(msg.sender == WETH);\n    // only accept ETH via fallback from the WETH contract\n  }\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n  )\n    external\n    override\n    ensure(deadline)\n    returns (uint amountA, uint amountB, uint liquidity)\n  {\n    (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n    address pair = PancakeLibrary.pairFor(factory, tokenA, tokenB);\n    PancakeTransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n    PancakeTransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n    liquidity = IUniswapV2Pair(pair).mint(to);\n  }\n\n  function addLiquidityETH(\n    address token,\n    uint amountTokenDesired,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  )\n    external\n    override\n    payable\n    ensure(deadline)\n    returns (uint amountToken, uint amountETH, uint liquidity)\n  {\n    (amountToken, amountETH) = _addLiquidity(\n      token,\n      WETH,\n      amountTokenDesired,\n      msg.value,\n      amountTokenMin,\n      amountETHMin\n    );\n    address pair = PancakeLibrary.pairFor(factory, token, WETH);\n    PancakeTransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n    IWrappedNative(WETH).deposit{value : amountETH}();\n    assert(IWrappedNative(WETH).transfer(pair, amountETH));\n    liquidity = IUniswapV2Pair(pair).mint(to);\n    // refund dust eth, if any\n    if (msg.value > amountETH) PancakeTransferHelper.safeTransferBNB(msg.sender, msg.value - amountETH);\n  }\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\n  )\n    external\n    override\n    returns (uint amountToken, uint amountETH)\n  {\n    address pair = PancakeLibrary.pairFor(factory, token, WETH);\n    uint value = approveMax ? uint(- 1) : liquidity;\n    IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n    (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n  }\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline,\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\n  )\n    external\n    override\n    returns (uint amountA, uint amountB)\n  {\n    address pair = PancakeLibrary.pairFor(factory, tokenA, tokenB);\n    uint value = approveMax ? uint(- 1) : liquidity;\n    IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n    (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\n  }\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\n  )\n    external\n    override\n    returns (uint amountETH)\n  {\n    address pair = PancakeLibrary.pairFor(factory, token, WETH);\n    uint value = approveMax ? uint(- 1) : liquidity;\n    IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n    amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\n      token, liquidity, amountTokenMin, amountETHMin, to, deadline\n    );\n  }\n\n  function swapExactTokensForTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    override\n    ensure(deadline)\n    returns (uint[] memory amounts)\n  {\n    amounts = PancakeLibrary.getAmountsOut(factory, amountIn, path);\n    require(amounts[amounts.length - 1] >= amountOutMin, 'PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT');\n    PancakeTransferHelper.safeTransferFrom(\n      path[0], msg.sender, PancakeLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n    );\n    _swap(amounts, path, to);\n  }\n\n  function swapTokensForExactTokens(\n    uint amountOut,\n    uint amountInMax,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    override\n    ensure(deadline)\n    returns (uint[] memory amounts)\n  {\n    amounts = PancakeLibrary.getAmountsIn(factory, amountOut, path);\n    require(amounts[0] <= amountInMax, 'PancakeRouter: EXCESSIVE_INPUT_AMOUNT');\n    PancakeTransferHelper.safeTransferFrom(\n      path[0], msg.sender, PancakeLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n    );\n    _swap(amounts, path, to);\n  }\n\n  function swapExactETHForTokens(\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    override\n    payable\n    ensure(deadline)\n    returns (uint[] memory amounts)\n  {\n    require(path[0] == WETH, 'PancakeRouter: INVALID_PATH');\n    amounts = PancakeLibrary.getAmountsOut(factory, msg.value, path);\n    require(amounts[amounts.length - 1] >= amountOutMin, 'PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT');\n    IWrappedNative(WETH).deposit{value : amounts[0]}();\n    assert(IWrappedNative(WETH).transfer(PancakeLibrary.pairFor(factory, path[0], path[1]), amounts[0]));\n    _swap(amounts, path, to);\n  }\n\n  function swapTokensForExactETH(\n    uint amountOut,\n    uint amountInMax,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    override\n    ensure(deadline)\n    returns (uint[] memory amounts)\n  {\n    require(path[path.length - 1] == WETH, 'PancakeRouter: INVALID_PATH');\n    amounts = PancakeLibrary.getAmountsIn(factory, amountOut, path);\n    require(amounts[0] <= amountInMax, 'PancakeRouter: EXCESSIVE_INPUT_AMOUNT');\n    PancakeTransferHelper.safeTransferFrom(\n      path[0], msg.sender, PancakeLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n    );\n    _swap(amounts, path, address(this));\n    IWrappedNative(WETH).withdraw(amounts[amounts.length - 1]);\n    PancakeTransferHelper.safeTransferBNB(to, amounts[amounts.length - 1]);\n  }\n\n  function swapExactTokensForETH(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    override\n    ensure(deadline)\n    returns (uint[] memory amounts)\n  {\n    require(path[path.length - 1] == WETH, 'PancakeRouter: INVALID_PATH');\n    amounts = PancakeLibrary.getAmountsOut(factory, amountIn, path);\n    require(amounts[amounts.length - 1] >= amountOutMin, 'PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT');\n    PancakeTransferHelper.safeTransferFrom(\n      path[0], msg.sender, PancakeLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n    );\n    _swap(amounts, path, address(this));\n    IWrappedNative(WETH).withdraw(amounts[amounts.length - 1]);\n    PancakeTransferHelper.safeTransferBNB(to, amounts[amounts.length - 1]);\n  }\n\n  function swapETHForExactTokens(\n    uint amountOut,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    override\n    payable\n    ensure(deadline)\n    returns (uint[] memory amounts)\n  {\n    require(path[0] == WETH, 'PancakeRouter: INVALID_PATH');\n    amounts = PancakeLibrary.getAmountsIn(factory, amountOut, path);\n    require(amounts[0] <= msg.value, 'PancakeRouter: EXCESSIVE_INPUT_AMOUNT');\n    IWrappedNative(WETH).deposit{value : amounts[0]}();\n    assert(IWrappedNative(WETH).transfer(PancakeLibrary.pairFor(factory, path[0], path[1]), amounts[0]));\n    _swap(amounts, path, to);\n    // refund dust eth, if any\n    if (msg.value > amounts[0]) PancakeTransferHelper.safeTransferBNB(msg.sender, msg.value - amounts[0]);\n  }\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    override\n    ensure(deadline)\n  {\n    PancakeTransferHelper.safeTransferFrom(\n      path[0], msg.sender, PancakeLibrary.pairFor(factory, path[0], path[1]), amountIn\n    );\n    uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n    _swapSupportingFeeOnTransferTokens(path, to);\n    require(\n      IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n      'PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT'\n    );\n  }\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    override\n    payable\n    ensure(deadline)\n  {\n    require(path[0] == WETH, 'PancakeRouter: INVALID_PATH');\n    uint amountIn = msg.value;\n    IWrappedNative(WETH).deposit{value : amountIn}();\n    assert(IWrappedNative(WETH).transfer(PancakeLibrary.pairFor(factory, path[0], path[1]), amountIn));\n    uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n    _swapSupportingFeeOnTransferTokens(path, to);\n    require(\n      IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n      'PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT'\n    );\n  }\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    override\n    ensure(deadline)\n  {\n    require(path[path.length - 1] == WETH, 'PancakeRouter: INVALID_PATH');\n    PancakeTransferHelper.safeTransferFrom(\n      path[0], msg.sender, PancakeLibrary.pairFor(factory, path[0], path[1]), amountIn\n    );\n    _swapSupportingFeeOnTransferTokens(path, address(this));\n    uint amountOut = IERC20(WETH).balanceOf(address(this));\n    require(amountOut >= amountOutMin, 'PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT');\n    IWrappedNative(WETH).withdraw(amountOut);\n    PancakeTransferHelper.safeTransferBNB(to, amountOut);\n  }\n\n  // public functions\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n  )\n    public\n    override\n    ensure(deadline)\n    returns (uint amountA, uint amountB)\n  {\n    address pair = PancakeLibrary.pairFor(factory, tokenA, tokenB);\n    IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity);\n    // send liquidity to pair\n    (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);\n    (address token0,) = PancakeLibrary.sortTokens(tokenA, tokenB);\n    (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n    require(amountA >= amountAMin, 'PancakeRouter: INSUFFICIENT_A_AMOUNT');\n    require(amountB >= amountBMin, 'PancakeRouter: INSUFFICIENT_B_AMOUNT');\n  }\n\n  function removeLiquidityETH(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  )\n    public\n    override\n    ensure(deadline)\n    returns (uint amountToken, uint amountETH)\n  {\n    (amountToken, amountETH) = removeLiquidity(\n      token,\n      WETH,\n      liquidity,\n      amountTokenMin,\n      amountETHMin,\n      address(this),\n      deadline\n    );\n    PancakeTransferHelper.safeTransfer(token, to, amountToken);\n    IWrappedNative(WETH).withdraw(amountETH);\n    PancakeTransferHelper.safeTransferBNB(to, amountETH);\n  }\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  )\n    public\n    override\n    ensure(deadline)\n    returns (uint amountETH)\n  {\n    (, amountETH) = removeLiquidity(\n      token,\n      WETH,\n      liquidity,\n      amountTokenMin,\n      amountETHMin,\n      address(this),\n      deadline\n    );\n    PancakeTransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\n    IWrappedNative(WETH).withdraw(amountETH);\n    PancakeTransferHelper.safeTransferBNB(to, amountETH);\n  }\n\n  // public function (views)\n\n  function getAmountsOut(\n    uint amountIn,\n    address[] memory path\n  )\n    public\n    view\n    override\n    returns (uint[] memory amounts)\n  {\n    return PancakeLibrary.getAmountsOut(factory, amountIn, path);\n  }\n\n  function getAmountsIn(\n    uint amountOut,\n    address[] memory path\n  )\n    public\n    view\n    override\n    returns (uint[] memory amounts)\n  {\n    return PancakeLibrary.getAmountsIn(factory, amountOut, path);\n  }\n\n  // public function (pure)\n\n  function quote(\n    uint amountA,\n    uint reserveA,\n    uint reserveB\n  )\n    public\n    pure\n    override\n    returns (uint amountB)\n  {\n    return PancakeLibrary.quote(amountA, reserveA, reserveB);\n  }\n\n  function getAmountOut(\n    uint amountIn,\n    uint reserveIn,\n    uint reserveOut\n  )\n    public\n    pure\n    override\n    returns (uint amountOut)\n  {\n    return PancakeLibrary.getAmountOut(amountIn, reserveIn, reserveOut);\n  }\n\n  function getAmountIn(\n    uint amountOut,\n    uint reserveIn,\n    uint reserveOut\n  )\n    public\n    pure\n    override\n    returns (uint amountIn)\n  {\n    return PancakeLibrary.getAmountIn(amountOut, reserveIn, reserveOut);\n  }\n\n  // private functions\n\n  function _addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin\n  )\n    private\n    returns (uint amountA, uint amountB)\n  {\n    // create the pair if it doesn't exist yet\n    if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\n      IUniswapV2Factory(factory).createPair(tokenA, tokenB);\n    }\n    (uint reserveA, uint reserveB) = PancakeLibrary.getReserves(factory, tokenA, tokenB);\n    if (reserveA == 0 && reserveB == 0) {\n      (amountA, amountB) = (amountADesired, amountBDesired);\n    } else {\n      uint amountBOptimal = PancakeLibrary.quote(amountADesired, reserveA, reserveB);\n      if (amountBOptimal <= amountBDesired) {\n        require(amountBOptimal >= amountBMin, 'PancakeRouter: INSUFFICIENT_B_AMOUNT');\n        (amountA, amountB) = (amountADesired, amountBOptimal);\n      } else {\n        uint amountAOptimal = PancakeLibrary.quote(amountBDesired, reserveB, reserveA);\n        assert(amountAOptimal <= amountADesired);\n        require(amountAOptimal >= amountAMin, 'PancakeRouter: INSUFFICIENT_A_AMOUNT');\n        (amountA, amountB) = (amountAOptimal, amountBDesired);\n      }\n    }\n  }\n\n  function _swap(\n    uint[] memory amounts,\n    address[] memory path,\n    address _to\n  )\n    private\n  {\n    for (uint i; i < path.length - 1; i++) {\n      (address input, address output) = (path[i], path[i + 1]);\n      (address token0,) = PancakeLibrary.sortTokens(input, output);\n      uint amountOut = amounts[i + 1];\n      (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n      address to = i < path.length - 2 ? PancakeLibrary.pairFor(factory, output, path[i + 2]) : _to;\n      IUniswapV2Pair(PancakeLibrary.pairFor(factory, input, output)).swap(\n        amount0Out, amount1Out, to, new bytes(0)\n      );\n    }\n  }\n\n  function _swapSupportingFeeOnTransferTokens(\n    address[] memory path,\n    address _to\n  )\n    private\n  {\n    for (uint i; i < path.length - 1; i++) {\n      (address input, address output) = (path[i], path[i + 1]);\n      (address token0,) = PancakeLibrary.sortTokens(input, output);\n      IUniswapV2Pair pair = IUniswapV2Pair(PancakeLibrary.pairFor(factory, input, output));\n      uint amountInput;\n      uint amountOutput;\n      {// scope to avoid stack too deep errors\n        (uint reserve0, uint reserve1,) = pair.getReserves();\n        (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n        amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\n        amountOutput = PancakeLibrary.getAmountOut(amountInput, reserveInput, reserveOutput);\n      }\n      (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n      address to = i < path.length - 2 ? PancakeLibrary.pairFor(factory, output, path[i + 2]) : _to;\n      pair.swap(amount0Out, amount1Out, to, new bytes(0));\n    }\n  }\n}\n"
    },
    "src/core/erc20/IWrappedNative.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\nimport \"./IERC20.sol\";\n\n\n/**\n * @title Wrapped native (eg. WBNB, WETH) token interface\n *\n * @notice Based on https://github.com/Uniswap/uniswap-v2-periphery/blob/dda62473e2da448bc9cb8f4514dadda4aeede5f4/contracts/interfaces/IWETH.sol\n */\ninterface IWrappedNative is IERC20 {\n  // external functions\n\n  function deposit()\n    external\n    payable;\n\n  function withdraw(\n    uint256 amount\n  )\n    external;\n}\n"
    },
    "src/uniswapV2/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\n/**\n * @title Uniswap v2 factory interface\n *\n * @notice Based on https://github.com/Uniswap/uniswap-v2-core/blob/4dd59067c76dea4a0e8e4bfdda41877a6b16dedc/contracts/interfaces/IUniswapV2Factory.sol\n */\ninterface IUniswapV2Factory {\n  // events\n\n  event PairCreated(\n    address indexed token0,\n    address indexed token1,\n    address pair,\n    uint256\n  );\n\n  // external functions\n\n  function createPair(\n    address tokenA,\n    address tokenB\n  )\n    external\n    returns (address);\n\n  function setFeeTo(\n    address\n  )\n    external;\n\n  function setFeeToSetter(\n    address\n  )\n    external;\n\n  // external functions (views)\n\n  function feeTo()\n    external\n    view\n    returns (address);\n\n  function feeToSetter()\n    external\n    view\n    returns (address);\n\n  function getPair(\n    address tokenA,\n    address tokenB\n  )\n    external\n    view\n    returns (address);\n\n  function allPairs(\n    uint256\n  )\n    external\n    view\n    returns (address);\n\n  function allPairsLength()\n    external\n    view\n    returns (uint256);\n}\n\n"
    },
    "src/uniswapV2/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/* solhint-disable func-name-mixedcase */\npragma solidity ^0.6.12;\n\nimport \"../core/erc20/IERC20.sol\";\n\n\n/**\n * @title Uniswap V2 pair interface\n *\n * @notice Based on https://github.com/Uniswap/uniswap-v2-core/blob/4dd59067c76dea4a0e8e4bfdda41877a6b16dedc/contracts/interfaces/IUniswapV2Pair.sol\n */\ninterface IUniswapV2Pair is IERC20 {\n  // events\n\n  event Mint(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1\n  );\n\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n\n  event Sync(\n    uint112 reserve0,\n    uint112 reserve1\n  );\n\n  // external functions\n\n  function initialize(\n    address,\n    address\n  )\n    external;\n\n  function mint(\n    address to\n  )\n    external\n    returns (uint256);\n\n  function burn(\n    address to\n  )\n    external\n    returns (uint256, uint256);\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  )\n    external;\n\n  function skim(\n    address to\n  )\n    external;\n\n  function sync()\n    external;\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external;\n\n  // external functions (views)\n\n  function DOMAIN_SEPARATOR()\n    external\n    view\n    returns (bytes32);\n\n  function nonces(\n    address owner\n  )\n    external\n    view\n    returns (uint256);\n\n  function factory()\n    external\n    view\n    returns (address);\n\n  function token0()\n    external\n    view\n    returns (address);\n\n  function token1()\n    external\n    view\n    returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (uint112, uint112, uint32);\n\n  function price0CumulativeLast()\n    external\n    view\n    returns (uint256);\n\n  function price1CumulativeLast()\n    external\n    view\n    returns (uint256);\n\n  function kLast()\n    external\n    view\n    returns (uint256);\n\n  // external functions (pure)\n\n  function PERMIT_TYPEHASH()\n    external\n    pure\n    returns (bytes32);\n\n  function MINIMUM_LIQUIDITY()\n    external\n    pure\n    returns (uint256);\n}\n"
    },
    "src/uniswapV2/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\nimport \"./IUniswapV2Router01.sol\";\n\n\n/**\n * @title Uniswap V2 router02 interface\n *\n * @notice Based on https://github.com/Uniswap/uniswap-v2-periphery/blob/dda62473e2da448bc9cb8f4514dadda4aeede5f4/contracts/interfaces/IUniswapV2Router02.sol\n */\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n  // external functions\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable;\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (uint256);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external\n    returns (uint256);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external;\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external;\n}\n"
    },
    "src/pancakeswap/PancakeLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/* solhint-disable */\npragma solidity ^0.6.12;\n\nimport \"../core/math/SafeMathLib.sol\";\nimport \"../uniswapV2/IUniswapV2Pair.sol\";\nimport \"./PancakePair.sol\";\n\n\n/**\n * @title Pancake library\n *\n * @notice Based on https://github.com/pancakeswap/pancake-swap-periphery/blob/d769a6d136b74fde82502ec2f9334acc1afc0732/contracts/libraries/PancakeLibrary.sol\n */\nlibrary PancakeLibrary {\n  using SafeMathLib for uint;\n\n  bytes32 private constant INIT_CODE_PAIR_HASH = keccak256(abi.encodePacked(type(PancakePair).creationCode));\n\n  // internal functions (pure)\n\n  function sortTokens(\n    address tokenA,\n    address tokenB\n  )\n    internal\n    pure\n    returns (address token0, address token1)\n  {\n    require(tokenA != tokenB, 'PancakeLibrary: IDENTICAL_ADDRESSES');\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), 'PancakeLibrary: ZERO_ADDRESS');\n  }\n\n  function pairFor(\n    address factory,\n    address tokenA,\n    address tokenB\n  )\n    internal\n    pure\n    returns (address pair)\n  {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = address(uint(keccak256(abi.encodePacked(\n        hex'ff',\n        factory,\n        keccak256(abi.encodePacked(token0, token1)),\n        INIT_CODE_PAIR_HASH\n      ))));\n  }\n\n  function quote(\n    uint amountA,\n    uint reserveA,\n    uint reserveB\n  )\n    internal\n    pure\n    returns (uint amountB)\n  {\n    require(amountA > 0, 'PancakeLibrary: INSUFFICIENT_AMOUNT');\n    require(reserveA > 0 && reserveB > 0, 'PancakeLibrary: INSUFFICIENT_LIQUIDITY');\n    amountB = amountA.mul(reserveB) / reserveA;\n  }\n\n  function getAmountOut(\n    uint amountIn,\n    uint reserveIn,\n    uint reserveOut\n  )\n    internal\n    pure\n    returns (uint amountOut)\n  {\n    require(amountIn > 0, 'PancakeLibrary: INSUFFICIENT_INPUT_AMOUNT');\n    require(reserveIn > 0 && reserveOut > 0, 'PancakeLibrary: INSUFFICIENT_LIQUIDITY');\n    uint amountInWithFee = amountIn.mul(998);\n    uint numerator = amountInWithFee.mul(reserveOut);\n    uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n    amountOut = numerator / denominator;\n  }\n\n  function getAmountIn(\n    uint amountOut,\n    uint reserveIn,\n    uint reserveOut\n  )\n    internal\n    pure\n    returns (uint amountIn)\n  {\n    require(amountOut > 0, 'PancakeLibrary: INSUFFICIENT_OUTPUT_AMOUNT');\n    require(reserveIn > 0 && reserveOut > 0, 'PancakeLibrary: INSUFFICIENT_LIQUIDITY');\n    uint numerator = reserveIn.mul(amountOut).mul(1000);\n    uint denominator = reserveOut.sub(amountOut).mul(998);\n    amountIn = (numerator / denominator).add(1);\n  }\n\n  // internal functions (pure)\n\n  function getReserves(\n    address factory,\n    address tokenA,\n    address tokenB\n  )\n    internal\n    view\n    returns (uint reserveA, uint reserveB)\n  {\n    (address token0,) = sortTokens(tokenA, tokenB);\n    pairFor(factory, tokenA, tokenB);\n    (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n    (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n  }\n\n  function getAmountsOut(\n    address factory,\n    uint amountIn,\n    address[] memory path\n  )\n    internal\n    view\n    returns (uint[] memory amounts)\n  {\n    require(path.length >= 2, 'PancakeLibrary: INVALID_PATH');\n    amounts = new uint[](path.length);\n    amounts[0] = amountIn;\n    for (uint i; i < path.length - 1; i++) {\n      (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n      amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n    }\n  }\n\n  function getAmountsIn(\n    address factory,\n    uint amountOut,\n    address[] memory path\n  )\n    internal\n    view\n    returns (uint[] memory amounts)\n  {\n    require(path.length >= 2, 'PancakeLibrary: INVALID_PATH');\n    amounts = new uint[](path.length);\n    amounts[amounts.length - 1] = amountOut;\n    for (uint i = path.length - 1; i > 0; i--) {\n      (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n      amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n    }\n  }\n}\n"
    },
    "src/pancakeswap/PancakeTransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/* solhint-disable */\npragma solidity ^0.6.12;\n\n/**\n * @title Pancake transfer helper library\n *\n * @notice Based on https://github.com/pancakeswap/pancake-swap-lib/blob/0c16ece6edc575dc92076245badd62cddead47b3/contracts/utils/TransferHelper.sol\n */\nlibrary PancakeTransferHelper {\n  // internal functions\n\n  function safeApprove(\n    address token,\n    address to,\n    uint256 value\n  )\n    internal\n  {\n    // bytes4(keccak256(bytes('approve(address,uint256)')));\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n    require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n  }\n\n  function safeTransfer(\n    address token,\n    address to,\n    uint256 value\n  )\n    internal\n  {\n    // bytes4(keccak256(bytes('transfer(address,uint256)')));\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n    require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n  }\n\n  function safeTransferFrom(\n    address token,\n    address from,\n    address to,\n    uint256 value\n  )\n    internal\n  {\n    // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n    require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n  }\n\n  function safeTransferBNB(\n    address to,\n    uint256 value\n  )\n    internal\n  {\n    (bool success,) = to.call{value : value}(new bytes(0));\n    require(success, 'TransferHelper: BNB_TRANSFER_FAILED');\n  }\n}\n"
    },
    "src/uniswapV2/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/* solhint-disable func-name-mixedcase */\npragma solidity ^0.6.12;\n\n/**\n * @title Uniswap V2 router01 interface\n *\n * @notice Based on https://github.com/Uniswap/uniswap-v2-periphery/blob/dda62473e2da448bc9cb8f4514dadda4aeede5f4/contracts/interfaces/IUniswapV2Router01.sol\n */\ninterface IUniswapV2Router01 {\n  // external functions\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable\n    returns (uint256, uint256, uint256);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable\n    returns (uint256[] memory);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (uint256, uint256, uint256);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (uint256, uint256);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (uint256, uint256);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external\n    returns (uint256, uint256);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external\n    returns (uint256, uint256);\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (uint256[] memory);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (uint256[] memory);\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (uint256[] memory);\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (uint256[] memory);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable\n    returns (uint256[] memory);\n\n  // external functions (views)\n\n  function getAmountsOut(\n    uint256 amountIn,\n    address[] calldata path\n  )\n    external\n    view\n    returns (uint256[] memory);\n\n  function getAmountsIn(\n    uint256 amountOut,\n    address[] calldata path\n  )\n    external\n    view\n    returns (uint256[] memory);\n\n  // external functions (pure)\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  )\n    external\n    pure\n    returns (uint256);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  )\n    external\n    pure\n    returns (uint256);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  )\n    external\n    pure\n    returns (uint256);\n\n  function factory()\n    external\n    pure\n    returns (address);\n\n  function WETH()\n    external\n    pure\n    returns (address);\n}\n"
    },
    "src/pancakeswap/PancakePair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/* solhint-disable */\npragma solidity ^0.6.12;\n\nimport '../core/erc20/IERC20.sol';\nimport '../core/math/SafeMathLib.sol';\nimport '../uniswapV2/IUniswapV2Factory.sol';\nimport '../uniswapV2/IUniswapV2Pair.sol';\nimport './IPancakeCallee.sol';\nimport './PancakeMath.sol';\nimport './PancakeUQ112x112.sol';\n\n\n/**\n * @title Pancake pair\n *\n * @notice Based on https://github.com/pancakeswap/pancake-swap-core/blob/3b214306770e86bc3a64e67c2b5bdb566b4e94a7/contracts/PancakePair.sol\n */\ncontract PancakePair is IUniswapV2Pair {\n  using SafeMathLib for uint;\n  using PancakeUQ112x112 for uint224;\n\n  uint public constant override MINIMUM_LIQUIDITY = 10 ** 3;\n  bytes32 public constant override PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9; // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n  bytes32 public override DOMAIN_SEPARATOR;\n\n  string public override name = 'Pancake LPs';\n  string public override symbol = 'Cake-LP';\n  uint8 public override decimals = 18;\n  uint public override totalSupply;\n\n  mapping(address => uint) public override balanceOf;\n  mapping(address => mapping(address => uint)) public override allowance;\n  mapping(address => uint) public override nonces;\n\n  address public override factory;\n  address public override token0;\n  address public override token1;\n\n  uint public override price0CumulativeLast;\n  uint public override price1CumulativeLast;\n  uint public override kLast;\n\n  bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n\n  uint112 private reserve0;\n  uint112 private reserve1;\n  uint32 private blockTimestampLast;\n  uint private unlocked = 1;\n\n  // modifiers\n\n  modifier lock() {\n    require(unlocked == 1, 'Pancake: LOCKED');\n    unlocked = 0;\n    _;\n    unlocked = 1;\n  }\n\n  // events\n\n  event Mint(\n    address indexed sender,\n    uint amount0,\n    uint amount1\n  );\n\n  event Burn(\n    address indexed sender,\n    uint amount0,\n    uint amount1,\n    address indexed to\n  );\n\n  event Swap(\n    address indexed sender,\n    uint amount0In,\n    uint amount1In,\n    uint amount0Out,\n    uint amount1Out,\n    address indexed to\n  );\n\n  event Sync(\n    uint112 reserve0,\n    uint112 reserve1\n  );\n\n  constructor()\n    public\n  {\n    factory = msg.sender;\n\n    uint chainId;\n\n    assembly {\n      chainId := chainid()\n    }\n\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n        keccak256(bytes(name)),\n        keccak256(bytes('1')),\n        chainId,\n        address(this)\n      )\n    );\n  }\n\n  // external functions\n\n  function initialize(\n    address _token0,\n    address _token1\n  )\n    external\n    override\n  {\n    require(msg.sender == factory, 'Pancake: FORBIDDEN');\n    // sufficient check\n    token0 = _token0;\n    token1 = _token1;\n  }\n\n  function approve(\n    address spender,\n    uint value\n  )\n    external\n    override\n    returns (bool)\n  {\n    _approve(msg.sender, spender, value);\n    return true;\n  }\n\n  function transfer(address to, uint value)\n    external\n    override\n    returns (bool)\n  {\n    _transfer(msg.sender, to, value);\n    return true;\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint value\n  )\n    external\n    override\n    returns (bool)\n  {\n    if (allowance[from][msg.sender] != uint(- 1)) {\n      allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n    }\n    _transfer(from, to, value);\n    return true;\n  }\n\n  function permit(\n    address owner,\n    address spender,\n    uint value,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external\n    override\n  {\n    require(deadline >= block.timestamp, 'Pancake: EXPIRED');\n    bytes32 digest = keccak256(\n      abi.encodePacked(\n        '\\x19\\x01',\n        DOMAIN_SEPARATOR,\n        keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n      )\n    );\n    address recoveredAddress = ecrecover(digest, v, r, s);\n    require(recoveredAddress != address(0) && recoveredAddress == owner, 'Pancake: INVALID_SIGNATURE');\n    _approve(owner, spender, value);\n  }\n\n  function mint(\n    address to\n  )\n    external\n    override\n    lock\n    returns (uint liquidity)\n  {\n    (uint112 _reserve0, uint112 _reserve1,) = getReserves();\n    // gas savings\n    uint balance0 = IERC20(token0).balanceOf(address(this));\n    uint balance1 = IERC20(token1).balanceOf(address(this));\n    uint amount0 = balance0.sub(_reserve0);\n    uint amount1 = balance1.sub(_reserve1);\n\n    bool feeOn = _mintFee(_reserve0, _reserve1);\n    uint _totalSupply = totalSupply;\n    // gas savings, must be defined here since totalSupply can update in _mintFee\n    if (_totalSupply == 0) {\n      liquidity = PancakeMath.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n      _mint(address(0), MINIMUM_LIQUIDITY);\n      // permanently lock the first MINIMUM_LIQUIDITY tokens\n    } else {\n      liquidity = PancakeMath.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n    }\n    require(liquidity > 0, 'Pancake: INSUFFICIENT_LIQUIDITY_MINTED');\n    _mint(to, liquidity);\n\n    _update(balance0, balance1, _reserve0, _reserve1);\n    if (feeOn) kLast = uint(reserve0).mul(reserve1);\n    // reserve0 and reserve1 are up-to-date\n    emit Mint(msg.sender, amount0, amount1);\n  }\n\n  function burn(\n    address to\n  )\n    external\n    override\n    lock\n    returns (uint amount0, uint amount1)\n  {\n    (uint112 _reserve0, uint112 _reserve1,) = getReserves();\n    // gas savings\n    address _token0 = token0;\n    // gas savings\n    address _token1 = token1;\n    // gas savings\n    uint balance0 = IERC20(_token0).balanceOf(address(this));\n    uint balance1 = IERC20(_token1).balanceOf(address(this));\n    uint liquidity = balanceOf[address(this)];\n\n    bool feeOn = _mintFee(_reserve0, _reserve1);\n    uint _totalSupply = totalSupply;\n    // gas savings, must be defined here since totalSupply can update in _mintFee\n    amount0 = liquidity.mul(balance0) / _totalSupply;\n    // using balances ensures pro-rata distribution\n    amount1 = liquidity.mul(balance1) / _totalSupply;\n    // using balances ensures pro-rata distribution\n    require(amount0 > 0 && amount1 > 0, 'Pancake: INSUFFICIENT_LIQUIDITY_BURNED');\n    _burn(address(this), liquidity);\n    _safeTransfer(_token0, to, amount0);\n    _safeTransfer(_token1, to, amount1);\n    balance0 = IERC20(_token0).balanceOf(address(this));\n    balance1 = IERC20(_token1).balanceOf(address(this));\n\n    _update(balance0, balance1, _reserve0, _reserve1);\n    if (feeOn) kLast = uint(reserve0).mul(reserve1);\n    // reserve0 and reserve1 are up-to-date\n    emit Burn(msg.sender, amount0, amount1, to);\n  }\n\n  function swap(\n    uint amount0Out,\n    uint amount1Out,\n    address to,\n    bytes calldata data\n  )\n    external\n    override\n    lock\n  {\n    require(amount0Out > 0 || amount1Out > 0, 'Pancake: INSUFFICIENT_OUTPUT_AMOUNT');\n    (uint112 _reserve0, uint112 _reserve1,) = getReserves();\n    // gas savings\n    require(amount0Out < _reserve0 && amount1Out < _reserve1, 'Pancake: INSUFFICIENT_LIQUIDITY');\n\n    uint balance0;\n    uint balance1;\n    {// scope for _token{0,1}, avoids stack too deep errors\n      address _token0 = token0;\n      address _token1 = token1;\n      require(to != _token0 && to != _token1, 'Pancake: INVALID_TO');\n      if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out);\n      // optimistically transfer tokens\n      if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out);\n      // optimistically transfer tokens\n      if (data.length > 0) IPancakeCallee(to).pancakeCall(msg.sender, amount0Out, amount1Out, data);\n      balance0 = IERC20(_token0).balanceOf(address(this));\n      balance1 = IERC20(_token1).balanceOf(address(this));\n    }\n    uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n    uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n    require(amount0In > 0 || amount1In > 0, 'Pancake: INSUFFICIENT_INPUT_AMOUNT');\n    {// scope for reserve{0,1}Adjusted, avoids stack too deep errors\n      uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(2));\n      uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(2));\n      require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000 ** 2), 'Pancake: K');\n    }\n\n    _update(balance0, balance1, _reserve0, _reserve1);\n    emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n  }\n\n  function skim(\n    address to\n  )\n    external\n    override\n    lock\n  {\n    address _token0 = token0;\n    // gas savings\n    address _token1 = token1;\n    // gas savings\n    _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\n    _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\n  }\n\n  function sync()\n    external\n    override\n    lock\n  {\n    _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\n  }\n\n  // public functions (views)\n\n  function getReserves()\n    public\n    override\n    view\n    returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast)\n  {\n    _reserve0 = reserve0;\n    _reserve1 = reserve1;\n    _blockTimestampLast = blockTimestampLast;\n  }\n\n  // private functions\n\n  function _mint(\n    address to,\n    uint value\n  )\n    private\n  {\n    totalSupply = totalSupply.add(value);\n    balanceOf[to] = balanceOf[to].add(value);\n    emit Transfer(address(0), to, value);\n  }\n\n  function _burn(\n    address from,\n    uint value\n  )\n    private\n  {\n    balanceOf[from] = balanceOf[from].sub(value);\n    totalSupply = totalSupply.sub(value);\n    emit Transfer(from, address(0), value);\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint value\n  )\n    private\n  {\n    allowance[owner][spender] = value;\n    emit Approval(owner, spender, value);\n  }\n\n  function _transfer(\n    address from,\n    address to,\n    uint value\n  )\n    private\n  {\n    balanceOf[from] = balanceOf[from].sub(value);\n    balanceOf[to] = balanceOf[to].add(value);\n    emit Transfer(from, to, value);\n  }\n\n  function _safeTransfer(\n    address token,\n    address to,\n    uint value\n  )\n    private\n  {\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n    require(success && (data.length == 0 || abi.decode(data, (bool))), 'Pancake: TRANSFER_FAILED');\n  }\n\n  function _update(\n    uint balance0,\n    uint balance1,\n    uint112 _reserve0,\n    uint112 _reserve1\n  )\n    private\n  {\n    require(balance0 <= uint112(- 1) && balance1 <= uint112(- 1), 'Pancake: OVERFLOW');\n    uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\n    uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n    // overflow is desired\n    if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n      // * never overflows, and + overflow is desired\n      price0CumulativeLast += uint(PancakeUQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n      price1CumulativeLast += uint(PancakeUQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n    }\n    reserve0 = uint112(balance0);\n    reserve1 = uint112(balance1);\n    blockTimestampLast = blockTimestamp;\n    emit Sync(reserve0, reserve1);\n  }\n\n  function _mintFee(\n    uint112 _reserve0,\n    uint112 _reserve1\n  )\n    private\n    returns (bool feeOn)\n  {\n    address feeTo = IUniswapV2Factory(factory).feeTo();\n    feeOn = feeTo != address(0);\n    uint _kLast = kLast;\n    // gas savings\n    if (feeOn) {\n      if (_kLast != 0) {\n        uint rootK = PancakeMath.sqrt(uint(_reserve0).mul(_reserve1));\n        uint rootKLast = PancakeMath.sqrt(_kLast);\n        if (rootK > rootKLast) {\n          uint numerator = totalSupply.mul(rootK.sub(rootKLast));\n          uint denominator = rootK.mul(3).add(rootKLast);\n          uint liquidity = numerator / denominator;\n          if (liquidity > 0) _mint(feeTo, liquidity);\n        }\n      }\n    } else if (_kLast != 0) {\n      kLast = 0;\n    }\n  }\n}\n"
    },
    "src/pancakeswap/IPancakeCallee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\n/**\n * @title Pancake callee interfaces\n *\n * @notice Based on https://github.com/pancakeswap/pancake-swap-core/blob/3b214306770e86bc3a64e67c2b5bdb566b4e94a7/contracts/interfaces/IPancakeCallee.sol\n */\ninterface IPancakeCallee {\n  // external functions\n\n  function pancakeCall(\n    address sender,\n    uint amount0,\n    uint amount1,\n    bytes calldata data\n  )\n    external;\n}\n"
    },
    "src/pancakeswap/PancakeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/* solhint-disable */\npragma solidity ^0.6.12;\n\n/**\n * @title Pancake math library\n *\n * @notice Based on https://github.com/pancakeswap/pancake-swap-core/blob/3b214306770e86bc3a64e67c2b5bdb566b4e94a7/contracts/libraries/Math.sol\n */\nlibrary PancakeMath {\n  // internal functions (pure)\n\n  function min(\n    uint x,\n    uint y\n  )\n    internal\n    pure\n    returns (uint)\n  {\n    return x < y ? x : y;\n  }\n\n  function sqrt(\n    uint y\n  )\n    internal\n    pure\n    returns (uint z)\n  {\n    if (y > 3) {\n      z = y;\n      uint x = y / 2 + 1;\n      while (x < z) {\n        z = x;\n        x = (y / x + x) / 2;\n      }\n    } else if (y != 0) {\n      z = 1;\n    }\n\n    return z;\n  }\n}\n"
    },
    "src/pancakeswap/PancakeUQ112x112.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/* solhint-disable */\npragma solidity ^0.6.12;\n\n/**\n * @title Pancake UQ112x112 library\n *\n * @notice Based on https://github.com/pancakeswap/pancake-swap-core/blob/3b214306770e86bc3a64e67c2b5bdb566b4e94a7/contracts/libraries/UQ112x112.sol\n */\nlibrary PancakeUQ112x112 {\n  uint224 internal constant Q112 = 2 ** 112;\n\n  // internal functions (pure)\n\n  function encode(\n    uint112 y\n  )\n    internal\n    pure\n    returns (uint224)\n  {\n    return uint224(y) * Q112;\n  }\n\n  function uqdiv(\n    uint224 x,\n    uint112 y\n  )\n    internal\n    pure\n    returns (uint224)\n  {\n    return x / uint224(y);\n  }\n}\n"
    },
    "src/pancakeswap/PancakeFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/* solhint-disable */\npragma solidity ^0.6.12;\n\nimport '../uniswapV2/IUniswapV2Factory.sol';\nimport '../uniswapV2/IUniswapV2Pair.sol';\nimport './PancakePair.sol';\n\n\n/**\n * @title Pancake factory\n *\n * @notice Based on https://github.com/pancakeswap/pancake-swap-core/blob/3b214306770e86bc3a64e67c2b5bdb566b4e94a7/contracts/PancakeFactory.sol\n */\ncontract PancakeFactory is IUniswapV2Factory {\n  address public override feeTo;\n  address public override feeToSetter;\n\n  mapping(address => mapping(address => address)) public override getPair;\n  address[] public override allPairs;\n\n  constructor(\n    address _feeToSetter\n  )\n    public\n  {\n    feeToSetter = _feeToSetter;\n  }\n\n  // external functions\n\n  function createPair(\n    address tokenA,\n    address tokenB\n  )\n    external\n    override\n    returns (address pair)\n  {\n    require(tokenA != tokenB, 'Pancake: IDENTICAL_ADDRESSES');\n    (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), 'Pancake: ZERO_ADDRESS');\n    require(getPair[token0][token1] == address(0), 'Pancake: PAIR_EXISTS');\n    // single check is sufficient\n    bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n\n    pair = address(new PancakePair{salt: salt}());\n\n    IUniswapV2Pair(pair).initialize(token0, token1);\n    getPair[token0][token1] = pair;\n    getPair[token1][token0] = pair;\n    // populate mapping in the reverse direction\n    allPairs.push(pair);\n    emit PairCreated(token0, token1, pair, allPairs.length);\n  }\n\n  function setFeeTo(\n    address _feeTo\n  )\n    external\n    override\n  {\n    require(msg.sender == feeToSetter, 'Pancake: FORBIDDEN');\n    feeTo = _feeTo;\n  }\n\n  function setFeeToSetter(\n    address _feeToSetter\n  )\n    external\n    override\n  {\n    require(msg.sender == feeToSetter, 'Pancake: FORBIDDEN');\n    feeToSetter = _feeToSetter;\n  }\n\n  // external functions (views)\n\n  function allPairsLength()\n    external\n    override\n    view\n    returns (uint)\n  {\n    return allPairs.length;\n  }\n}\n"
    },
    "src/MetaheroLPMForUniswapV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./core/erc20/IWrappedNative.sol\";\nimport \"./uniswapV2/IUniswapV2Factory.sol\";\nimport \"./uniswapV2/IUniswapV2Pair.sol\";\nimport \"./uniswapV2/IUniswapV2Router02.sol\";\nimport \"./MetaheroLPM.sol\";\n\n\n/**\n * @title Metahero liquidity pool manager for Uniswap v2\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract MetaheroLPMForUniswapV2 is MetaheroLPM {\n  struct Settings {\n    uint256 enableBurnLPAtValue; // value of the tokens that turned on the burnLP method\n    address stableCoin; // stable coin address eg. BUSD, DAI\n  }\n\n  /**\n   * @return settings object\n   */\n  Settings public settings;\n\n  /**\n   * @return Uniswap V2 factory address\n   */\n  IUniswapV2Factory public uniswapFactory;\n\n  /**\n   * @return Uniswap V2 pair address\n   */\n  IUniswapV2Pair public uniswapPair;\n\n  /**\n   * @return Uniswap V2 router02 address\n   */\n  IUniswapV2Router02 public uniswapRouter;\n\n  IWrappedNative private wrappedNative;\n  bool private correctPairOrder;\n\n  // events\n\n  /**\n   * @dev Emitted the contract is initialized\n   * @param enableBurnLPAtValue value of the tokens that turned on the burnLP method\n   * @param stableCoin stable coin address eg. BUSD, DAI\n   * @param token token address\n   * @param uniswapRouter Uniswap V2 router02 address\n   * @param uniswapPair Uniswap V2 pair address\n   */\n  event Initialized(\n    uint256 enableBurnLPAtValue,\n    address stableCoin,\n    address token,\n    address uniswapRouter,\n    address uniswapPair\n  );\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    MetaheroLPM()\n  {\n    //\n  }\n\n  // external functions\n\n  /**\n   * @dev Mints stable coins to the contract\n   */\n  receive()\n    external\n    payable\n  {\n    _deposit(msg.value);\n  }\n\n  /**\n   * @dev Mints stable coins to the contract\n   */\n  function deposit()\n    external\n    payable\n  {\n    _deposit(msg.value);\n  }\n\n  /**\n   * @dev Initializes the contract\n   * @param enableBurnLPAtValue value of the tokens that turned on the burnLP method\n   * @param stableCoin stable coin address eg. BUSD, DAI\n   * @param token_ token address\n   * @param uniswapRouter_ Uniswap V2 router02 address\n   */\n  function initialize(\n    uint256 enableBurnLPAtValue,\n    address stableCoin,\n    address token_,\n    address uniswapRouter_\n  )\n    external\n    onlyInitializer\n  {\n    _initialize(token_);\n\n    if (enableBurnLPAtValue != 0) {\n      require(\n        stableCoin != address(0),\n        \"MetaheroLPMForUniswapV2#2\" // stable coin is the zero address\n      );\n\n      settings.enableBurnLPAtValue = enableBurnLPAtValue;\n      settings.stableCoin = stableCoin;\n    }\n\n    require(\n      uniswapRouter_ != address(0),\n      \"MetaheroLPMForUniswapV2#3\" // Uniswap V2 router02 is the zero address\n    );\n\n    uniswapRouter = IUniswapV2Router02(uniswapRouter_);\n    uniswapFactory = IUniswapV2Factory(uniswapRouter.factory());\n\n    wrappedNative = IWrappedNative(uniswapRouter.WETH());\n\n    // create a pair\n    uniswapPair = IUniswapV2Pair(uniswapFactory.createPair(\n      address(token),\n      address(wrappedNative)\n    ));\n\n    correctPairOrder = address(token) < address(wrappedNative);\n\n    emit Initialized(\n      enableBurnLPAtValue,\n      stableCoin,\n      token_,\n      uniswapRouter_,\n      address(uniswapPair)\n    );\n  }\n\n  // external functions (views)\n\n  /**\n   * @notice Checks when to sync the liquidity pool\n   * @param sender sender address\n   * @param recipient recipient address\n   */\n  function canSyncLP(\n    address sender,\n    address recipient\n  )\n    external\n    view\n    override\n    returns (\n      bool shouldSyncLPBefore,\n      bool shouldSyncLPAfter\n    )\n  {\n    if (sender != address(uniswapPair)) { // omit when swap HERO > BNB\n      if (recipient == address(uniswapPair)) {\n        shouldSyncLPBefore = true; // swap BNB > HERO\n      } else {\n        shouldSyncLPAfter = true;\n      }\n    }\n\n    return (shouldSyncLPBefore, shouldSyncLPAfter);\n  }\n\n  // internal functions\n\n  function _syncLP()\n    internal\n    override\n  {\n    uint256 totalAmount = token.balanceOf(address(this));\n\n    if (totalAmount >= 2) {\n      uint256 swapAmount = totalAmount.div(2);\n      uint256 liquidityAmount = totalAmount.sub(swapAmount);\n\n      // swap half for native\n      _swapTokens(swapAmount);\n\n      // add other half with received native\n      _addTokensToLiquidity(liquidityAmount);\n    }\n  }\n\n  function _burnLP(\n    uint256 amount\n  )\n    internal\n    override\n  {\n    if (settings.enableBurnLPAtValue != 0) {\n      (uint256 tokenReserve, ) = _getLiquidityReserves();\n\n      require(\n        tokenReserve != 0,\n        \"MetaheroLPMForUniswapV2#4\" // token reserve is zero\n      );\n\n      require(\n        amount <= tokenReserve,\n        \"MetaheroLPMForUniswapV2#5\" // amount higher than token reserve\n      );\n\n      uint256 tokenReserveValue = _calcTokensValue(tokenReserve);\n\n      require(\n        tokenReserveValue > settings.enableBurnLPAtValue,\n        \"MetaheroLPMForUniswapV2#6\" // burnLP disabled\n      );\n\n      uint256 amountValue = _calcTokensValue(amount);\n      uint256 maxAmountValue = tokenReserveValue.sub(settings.enableBurnLPAtValue);\n\n      require(\n        amountValue <= maxAmountValue,\n        \"MetaheroLPMForUniswapV2#7\" // amount is too high\n      );\n    }\n\n    // remove liquidity\n    _removeLiquidity();\n\n    uint256 totalAmount = token.balanceOf(address(this));\n\n    require(\n      totalAmount >= amount,\n      \"MetaheroLPMForUniswapV2#8\" // amount is too high\n    );\n\n    token.burn(amount); // burn tokens\n\n    _addTokensToLiquidity( // adds others to liquidity\n      totalAmount.sub(amount)\n    );\n  }\n\n  // private functions\n\n  function _deposit(\n    uint256 amount\n  )\n    private\n  {\n    require(\n      amount != 0,\n      \"MetaheroLPMForUniswapV2#1\" // amount is zero\n    );\n\n    wrappedNative.deposit{value: amount}();\n  }\n\n  function _swapTokens(\n    uint256 amount\n  )\n    private\n  {\n    token.approve(\n      address(uniswapRouter),\n      amount\n    );\n\n    address[] memory path = new address[](2);\n\n    path[0] = address(token);\n    path[1] = address(wrappedNative);\n\n    // omit revert, let's use those tokens on the next swap\n    try uniswapRouter.swapExactTokensForTokens(\n      amount,\n      0,\n      path,\n      address(this),\n      block.timestamp // solhint-disable-line not-rely-on-time\n    ) {\n      //\n    } catch {\n      //\n    }\n  }\n\n  function _addTokensToLiquidity(\n    uint256 tokensAmount\n  )\n    private\n  {\n    uint256 wrappedNativeAmount = wrappedNative.balanceOf(address(this));\n\n    if (\n      tokensAmount != 0 &&\n      wrappedNativeAmount != 0\n    ) {\n      token.approve(\n        address(uniswapRouter),\n        tokensAmount\n      );\n\n      wrappedNative.approve(\n        address(uniswapRouter),\n        wrappedNativeAmount\n      );\n\n      // omit revert, let's use those tokens on the next swap\n      try uniswapRouter.addLiquidity(\n        address(token),\n        address(wrappedNative),\n        tokensAmount,\n        wrappedNativeAmount,\n        0,\n        0,\n        address(this),\n        block.timestamp // solhint-disable-line not-rely-on-time\n      ) {\n        //\n      } catch {\n        //\n      }\n    }\n  }\n\n  function _removeLiquidity()\n    private\n  {\n    uint256 liquidity = uniswapPair.balanceOf(address(this));\n\n    if (liquidity != 0) {\n      uniswapPair.approve(\n        address(uniswapRouter),\n        liquidity\n      );\n\n      uniswapRouter.removeLiquidity(\n        address(token),\n        address(wrappedNative),\n        liquidity,\n        0,\n        0,\n        address(this),\n        block.timestamp // solhint-disable-line not-rely-on-time\n      );\n    }\n  }\n\n  // private functions (views)\n\n  function _calcTokensValue(\n    uint256 amount\n  )\n    private\n    view\n    returns (uint256)\n  {\n    address[] memory path = new address[](3);\n\n    path[0] = address(token);\n    path[1] = address(wrappedNative);\n    path[2] = settings.stableCoin;\n\n    uint256[] memory amounts = uniswapRouter.getAmountsOut(amount, path);\n\n    return amounts[2];\n  }\n\n  function _getLiquidityReserves()\n    private\n    view\n    returns (\n      uint256 tokenReserve,\n      uint256 wrappedNativeReserve\n    )\n  {\n    (\n      uint112 reserve0,\n      uint112 reserve1,\n    ) = uniswapPair.getReserves();\n\n    (tokenReserve, wrappedNativeReserve) = correctPairOrder\n      ? (reserve0, reserve1)\n      : (reserve1, reserve0);\n\n    return (tokenReserve, wrappedNativeReserve);\n  }\n}\n"
    },
    "src/MetaheroLPMMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./MetaheroLPM.sol\";\n\n\n/**\n * @title Metahero liquidity pool manager mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract MetaheroLPMMock is MetaheroLPM {\n  bool private shouldSyncLPBefore;\n  bool private shouldSyncLPAfter;\n\n  // events\n\n  event Triggered();\n\n  event LPSynced();\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    MetaheroLPM()\n  {\n    //\n  }\n\n  // external functions\n\n  function triggerOnlyToken()\n    external\n    onlyToken\n  {\n    emit Triggered();\n  }\n\n  function initialize(\n    address token_\n  )\n    external\n  {\n    _initialize(token_);\n  }\n\n  function setLocked(\n    bool locked_\n  )\n    external\n  {\n    locked = locked_;\n  }\n\n  function allowSyncLP(\n    bool shouldSyncLPBefore_,\n    bool shouldSyncLPAfter_\n  )\n    external\n  {\n    shouldSyncLPBefore = shouldSyncLPBefore_;\n    shouldSyncLPAfter = shouldSyncLPAfter_;\n  }\n\n  // external functions (views)\n\n  function canSyncLP(\n    address,\n    address\n  )\n    external\n    view\n    override\n    returns (bool, bool)\n  {\n    return (shouldSyncLPBefore, shouldSyncLPAfter);\n  }\n\n  // internal functions\n\n  function _syncLP()\n    internal\n    override\n  {\n    emit LPSynced();\n  }\n\n  function _burnLP(\n    uint256\n  )\n    internal\n    override\n  {\n    emit Triggered();\n  }\n}\n"
    },
    "src/MetaheroDAO.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./core/lifecycle/Initializable.sol\";\nimport \"./core/math/MathLib.sol\";\nimport \"./core/math/SafeMathLib.sol\";\nimport \"./IMetaheroDAO.sol\";\nimport \"./MetaheroToken.sol\";\n\n\n/**\n * @title Metahero DAO\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract MetaheroDAO is Initializable, IMetaheroDAO {\n  using MathLib for uint256;\n  using SafeMathLib for uint256;\n\n  struct Settings {\n    uint256 minVotingPeriod;\n    uint256 snapshotWindow;\n  }\n\n  struct Proposal {\n    uint256 snapshotId;\n    bytes callData;\n    uint256 startsAt;\n    uint256 endsAt;\n    bool processed;\n    uint256 votesMinPercentage;\n    uint256 votesMinWeight;\n    uint256 votesYesWeight;\n    uint256 votesNoWeight;\n    uint256 votesCount;\n    mapping (address => uint8) votes; // 1 - yes, 2 - no\n  }\n\n  struct WeightsHistory {\n    uint256[] weights;\n    uint256[] snapshotIds;\n  }\n\n  // globals\n\n  uint256 private constant MAX_VOTES_MIN_PERCENTAGE = 75; // 75%\n\n  /**\n   * @return operator address\n   */\n  address public operator;\n\n  /**\n   * @return token address\n   */\n  MetaheroToken public token;\n\n  /**\n   * @return settings object\n   */\n  Settings public settings;\n\n  mapping(uint256 => Proposal) private proposals;\n  mapping(address => WeightsHistory) private membersWeightsHistory;\n  WeightsHistory private totalWeightsHistory;\n  uint256 private proposalCounter;\n  uint256 private snapshotBaseTimestamp;\n\n  // events\n\n  /**\n   * @dev Emitted the contract is initialized\n   * @param token token address\n   * @param operator operator address\n   * @param minVotingPeriod min voting period\n   * @param snapshotWindow snapshot window\n   * @param snapshotBaseTimestamp snapshot base timestamp\n   */\n  event Initialized(\n    address token,\n    address operator,\n    uint256 minVotingPeriod,\n    uint256 snapshotWindow,\n    uint256 snapshotBaseTimestamp\n  );\n\n  /**\n   * @dev Emitted the proposal is created\n   * @param proposalId proposal id\n   * @param callData token call data\n   * @param snapshotId snapshot id\n   * @param startsAt starts at\n   * @param endsAt ends at\n   * @param votesMinPercentage votes min percentage\n   * @param votesMinWeight votes min weight\n   */\n  event ProposalCreated(\n    uint256 proposalId,\n    uint256 snapshotId,\n    bytes callData,\n    uint256 startsAt,\n    uint256 endsAt,\n    uint256 votesMinPercentage,\n    uint256 votesMinWeight\n  );\n\n  /**\n   * @dev Emitted the proposal is processed\n   * @param proposalId proposal id\n   * @param votesYesWeight votes yes weight\n   * @param votesNoWeight votes no weight\n   */\n  event ProposalProcessed(\n    uint256 proposalId,\n    uint256 votesYesWeight,\n    uint256 votesNoWeight\n  );\n\n  /**\n   * @dev Emitted the vote is submitted\n   * @param proposalId proposal id\n   * @param member member address\n   * @param vote where `1` eq yes and `2` eq no\n   */\n  event VoteSubmitted(\n    uint256 proposalId,\n    address member,\n    uint8 vote\n  );\n\n  // modifiers\n\n  /**\n   * @dev Throws if msg.sender is not the operator\n   */\n  modifier onlyOperator() {\n    require(\n      msg.sender == operator,\n      \"MetaheroDAO#1\" // msg.sender is not the operator\n    );\n\n    _;\n  }\n\n  /**\n   * @dev Throws if msg.sender is not the token\n   */\n  modifier onlyToken() {\n    require(\n      msg.sender == address(token),\n      \"MetaheroDAO#2\" // msg.sender is not the token\n    );\n\n    _;\n  }\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    Initializable()\n  {\n    //\n  }\n\n  // external functions\n\n  /**\n   * @dev Initializes the contract\n   * @param token_ token address\n   * @param operator_ custom operator address\n   * @param minVotingPeriod min voting period\n   * @param snapshotWindow snapshot window\n   */\n  function initialize(\n    address token_,\n    address operator_,\n    uint256 minVotingPeriod,\n    uint256 snapshotWindow\n  )\n    external\n    onlyInitializer\n  {\n    require(\n      token_ != address(0),\n      \"MetaheroDAO#3\" // token is the zero address\n    );\n\n    require(\n      minVotingPeriod != 0,\n      \"MetaheroDAO#4\" // min voting period is zero\n    );\n\n    require(\n      snapshotWindow != 0,\n      \"MetaheroDAO#5\" // snapshot window is zero\n    );\n\n    token = MetaheroToken(token_);\n\n    if (operator_ == address(0)) {\n      operator_ = token.owner();\n    }\n\n    operator = operator_;\n\n    settings.minVotingPeriod = minVotingPeriod;\n    settings.snapshotWindow = snapshotWindow;\n\n    snapshotBaseTimestamp = block.timestamp; // solhint-disable-line not-rely-on-time\n\n    emit Initialized(\n      token_,\n      operator_,\n      minVotingPeriod,\n      snapshotWindow,\n      snapshotBaseTimestamp\n    );\n  }\n\n  /**\n   * @notice Called by a token to sync a dao member\n   * @param member member address\n   * @param memberWeight member weight\n   * @param totalWeight all members weight\n   */\n  function syncMember(\n    address member,\n    uint256 memberWeight,\n    uint256 totalWeight\n  )\n    external\n    onlyToken\n    override\n  {\n    uint256 snapshotId = _getSnapshotIdAt(block.timestamp); // solhint-disable-line not-rely-on-time\n\n    _setMemberWeight(\n      member,\n      memberWeight,\n      snapshotId\n    );\n\n    _setTotalWeight(\n      totalWeight,\n      snapshotId\n    );\n  }\n\n  /**\n   * @notice Called by a token to sync a dao members\n   * @param memberA member A address\n   * @param memberAWeight member A weight\n   * @param memberB member B address\n   * @param memberBWeight member B weight\n   * @param totalWeight all members weight\n   */\n  function syncMembers(\n    address memberA,\n    uint256 memberAWeight,\n    address memberB,\n    uint256 memberBWeight,\n    uint256 totalWeight\n  )\n    external\n    onlyToken\n    override\n  {\n    uint256 snapshotId = _getSnapshotIdAt(block.timestamp); // solhint-disable-line not-rely-on-time\n\n    _setMemberWeight(\n      memberA,\n      memberAWeight,\n      snapshotId\n    );\n\n    _setMemberWeight(\n      memberB,\n      memberBWeight,\n      snapshotId\n    );\n\n    _setTotalWeight(\n      totalWeight,\n      snapshotId\n    );\n  }\n\n  /**\n   * @dev Removes token lp fees\n   */\n  function removeTokenLPFees()\n    external\n    onlyOperator\n  {\n    (\n      MetaheroToken.Fees memory burnFees,\n      MetaheroToken.Fees memory lpFees,\n      MetaheroToken.Fees memory rewardsFees,\n    ) = token.settings();\n\n    require(\n      lpFees.sender != 0 ||\n      lpFees.recipient != 0,\n      \"MetaheroDAO#6\" // already removed\n    );\n\n    token.updateFees(\n      MetaheroToken.Fees(\n        burnFees.sender.add(lpFees.sender),\n        burnFees.recipient.add(lpFees.recipient)\n      ),\n      MetaheroToken.Fees(0, 0), // remove lp fees\n      rewardsFees\n    );\n  }\n\n  /**\n   * @dev Excludes token account\n   * @param account account address\n   * @param excludeSenderFromFee exclude sender from fee\n   * @param excludeRecipientFromFee exclude recipient from fee\n   */\n  function excludeTokenAccount(\n    address account,\n    bool excludeSenderFromFee,\n    bool excludeRecipientFromFee\n  )\n    external\n    onlyOperator\n  {\n    token.excludeAccount(\n      account,\n      excludeSenderFromFee,\n      excludeRecipientFromFee\n    );\n  }\n\n  /**\n   * @dev Creates proposal\n   * @param callData token call data\n   * @param startsIn starts in\n   * @param endsIn ends in\n   * @param votesMinPercentage votes min percentage\n   */\n  function createProposal(\n    bytes calldata callData,\n    uint256 startsIn,\n    uint256 endsIn,\n    uint256 votesMinPercentage\n  )\n    external\n    onlyOperator\n  {\n    require(\n      endsIn > startsIn,\n      \"MetaheroDAO#7\" // `ends in` should be higher than `starts in`\n    );\n\n    require(\n      endsIn.sub(startsIn) >= settings.minVotingPeriod,\n      \"MetaheroDAO#8\" // voting period is too short\n    );\n\n    proposalCounter++;\n\n    uint256 proposalId = proposalCounter;\n    uint256 snapshotId = _getSnapshotIdAt(block.timestamp); // solhint-disable-line not-rely-on-time\n    uint256 startsAt = startsIn.add(block.timestamp); // solhint-disable-line not-rely-on-time\n    uint256 endsAt = endsIn.add(block.timestamp); // solhint-disable-line not-rely-on-time\n    uint256 votesMinWeight;\n\n    if (votesMinPercentage != 0) {\n      require(\n        votesMinPercentage <= MAX_VOTES_MIN_PERCENTAGE,\n        \"MetaheroDAO#9\" // invalid votes min percentage\n      );\n\n      votesMinWeight = _getTotalWeightOnSnapshot(\n        snapshotId\n      ).percent(votesMinPercentage);\n    }\n\n    proposals[proposalId].snapshotId = snapshotId;\n    proposals[proposalId].callData = callData;\n    proposals[proposalId].startsAt = startsAt;\n    proposals[proposalId].endsAt = endsAt;\n    proposals[proposalId].votesMinPercentage = votesMinPercentage;\n    proposals[proposalId].votesMinWeight = votesMinWeight;\n\n    emit ProposalCreated(\n      proposalId,\n      snapshotId,\n      callData,\n      startsAt,\n      endsAt,\n      votesMinPercentage,\n      votesMinWeight\n    );\n  }\n\n  /**\n   * @dev Processes proposal\n   * @param proposalId proposal id\n   */\n  function processProposal(\n    uint256 proposalId\n  )\n    external\n  {\n    Proposal memory proposal = proposals[proposalId];\n\n    require(\n      proposal.snapshotId != 0,\n      \"MetaheroDAO#10\" // proposal not found\n    );\n\n    require(\n      proposal.endsAt <= block.timestamp, // solhint-disable-line not-rely-on-time\n      \"MetaheroDAO#11\"\n    );\n\n    require(\n      !proposal.processed,\n      \"MetaheroDAO#12\" // already processed\n    );\n\n    if (\n      proposal.callData.length > 0 &&\n      proposal.votesYesWeight > proposal.votesNoWeight &&\n      proposal.votesYesWeight >= proposal.votesMinWeight\n    ) {\n      (bool success, ) = address(token).call(proposal.callData); // solhint-disable-line avoid-low-level-calls\n\n      require(\n        success,\n        \"MetaheroDAO#13\" // call failed\n      );\n    }\n\n    proposals[proposalId].processed = true;\n\n    emit ProposalProcessed(\n      proposalId,\n      proposal.votesYesWeight,\n      proposal.votesNoWeight\n    );\n  }\n\n  /**\n   * @dev Submits vote\n   * @param proposalId proposal id\n   * @param vote where `1` eq yes and `2` eq no\n   */\n  function submitVote(\n    uint256 proposalId,\n    uint8 vote\n  )\n    external\n  {\n    Proposal memory proposal = proposals[proposalId];\n\n    require(\n      proposal.snapshotId != 0,\n      \"MetaheroDAO#14\" // proposal not found\n    );\n\n    require(\n      proposal.startsAt <= block.timestamp, // solhint-disable-line not-rely-on-time\n      \"MetaheroDAO#15\"\n    );\n\n    require(\n      proposal.endsAt > block.timestamp, // solhint-disable-line not-rely-on-time\n      \"MetaheroDAO#16\"\n    );\n\n    require(\n      vote == 1 ||\n      vote == 2,\n      \"MetaheroDAO#17\"\n    );\n\n    require(\n      proposals[proposalId].votes[msg.sender] == 0,\n      \"MetaheroDAO#18\"\n    );\n\n    uint256 memberWeight = _getMemberWeightOnSnapshot(\n      msg.sender,\n      proposal.snapshotId\n    );\n\n    require(\n      memberWeight != 0,\n      \"MetaheroDAO#19\"\n    );\n\n    if (vote == 1) { // yes vote\n      proposals[proposalId].votesYesWeight = proposal.votesYesWeight.add(\n        memberWeight\n      );\n    }\n\n    if (vote == 2) { // no vote\n      proposals[proposalId].votesNoWeight = proposal.votesNoWeight.add(\n        memberWeight\n      );\n    }\n\n    proposals[proposalId].votesCount = proposal.votesCount.add(1);\n    proposals[proposalId].votes[msg.sender] = vote;\n\n    emit VoteSubmitted(\n      proposalId,\n      msg.sender,\n      vote\n    );\n  }\n\n  // external functions (views)\n\n  function getProposal(\n    uint256 proposalId\n  )\n    external\n    view\n    returns (\n      uint256 snapshotId,\n      bytes memory callData,\n      uint256 startsAt,\n      uint256 endsAt,\n      bool processed,\n      uint256 votesMinPercentage,\n      uint256 votesMinWeight,\n      uint256 votesYesWeight,\n      uint256 votesNoWeight,\n      uint256 votesCount\n    )\n  {\n    {\n      snapshotId = proposals[proposalId].snapshotId;\n      callData = proposals[proposalId].callData;\n      startsAt = proposals[proposalId].startsAt;\n      endsAt = proposals[proposalId].endsAt;\n      processed = proposals[proposalId].processed;\n      votesMinPercentage = proposals[proposalId].votesMinPercentage;\n      votesMinWeight = proposals[proposalId].votesMinWeight;\n      votesYesWeight = proposals[proposalId].votesYesWeight;\n      votesNoWeight = proposals[proposalId].votesNoWeight;\n      votesCount = proposals[proposalId].votesCount;\n    }\n\n    return (\n      snapshotId,\n      callData,\n      startsAt,\n      endsAt,\n      processed,\n      votesMinPercentage,\n      votesMinWeight,\n      votesYesWeight,\n      votesNoWeight,\n      votesCount\n    );\n  }\n\n  function getMemberProposalVote(\n    address member,\n    uint256 proposalId\n  )\n    external\n    view\n    returns (uint8)\n  {\n    return proposals[proposalId].votes[member];\n  }\n\n  function getCurrentSnapshotId()\n    external\n    view\n    returns (uint256)\n  {\n    return _getSnapshotIdAt(block.timestamp); // solhint-disable-line not-rely-on-time\n  }\n\n  function getSnapshotIdAt(\n    uint256 timestamp\n  )\n    external\n    view\n    returns (uint256)\n  {\n    return _getSnapshotIdAt(timestamp);\n  }\n\n  function getCurrentMemberWeight(\n    address member\n  )\n    external\n    view\n    returns (uint256)\n  {\n    return _getMemberWeightOnSnapshot(\n      member,\n      _getSnapshotIdAt(block.timestamp) // solhint-disable-line not-rely-on-time\n    );\n  }\n\n  function getMemberWeightOnSnapshot(\n    address member,\n    uint256 snapshotId\n  )\n    external\n    view\n    returns (uint256)\n  {\n    return _getMemberWeightOnSnapshot(\n      member,\n      snapshotId\n    );\n  }\n\n  function getCurrentTotalWeight()\n    external\n    view\n    returns (uint256)\n  {\n    return _getTotalWeightOnSnapshot(\n      _getSnapshotIdAt(block.timestamp) // solhint-disable-line not-rely-on-time\n    );\n  }\n\n  function getTotalWeightOnSnapshot(\n    uint256 snapshotId\n  )\n    external\n    view\n    returns (uint256)\n  {\n    return _getTotalWeightOnSnapshot(\n      snapshotId\n    );\n  }\n\n  // private functions\n\n  function _setMemberWeight(\n    address member,\n    uint256 memberWeight,\n    uint256 snapshotId\n  )\n    private\n  {\n    uint256 snapshotIdsLen = membersWeightsHistory[member].snapshotIds.length;\n\n    if (snapshotIdsLen == 0) {\n      membersWeightsHistory[member].weights.push(memberWeight);\n      membersWeightsHistory[member].snapshotIds.push(snapshotId);\n    } else {\n      uint256 snapshotIdsLastIndex = snapshotIdsLen - 1;\n\n      if (\n        membersWeightsHistory[member].snapshotIds[snapshotIdsLastIndex] == snapshotId\n      ) {\n        membersWeightsHistory[member].weights[snapshotIdsLastIndex] = memberWeight;\n      } else {\n        membersWeightsHistory[member].weights.push(memberWeight);\n        membersWeightsHistory[member].snapshotIds.push(snapshotId);\n      }\n    }\n  }\n\n  function _setTotalWeight(\n    uint256 totalWeight,\n    uint256 snapshotId\n  )\n    private\n  {\n    uint256 snapshotIdsLen = totalWeightsHistory.snapshotIds.length;\n\n    if (snapshotIdsLen == 0) {\n      totalWeightsHistory.weights.push(totalWeight);\n      totalWeightsHistory.snapshotIds.push(snapshotId);\n    } else {\n      uint256 snapshotIdsLastIndex = snapshotIdsLen - 1;\n\n      if (\n        totalWeightsHistory.snapshotIds[snapshotIdsLastIndex] == snapshotId\n      ) {\n        totalWeightsHistory.weights[snapshotIdsLastIndex] = totalWeight;\n      } else {\n        totalWeightsHistory.weights.push(totalWeight);\n        totalWeightsHistory.snapshotIds.push(snapshotId);\n      }\n    }\n  }\n\n  // private functions (views)\n\n  function _getSnapshotIdAt(\n    uint256 timestamp\n  )\n    private\n    view\n    returns (uint256)\n  {\n    return snapshotBaseTimestamp >= timestamp\n      ? 0\n      : timestamp.sub(\n        snapshotBaseTimestamp\n      ).div(\n        settings.snapshotWindow\n      ).add(1);\n  }\n\n  function _getMemberWeightOnSnapshot(\n    address member,\n    uint256 snapshotId\n  )\n    private\n    view\n    returns (uint256 result)\n  {\n    WeightsHistory memory weightsHistory = membersWeightsHistory[member];\n    uint len = weightsHistory.snapshotIds.length;\n\n    if (len != 0) {\n      for (uint pos = 1 ; pos <= len ; pos++) {\n        uint index = len - pos;\n\n        if (weightsHistory.snapshotIds[index] <= snapshotId) {\n          result = membersWeightsHistory[member].weights[index];\n          break;\n        }\n      }\n    } else {\n      (\n        ,\n        uint256 holdingBalance,\n        uint256 totalRewards\n      ) = token.getBalanceSummary(member);\n\n      if (totalRewards != 0) {\n        result = holdingBalance;\n      }\n    }\n\n    return result;\n  }\n\n  function _getTotalWeightOnSnapshot(\n    uint256 snapshotId\n  )\n    private\n    view\n    returns (uint256 result)\n  {\n    uint len = totalWeightsHistory.snapshotIds.length;\n\n    if (len != 0) {\n      for (uint pos = 1 ; pos <= len ; pos++) {\n        uint index = len - pos;\n\n        if (totalWeightsHistory.snapshotIds[index] <= snapshotId) {\n          result = totalWeightsHistory.weights[index];\n          break;\n        }\n      }\n    } else {\n      (\n        ,\n        uint256 totalHolding,\n        ,\n      ) = token.summary();\n\n      result = totalHolding;\n    }\n\n    return result;\n  }\n}\n"
    },
    "src/MetaheroDAOMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./IMetaheroDAO.sol\";\n\n\n/**\n * @title Metahero DAO mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract MetaheroDAOMock is IMetaheroDAO {\n  // events\n\n  event MemberWeightSynced(\n    address member,\n    uint256 memberWeight\n  );\n\n  event TotalWeightSynced(\n    uint256 totalWeight\n  );\n\n  // external functions\n\n  function syncMember(\n    address member,\n    uint256 memberWeight,\n    uint256 totalWeight\n  )\n    external\n    override\n  {\n    emit MemberWeightSynced(\n      member,\n      memberWeight\n    );\n\n    emit TotalWeightSynced(\n      totalWeight\n    );\n  }\n\n  function syncMembers(\n    address memberA,\n    uint256 memberAWeight,\n    address memberB,\n    uint256 memberBWeight,\n    uint256 totalWeight\n  )\n    external\n    override\n  {\n    emit MemberWeightSynced(\n      memberA,\n      memberAWeight\n    );\n\n    emit MemberWeightSynced(\n      memberB,\n      memberBWeight\n    );\n\n    emit TotalWeightSynced(\n      totalWeight\n    );\n  }\n}\n"
    },
    "src/core/math/MathLibMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./MathLib.sol\";\n\n\n/**\n * @title Math library mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract MathLibMock {\n  using MathLib for uint256;\n\n  // external functions (pure)\n\n  function percent(\n    uint256 a,\n    uint256 p\n  )\n    external\n    pure\n    returns (uint256)\n  {\n    return a.percent(p);\n  }\n}\n"
    },
    "src/MetaheroAirdrop.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./core/access/Owned.sol\";\nimport \"./core/lifecycle/Initializable.sol\";\nimport \"./core/math/SafeMathLib.sol\";\nimport \"./MetaheroToken.sol\";\n\n\n/**\n * @title Metahero airdrop\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract MetaheroAirdrop is Owned, Initializable {\n  /**\n   * @return settings object\n   */\n  MetaheroToken public token;\n\n  // events\n\n  /**\n   * @dev Emitted when the contract is initialized\n  * @param token token address\n   */\n  event Initialized(\n    address token\n  );\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    Owned()\n    Initializable()\n  {\n    //\n  }\n\n  // external functions\n\n  /**\n   * @dev Initializes the contract\n   * @param token_ token address\n   */\n  function initialize(\n    address token_\n  )\n    external\n    onlyInitializer\n  {\n    require(\n      token_ != address(0),\n      \"MetaheroAirdrop#1\" // token is the zero address\n    );\n\n    token = MetaheroToken(token_);\n\n    emit Initialized(\n      token_\n    );\n  }\n\n  function batchTransfer(\n    address[] calldata recipients,\n    uint256[] calldata amounts\n  )\n    external\n    onlyOwner\n  {\n    require(\n      recipients.length != 0,\n      \"MetaheroAirdrop#1\"\n    );\n\n    require(\n      recipients.length == amounts.length,\n      \"MetaheroAirdrop#2\"\n    );\n\n    uint256 len = recipients.length;\n\n    for (uint256 index; index < len; index++) {\n      address recipient = recipients[index];\n      uint256 amount = amounts[index];\n\n      if (\n        recipient != address(0) &&\n        amount != 0\n      ) {\n        token.transfer(recipient, amount);\n      }\n    }\n  }\n}\n"
    },
    "src/core/access/OwnedMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./Owned.sol\";\n\n\n/**\n * @title Owned mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract OwnedMock is Owned {\n  // events\n\n  event Triggered();\n\n  /**\n   * @dev Public constructor\n   */\n  constructor()\n    public\n    Owned()\n  {\n    //\n  }\n\n  // external functions\n\n  function triggerOnlyOwner()\n    external\n    onlyOwner\n  {\n    emit Triggered();\n  }\n}\n"
    },
    "src/core/lifecycle/InitializableMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./Initializable.sol\";\n\n\n/**\n * @title Initializable mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract InitializableMock is Initializable {\n  // events\n\n  event Triggered();\n\n  /**\n   * @dev Public constructor\n   */\n  constructor()\n    public\n    Initializable()\n  {\n    //\n  }\n\n  // external functions\n\n  function triggerOnlyInitializer()\n    external\n    onlyInitializer\n  {\n    emit Triggered();\n  }\n}\n"
    },
    "src/core/access/LockableMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./Lockable.sol\";\n\n\n/**\n * @title Lockable mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract LockableMock is Lockable {\n  // events\n\n  event Triggered();\n\n  /**\n   * @dev Public constructor\n   */\n  constructor()\n    public\n  {\n    //\n  }\n\n  // external functions\n\n  function setLocked(\n    bool locked_\n  )\n    external\n  {\n    locked = locked_;\n  }\n\n  // external functions\n\n  function triggerLock()\n    external\n    lock\n  {\n    emit Triggered();\n  }\n\n  function triggerLockOrThrowError()\n    external\n    lockOrThrowError\n  {\n    emit Triggered();\n  }\n}\n"
    },
    "src/core/erc20/WrappedNativeMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./ERC20Mock.sol\";\nimport \"./IWrappedNative.sol\";\n\n\n/**\n * @title Wrapped native mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract WrappedNativeMock is IWrappedNative, ERC20Mock {\n  using SafeMathLib for uint256;\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    ERC20Mock()\n  {\n    //\n  }\n\n  // external functions\n\n  function deposit()\n    external\n    override\n    payable\n  {\n    require(\n      msg.value != 0,\n      \"WrappedNativeMock#1\"\n    );\n\n    totalSupply = totalSupply.add(msg.value);\n    balanceOf[msg.sender] = balanceOf[msg.sender].add(msg.value);\n\n    emit Transfer(\n      address(0),\n      msg.sender,\n      msg.value\n    );\n  }\n\n  function withdraw(\n    uint256 amount\n  )\n    external\n    override\n  {\n    require(\n      amount <= balanceOf[msg.sender],\n      \"WrappedNativeMock#2\"\n    );\n\n    totalSupply = totalSupply.sub(amount);\n    balanceOf[msg.sender] = balanceOf[msg.sender].sub(amount);\n\n    msg.sender.transfer(amount);\n\n    emit Transfer(\n      msg.sender,\n      address(0),\n      amount\n    );\n  }\n}\n"
    },
    "src/core/erc20/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"../math/SafeMathLib.sol\";\nimport \"./ERC20.sol\";\n\n\n/**\n * @title ERC20 token mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract ERC20Mock is ERC20 {\n  using SafeMathLib for uint256;\n\n  // metadata\n\n  string private constant TOKEN_NAME = \"Mocked token\";\n  string private constant TOKEN_SYMBOL = \"MOCK\";\n  uint8 private constant TOKEN_DECIMALS = 18; // 0.000000000000000000\n\n  uint256 public override totalSupply;\n  mapping(address => uint256) public override balanceOf;\n  mapping(address => mapping(address => uint256)) public override allowance;\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    ERC20(TOKEN_NAME, TOKEN_SYMBOL, TOKEN_DECIMALS)\n  {\n    //\n  }\n\n  // external functions\n\n  function setBalance(\n    address account,\n    uint256 balance\n  )\n    external\n  {\n    require(\n      account != address(0),\n      \"ERC20Mock#1\"\n    );\n\n    uint256 diff;\n\n    if (balance > balanceOf[account]) {\n      diff = balance.sub(balanceOf[account]);\n\n      totalSupply = totalSupply.add(diff);\n      balanceOf[account] = balanceOf[account].add(diff);\n\n      emit Transfer(\n        address(0),\n        account,\n        diff\n      );\n    } else {\n      diff = balanceOf[account].sub(balance);\n\n      totalSupply = totalSupply.sub(diff);\n      balanceOf[account] = balanceOf[account].sub(diff);\n\n      emit Transfer(\n        account,\n        address(0),\n        diff\n      );\n    }\n  }\n\n  function transfer(\n    address recipient,\n    uint256 amount\n  )\n    external\n    override\n    returns (bool)\n  {\n    _transfer(msg.sender, recipient, amount);\n\n    return true;\n  }\n\n  function approve(\n    address spender,\n    uint256 amount\n  )\n    external\n    override\n    returns (bool)\n  {\n    _approve(msg.sender, spender, amount);\n\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    external\n    override\n    returns (bool)\n  {\n    _transfer(sender, recipient, amount);\n\n    require(\n      allowance[sender][msg.sender] >= amount,\n      \"ERC20Mock#2\"\n    );\n\n    _approve(\n      sender,\n      msg.sender,\n      allowance[sender][msg.sender].sub(amount)\n    );\n\n    return true;\n  }\n\n  // private functions\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      sender != address(0),\n      \"ERC20Mock#3\"\n    );\n\n    require(\n      recipient != address(0),\n      \"ERC20Mock#4\"\n    );\n\n    require(\n      balanceOf[sender] >= amount,\n      \"ERC20Mock#5\"\n    );\n\n    balanceOf[sender] = balanceOf[sender].sub(amount);\n    balanceOf[recipient] = balanceOf[recipient].add(amount);\n\n    emit Transfer(\n      sender,\n      recipient,\n      amount\n    );\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      owner != address(0),\n      \"ERC20Mock#6\"\n    );\n\n    require(\n      spender != address(0),\n      \"ERC20Mock#7\"\n    );\n\n    allowance[owner][spender] = amount;\n\n    emit Approval(\n      owner,\n      spender,\n      amount\n    );\n  }\n}\n"
    },
    "src/core/math/SafeMathLibMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./SafeMathLib.sol\";\n\n\n/**\n * @title Safe math library mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract SafeMathLibMock {\n  using SafeMathLib for uint256;\n\n  // external functions (pure)\n\n  function add(\n    uint256 a,\n    uint256 b\n  )\n    external\n    pure\n    returns (uint256)\n  {\n    return a.add(b);\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b\n  )\n    external\n    pure\n    returns (uint256)\n  {\n    return a.sub(b);\n  }\n\n  function mul(\n    uint256 a,\n    uint256 b\n  )\n    external\n    pure\n    returns (uint256)\n  {\n    return a.mul(b);\n  }\n\n  function div(\n    uint256 a,\n    uint256 b\n  )\n    external\n    pure\n    returns (uint256)\n  {\n    return a.div(b);\n  }\n}\n"
    },
    "src/core/access/ControlledMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./Controlled.sol\";\n\n\n/**\n * @title Controlled mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract ControlledMock is Controlled {\n  // events\n\n  event Triggered();\n\n  /**\n   * @dev Public constructor\n   */\n  constructor()\n    public\n    Controlled()\n  {\n    //\n  }\n\n  // external functions\n\n  function triggerOnlyController()\n    external\n    onlyController\n  {\n    emit Triggered();\n  }\n\n  function initializeController(\n    address controller_\n  )\n    external\n  {\n    _initializeController(controller_);\n  }\n\n  function setController(\n    address controller_\n  )\n    external\n  {\n    _setController(controller_);\n  }\n\n  function removeController()\n    external\n  {\n    _removeController();\n  }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "istanbul",
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}