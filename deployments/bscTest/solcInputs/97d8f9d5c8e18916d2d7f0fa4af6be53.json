{
  "language": "Solidity",
  "sources": {
    "src/components/Controlled.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Controlled\n */\ncontract Controlled {\n  address public controller;\n\n  // modifiers\n\n  modifier onlyController() {\n    require(\n      msg.sender == controller,\n      \"Controlled#1\"\n    );\n\n    _;\n  }\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor()\n    internal\n  {\n    controller = msg.sender;\n  }\n\n  // external functions\n\n  function setController(\n    address controller_\n  )\n    external\n    onlyController\n  {\n    require(\n      controller_ != address(0) &&\n      controller_ != controller,\n      \"Controlled#2\"\n    );\n\n    controller = controller_;\n  }\n}\n"
    },
    "src/HEROTokenCommon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./components/Controlled.sol\";\nimport \"./libs/MathLib.sol\";\n\n\n/**\n * @title HERO token common module\n */\nabstract contract HEROTokenCommon is Controlled {\n  using MathLib for uint256;\n\n  struct Fees {\n    uint256 sender; // percent\n    uint256 recipient; // percent\n  }\n\n  struct Settings {\n    Fees lpFees;\n    Fees rewardsFees;\n    uint256 enableBurnLPAtValue;\n  }\n\n  Settings public settings;\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor ()\n    internal\n    Controlled()\n  {\n    //\n  }\n}\n"
    },
    "src/libs/MathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Math library\n */\nlibrary MathLib {\n  function add(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    uint256 c = a + b;\n\n    require(\n      c >= a,\n      \"MathLib#1\"\n    );\n\n    return c;\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    require(\n      b <= a,\n      \"MathLib#2\"\n    );\n\n    return a - b;\n  }\n\n  function mul(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    if (a == 0 || b == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n\n    require(\n      c / a == b,\n      \"MathLib#3\"\n    );\n\n    return c;\n  }\n\n  function div(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    require(\n      b != 0,\n      \"MathLib#4\"\n    );\n\n    return a / b;\n  }\n\n  function percent(\n    uint256 a,\n    uint256 p\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    uint256 result;\n\n    if (a != 0 && p != 0) {\n      result = div(mul(a, p), 100);\n    }\n\n    return result;\n  }\n}\n"
    },
    "src/HEROPresale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./components/Controlled.sol\";\nimport \"./components/Initializable.sol\";\nimport \"./libs/MathLib.sol\";\nimport \"./HEROToken.sol\";\n\n\n/**\n * @title HERO presale\n */\ncontract HEROPresale is Controlled, Initializable {\n  using MathLib for uint256;\n\n  struct Settings {\n    uint256 tokensAmountPerNative;\n    uint256 maxPurchasePrice; // max purchase price per whitelisted account\n  }\n\n  struct Summary {\n    uint256 totalAccounts;\n    uint256 totalTokens;\n  }\n\n  // defaults\n\n  uint256 private constant DEFAULT_DEADLINE_IN = 14 * 24 * 60 * 60; // 14 days\n  uint256 private constant DEFAULT_TOKENS_AMOUNT_PER_NATIVE = 200000;\n  uint256 private constant DEFAULT_MAX_PURCHASE_PRICE = 10 ** 18; // 10.000000000000000000\n\n  HEROToken public token;\n  Settings public settings;\n  Summary public summary;\n  uint256 public deadline;\n\n  mapping (address => bool) public whitelist;\n\n  // events\n\n  event TokensPurchased(\n    address indexed account,\n    uint256 tokensPrice,\n    uint256 tokensAmount\n  );\n\n  event SettingsUpdated(\n    uint256 tokensAmountPerNative,\n    uint256 maxPurchasePrice\n  );\n\n  event DeadlineUpdated(\n    uint256 deadline\n  );\n\n  event AccountAdded(\n    address indexed account\n  );\n\n  event AccountRemoved(\n    address indexed account\n  );\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    Controlled()\n    Initializable()\n  {\n    //\n  }\n\n  // external functions (payable)\n\n  function buyTokens()\n    external\n    payable\n  {\n    require(\n      block.timestamp < deadline, // solhint-disable-line not-rely-on-time\n      \"HEROPresale#1\"\n    );\n\n    require(\n      whitelist[msg.sender],\n      \"HEROPresale#2\"\n    );\n\n    require(\n      msg.value != 0,\n      \"HEROPresale#3\"\n    );\n\n    require(\n      msg.value <= settings.maxPurchasePrice,\n      \"HEROPresale#4\"\n    );\n\n    uint256 tokensAmount = msg.value.mul(settings.tokensAmountPerNative);\n\n    require(\n      tokensAmount <= summary.totalTokens,\n      \"HEROPresale#5\"\n    );\n\n    whitelist[msg.sender] = false;\n\n    summary.totalAccounts = summary.totalAccounts.sub(1);\n    summary.totalTokens = summary.totalTokens.sub(tokensAmount);\n\n    token.transfer(\n      msg.sender,\n      tokensAmount\n    );\n\n    emit TokensPurchased(\n      msg.sender,\n      msg.value,\n      tokensAmount\n    );\n  }\n\n  // external functions\n\n  function initialize(\n    address payable token_,\n    uint256 tokensAmountPerNative,\n    uint256 maxPurchasePrice,\n    uint256 deadlineIn, // in seconds\n    address[] calldata accounts\n  )\n    external\n    onlyInitializer\n  {\n    require(\n      token_ != address(0),\n      \"HEROPresale#6\"\n    );\n\n    token = HEROToken(token_);\n\n    summary.totalTokens = token.balanceOf(address(this));\n\n    _updateSettings(\n      tokensAmountPerNative == 0\n        ? DEFAULT_TOKENS_AMOUNT_PER_NATIVE\n        : tokensAmountPerNative,\n      maxPurchasePrice == 0\n        ? DEFAULT_MAX_PURCHASE_PRICE\n        : maxPurchasePrice\n    );\n\n    _updateDeadline(deadlineIn != 0\n      ? deadlineIn\n      : DEFAULT_DEADLINE_IN\n    );\n\n    if (accounts.length != 0) {\n      _addAccounts(accounts);\n    }\n  }\n\n  function syncTotalTokens()\n    external\n    onlyController\n  {\n    summary.totalTokens = token.balanceOf(address(this));\n  }\n\n  function updateDeadline(\n    uint256 deadlineIn_ // in seconds\n  )\n    external\n    onlyController\n  {\n    _updateDeadline(deadlineIn_);\n  }\n\n  function addAccounts(\n    address[] calldata accounts\n  )\n    external\n    onlyController\n  {\n    _addAccounts(accounts);\n  }\n\n  function removeAccounts(\n    address[] calldata accounts\n  )\n    external\n    onlyController\n  {\n    uint256 totalRemoved;\n    uint256 accountsLen = accounts.length;\n\n    for (uint256 index ; index < accountsLen ; index++) {\n      require(\n        accounts[index] != address(0),\n        \"HEROPresale#7\"\n      );\n\n      if (whitelist[accounts[index]]) {\n        whitelist[accounts[index]] = false;\n\n        totalRemoved = totalRemoved.add(1);\n\n        emit AccountRemoved(\n          accounts[index]\n        );\n      }\n    }\n\n    require(\n      totalRemoved != 0,\n      \"HEROPresale#8\"\n    );\n\n    summary.totalAccounts = summary.totalAccounts.sub(totalRemoved);\n  }\n\n  function finishPresale()\n    external\n    onlyController\n  {\n    require(\n      block.timestamp >= deadline, // solhint-disable-line not-rely-on-time\n      \"HEROPresale#9\"\n    );\n\n    uint256 totalTokens = token.balanceOf(address(this));\n\n    if (totalTokens != 0) {\n      token.burn(\n        totalTokens\n      );\n    }\n\n    selfdestruct(msg.sender);\n  }\n\n  // private functions\n\n  function _updateSettings(\n    uint256 tokensAmountPerNative,\n    uint256 maxPurchasePrice\n  )\n    private\n  {\n    require(\n      tokensAmountPerNative != 0,\n      \"HEROPresale#10\"\n    );\n\n    require(\n      maxPurchasePrice != 0,\n      \"HEROPresale#11\"\n    );\n\n    settings.tokensAmountPerNative = tokensAmountPerNative;\n    settings.maxPurchasePrice = maxPurchasePrice;\n\n    emit SettingsUpdated(\n      tokensAmountPerNative,\n      maxPurchasePrice\n    );\n  }\n\n  function _updateDeadline(\n    uint256 deadlineIn\n  )\n    private\n  {\n    deadline = block.timestamp.add(deadlineIn); // solhint-disable-line not-rely-on-time\n\n    emit DeadlineUpdated(\n      deadline\n    );\n  }\n\n  function _addAccounts(\n    address[] memory accounts\n  )\n    private\n  {\n    uint256 totalAdded;\n    uint256 accountsLen = accounts.length;\n\n    for (uint256 index ; index < accountsLen ; index++) {\n      require(\n        accounts[index] != address(0),\n        \"HEROPresale#12\"\n      );\n\n      if (!whitelist[accounts[index]]) {\n        whitelist[accounts[index]] = true;\n\n        totalAdded = totalAdded.add(1);\n\n        emit AccountAdded(\n          accounts[index]\n        );\n      }\n    }\n\n    require(\n      totalAdded != 0,\n      \"HEROPresale#13\"\n    );\n\n    summary.totalAccounts = summary.totalAccounts.add(totalAdded);\n  }\n}\n"
    },
    "src/components/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Initializable\n */\ncontract Initializable {\n  address private initializer;\n\n  // events\n\n  event Initialized();\n\n  // modifiers\n\n  modifier onlyInitializer() {\n    require(\n      initializer != address(0),\n      \"Initializable#1\"\n    );\n\n    require(\n      msg.sender == initializer,\n      \"Initializable#2\"\n    );\n\n    initializer = address(0);\n\n    _;\n\n    emit Initialized();\n  }\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor()\n    internal\n  {\n    initializer = msg.sender;\n  }\n\n  // external functions (views)\n\n  function initialized()\n    external\n    view\n    returns (bool)\n  {\n    return initializer == address(0);\n  }\n}\n"
    },
    "src/HEROToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./components/ERC20Metadata.sol\";\nimport \"./components/Initializable.sol\";\nimport \"./HEROTokenLP.sol\";\n\n\n/**\n * @title HERO token\n */\ncontract HEROToken is ERC20Metadata, Initializable, HEROTokenLP {\n  // metadata\n  string private constant TOKEN_NAME = \"Metahero\";\n  string private constant TOKEN_SYMBOL = \"HERO\";\n  uint8 private constant TOKEN_DECIMALS = 18; // 0.000000000000000000\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    ERC20Metadata(\n      Metadata(TOKEN_NAME, TOKEN_SYMBOL, TOKEN_DECIMALS)\n    )\n    Initializable()\n    HEROTokenLP()\n  {\n    //\n  }\n\n  // external functions\n\n  function initialize(\n    Fees calldata lpFees,\n    Fees calldata rewardsFees,\n    uint256 totalSupply_,\n    address[] calldata excluded_,\n    uint256 enableBurnLPAtValue,\n    address swapRouter_,\n    address stableCoin_\n  )\n    external\n    onlyInitializer\n  {\n    _initializeEconomy(\n      lpFees,\n      rewardsFees,\n      totalSupply_,\n      excluded_\n    );\n\n    _initializeLP(\n      enableBurnLPAtValue,\n      swapRouter_,\n      stableCoin_\n    );\n  }\n}\n"
    },
    "src/components/ERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\ncontract ERC20Metadata {\n  struct Metadata {\n    string name;\n    string symbol;\n    uint8 decimals;\n  }\n\n  Metadata private metadata;\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor (\n    Metadata memory metadata_\n  )\n    internal\n  {\n    metadata = metadata_;\n  }\n\n  // external functions (views)\n\n  function name()\n    external\n    view\n    virtual\n    returns (string memory)\n  {\n    return metadata.name;\n  }\n\n  function symbol()\n    external\n    view\n    virtual\n    returns (string memory)\n  {\n    return metadata.symbol;\n  }\n\n  function decimals()\n    external\n    view\n    virtual\n    returns (uint8)\n  {\n    return metadata.decimals;\n  }\n}\n"
    },
    "src/HEROTokenLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./external/UniswapV2Factory.sol\";\nimport \"./external/UniswapV2Pair.sol\";\nimport \"./external/UniswapV2Router02.sol\";\nimport \"./HEROTokenEconomy.sol\";\n\n\n/**\n * @title HERO token liquidity pool module\n */\ncontract HEROTokenLP is HEROTokenEconomy {\n  // defaults\n\n  uint256 private constant DEFAULT_ENABLE_BURN_LP_AT_VALUE = 10000000 * 10 ** 18; // 10,000,000.000000000000000000\n\n  UniswapV2Factory public swapFactory;\n  UniswapV2Router02 public swapRouter;\n  UniswapV2Pair public swapPair;\n  address public stableCoin;\n\n  address private wrappedNative;\n  bool private swapLocked;\n  uint256 private pendingLPAmount;\n\n  // modifiers\n\n  modifier lockSwap() {\n    if (!swapLocked) {\n      swapLocked = true;\n\n      _;\n\n      swapLocked = false;\n    }\n  }\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor ()\n    internal\n    HEROTokenEconomy()\n  {\n    //\n  }\n\n  // external functions\n\n  receive()\n    external\n    payable\n  {\n    //\n  }\n\n  function burnLP(\n    uint256 amount\n  )\n    external\n    onlyController\n    lockSwap\n  {\n    require(\n      amount > 1,\n      \"HEROTokenLP#1\"\n    );\n\n    (uint256 tokenAmount, ) = _getLiquidityReserves();\n\n    require(\n      tokenAmount != 0,\n      \"HEROTokenLP#2\"\n    );\n\n    require(\n      amount <= tokenAmount,\n      \"HEROTokenLP#3\"\n    );\n\n    address[] memory path = new address[](3);\n\n    path[0] = address(this);\n    path[1] = wrappedNative;\n    path[2] = stableCoin;\n\n    uint256[] memory amounts = swapRouter.getAmountsOut(amount, path);\n\n    uint256 tokensValue = amounts[2];\n\n    require(\n      tokensValue > settings.enableBurnLPAtValue,\n      \"HEROTokenLP#4\"\n    );\n\n    uint256 amountValue = amount.mul(tokensValue).div(tokenAmount);\n    uint256 maxValue = tokensValue.div(settings.enableBurnLPAtValue);\n\n    require(\n      maxValue >= amountValue,\n      \"HEROTokenLP#5\"\n    );\n\n    (tokenAmount, ) = _removeLiquidity(\n      swapPair.balanceOf(address(this))\n    );\n\n    _burn(\n      address(this),\n      amount\n    );\n\n    _addLiquidity(\n      tokenAmount.add(amount),\n      address(this).balance\n    );\n  }\n\n  // internal functions\n\n  function _initializeLP(\n    uint256 enableBurnLPAtValue,\n    address swapRouter_,\n    address stableCoin_\n  )\n    internal\n  {\n    require(\n      swapRouter_ != address(0),\n      \"HEROTokenLP#6\"\n    );\n\n    require(\n      stableCoin_ != address(0),\n      \"HEROTokenLP#7\"\n    );\n\n    settings.enableBurnLPAtValue = enableBurnLPAtValue == 0\n      ? DEFAULT_ENABLE_BURN_LP_AT_VALUE\n      : enableBurnLPAtValue;\n\n    swapRouter = UniswapV2Router02(swapRouter_);\n    swapFactory = UniswapV2Factory(swapRouter.factory());\n\n    wrappedNative = swapRouter.WETH();\n\n    swapPair = UniswapV2Pair(swapFactory.createPair(\n      address(this),\n      wrappedNative\n    ));\n\n    stableCoin = stableCoin_;\n\n    _excludeAccount(address(swapRouter), true);\n    _excludeAccount(address(swapPair), true);\n  }\n\n  function _increaseTotalLP(\n    uint256 amount\n  )\n    internal\n    override\n  {\n    HEROTokenEconomy._increaseTotalLP(amount);\n\n    pendingLPAmount = pendingLPAmount.add(amount);\n\n    _swapTokensAndAddLiquidity();\n  }\n\n  // private functions\n\n  function _swapTokensAndAddLiquidity()\n    private\n    lockSwap\n  {\n    uint256 half = pendingLPAmount.div(2);\n    uint256 otherHalf = pendingLPAmount.sub(half);\n\n    pendingLPAmount = 0;\n\n    _swapTokens(half);\n\n    uint256 nativeAmount = address(this).balance;\n\n    _addLiquidity(\n      otherHalf,\n      nativeAmount\n    );\n  }\n\n  function _swapTokens(\n    uint256 tokenAmount\n  )\n    private\n  {\n    if (tokenAmount != 0) {\n      _approve(\n        address(this),\n        address(swapRouter),\n        tokenAmount\n      );\n\n      address[] memory path = new address[](2);\n\n      path[0] = address(this);\n      path[1] = wrappedNative;\n\n      swapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\n        tokenAmount,\n        0,\n        path,\n        address(this),\n        block.timestamp // solhint-disable-line not-rely-on-time\n      );\n    }\n  }\n\n  function _addLiquidity(\n    uint256 tokenAmount,\n    uint256 nativeAmount\n  )\n    private\n  {\n    if (tokenAmount != 0 && nativeAmount != 0) {\n      _approve(\n        address(this),\n        address(swapRouter),\n        tokenAmount\n      );\n\n      swapRouter.addLiquidityETH{value : nativeAmount}(\n        address(this),\n        tokenAmount,\n        0,\n        0,\n        address(this),\n        block.timestamp // solhint-disable-line not-rely-on-time\n      );\n    }\n  }\n\n  function _removeLiquidity(\n    uint256 liquidity\n  )\n    private\n    returns (\n      uint256 tokenAmount,\n      uint256 nativeAmount\n    )\n  {\n    swapPair.approve(\n      address(swapRouter),\n      liquidity\n    );\n\n    return swapRouter.removeLiquidityETH(\n      address(this),\n      liquidity,\n      0,\n      0,\n      address(this),\n      block.timestamp // solhint-disable-line not-rely-on-time\n    );\n  }\n\n  // private functions (views)\n\n  function _getLiquidityReserves()\n    private\n    view\n    returns (\n      uint256 tokenAmount,\n      uint256 nativeAmount\n    )\n  {\n    (\n      uint112 reserve0,\n      uint112 reserve1,\n    )= swapPair.getReserves();\n\n    (tokenAmount, nativeAmount) = address(this) < wrappedNative\n      ? (reserve0, reserve1)\n      : (reserve1, reserve0);\n\n    return (tokenAmount, nativeAmount);\n  }\n\n\n}\n"
    },
    "src/external/UniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\ninterface UniswapV2Factory {\n  // events\n\n  event PairCreated(\n    address indexed token0,\n    address indexed token1,\n    address pair,\n    uint256\n  );\n\n  // external functions\n\n  function createPair(\n    address tokenA,\n    address tokenB\n  )\n    external\n    returns (address);\n\n  function setFeeTo(\n    address\n  )\n    external;\n\n  function setFeeToSetter(\n    address\n  )\n    external;\n\n  // external functions (views)\n\n  function feeTo()\n    external\n    view\n    returns (address);\n\n  function feeToSetter()\n    external\n    view\n    returns (address);\n\n  function getPair(\n    address tokenA,\n    address tokenB\n  )\n    external\n    view\n    returns (address);\n\n  function allPairs(\n    uint256\n  )\n    external\n    view\n    returns (address);\n\n  function allPairsLength()\n    external\n    view\n    returns (uint256);\n}\n\n"
    },
    "src/external/UniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable func-name-mixedcase */\npragma solidity ^0.6.12;\n\ninterface UniswapV2Pair {\n  // events\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint value\n  );\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint value\n  );\n\n  event Mint(\n    address indexed sender,\n    uint amount0,\n    uint amount1\n  );\n\n  event Burn(\n    address indexed sender,\n    uint amount0,\n    uint amount1,\n    address indexed to\n  );\n\n  event Swap(\n    address indexed sender,\n    uint amount0In,\n    uint amount1In,\n    uint amount0Out,\n    uint amount1Out,\n    address indexed to\n  );\n\n  event Sync(\n    uint112 reserve0,\n    uint112 reserve1\n  );\n\n  // external functions\n\n  function initialize(\n    address,\n    address\n  )\n    external;\n\n  function approve(\n    address spender,\n    uint value\n  )\n    external\n    returns (bool);\n\n  function transfer(\n    address to,\n    uint value\n  )\n    external\n    returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint value\n  )\n    external\n    returns (bool);\n\n  function mint(\n    address to\n  )\n    external\n    returns (uint);\n\n  function burn(\n    address to\n  )\n    external\n    returns (uint, uint);\n\n  function swap(\n    uint amount0Out,\n    uint amount1Out,\n    address to,\n    bytes calldata data\n  )\n    external;\n\n  function skim(\n    address to\n  )\n    external;\n\n  function sync()\n    external;\n\n  function permit(\n    address owner,\n    address spender,\n    uint value,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external;\n\n  // external functions (views)\n\n  function totalSupply()\n    external\n    view\n    returns (uint);\n\n  function balanceOf(\n    address owner\n  )\n    external\n    view\n    returns (uint);\n\n  function allowance(\n    address owner,\n    address spender\n  )\n    external\n    view\n    returns (uint);\n\n  function DOMAIN_SEPARATOR()\n    external\n    view\n    returns (bytes32);\n\n  function nonces(\n    address owner\n  )\n    external\n    view\n    returns (uint);\n\n  function factory()\n    external\n    view\n    returns (address);\n\n  function token0()\n    external\n    view\n    returns (address);\n\n  function token1()\n    external\n    view\n    returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (uint112, uint112, uint32);\n\n  function price0CumulativeLast()\n    external\n    view\n    returns (uint);\n\n  function price1CumulativeLast()\n    external\n    view\n    returns (uint);\n\n  function kLast()\n    external\n    view\n    returns (uint);\n\n  // external functions (pure)\n\n  function name()\n    external\n    pure\n    returns (string memory);\n\n  function symbol()\n    external\n    pure\n    returns (string memory);\n\n  function decimals()\n    external\n    pure\n    returns (uint8);\n\n  function PERMIT_TYPEHASH()\n    external\n    pure\n    returns (bytes32);\n\n  function MINIMUM_LIQUIDITY()\n    external\n    pure\n    returns (uint);\n}\n"
    },
    "src/external/UniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./UniswapV2Router01.sol\";\n\n\ninterface UniswapV2Router02 is UniswapV2Router01 {\n  // external functions (payable)\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    payable;\n\n  // external functions\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  )\n    external\n    returns (uint);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external\n    returns (uint);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external;\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external;\n}\n"
    },
    "src/HEROTokenEconomy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./components/ERC20.sol\";\nimport \"./HEROTokenCommon.sol\";\n\n\n/**\n * @title HERO token economy module\n */\ncontract HEROTokenEconomy is ERC20, HEROTokenCommon {\n  struct Summary {\n    uint256 totalExcluded;\n    uint256 totalHolding;\n    uint256 totalRewards;\n    uint256 totalSupply;\n  }\n\n  struct ExcludedAccount {\n    bool exists;\n    bool excludeRecipientFromFee;\n  }\n\n  // defaults\n\n  uint256 private constant DEFAULT_TOTAL_SUPPLY = 10000000000 * 10 ** 18; // 10,000,000,000.000000000000000000\n\n  Summary public summary;\n  bool public presaleFinished;\n\n  mapping (address => uint256) internal accountBalances;\n  mapping (address => mapping (address => uint256)) private accountAllowances;\n  mapping (address => ExcludedAccount) private excludedAccounts;\n\n  // events\n\n  event PresaleFinished();\n\n  event AccountExcluded(\n    address indexed account,\n    bool excludeRecipientFromFee\n  );\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor ()\n    internal\n    HEROTokenCommon()\n  {\n    //\n  }\n\n  // external functions\n\n  function finishPresale()\n    external\n    onlyController\n  {\n    require(\n      !presaleFinished,\n      \"HEROTokenEconomy#1\"\n    );\n\n    presaleFinished = true;\n\n    emit PresaleFinished();\n  }\n\n  function excludeAccount(\n    address account,\n    bool excludeRecipientFromFee\n  )\n    external\n    onlyController\n  {\n    _excludeAccount(\n      account,\n      excludeRecipientFromFee\n    );\n  }\n\n  function transfer(\n    address recipient,\n    uint256 amount\n  )\n    external\n    override\n    returns (bool)\n  {\n    _transfer(\n      msg.sender,\n      recipient,\n      amount\n    );\n\n    return true;\n  }\n\n  function burn(\n    uint256 amount\n  )\n    external\n  {\n    _burn(\n      msg.sender,\n      amount\n    );\n  }\n\n  function approve(\n    address spender,\n    uint256 amount\n  )\n    external\n    override\n    returns (bool)\n  {\n    _approve(\n      msg.sender,\n      spender,\n      amount\n    );\n\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    external\n    override\n    returns (bool)\n  {\n    _transfer(\n      sender,\n      recipient,\n      amount\n    );\n\n    uint256 allowance = accountAllowances[sender][msg.sender];\n\n    require(\n      allowance >= amount,\n      \"HEROTokenEconomy#2\"\n    );\n\n    _approve(\n      sender,\n      msg.sender,\n      allowance.sub(amount)\n    );\n\n    return true;\n  }\n\n  // external functions (views)\n\n  function totalSupply()\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return summary.totalSupply;\n  }\n\n  function allowance(\n    address owner,\n    address spender\n  )\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return accountAllowances[owner][spender];\n  }\n\n  function balanceOf(\n    address account\n  )\n    external\n    view\n    override\n    returns (uint256 result)\n  {\n    result = accountBalances[account];\n\n    if (\n      !excludedAccounts[account].exists &&\n      summary.totalRewards != 0\n    ) {\n      result = result.add(\n        summary.totalRewards\n        .mul(result)\n        .div(summary.totalHolding)\n      );\n    }\n\n    return result;\n  }\n\n  // internal functions\n\n  function _initializeEconomy(\n    Fees memory lpFees,\n    Fees memory rewardsFees,\n    uint256 totalSupply_,\n    address[] calldata excludedAccounts_\n  )\n    internal\n  {\n    settings.lpFees = lpFees;\n    settings.rewardsFees = rewardsFees;\n\n    _mint(\n      msg.sender,\n      totalSupply_ == 0\n      ? DEFAULT_TOTAL_SUPPLY\n      : totalSupply_\n    );\n\n    _excludeAccount(address(this), false);\n\n    uint256 excludedAccountsLen = excludedAccounts_.length;\n\n    for (uint256 index; index < excludedAccountsLen; index++) {\n      _excludeAccount(excludedAccounts_[index], false);\n    }\n  }\n\n  function _excludeAccount(\n    address account,\n    bool excludeRecipientFromFee\n  )\n    internal\n  {\n    require(\n      account != address(0),\n      \"HEROTokenEconomy#3\"\n    );\n\n    if (excludedAccounts[account].exists) {\n      require(\n        excludedAccounts[account].excludeRecipientFromFee != excludeRecipientFromFee,\n        \"HEROTokenEconomy#4\"\n      );\n\n      excludedAccounts[account].excludeRecipientFromFee = excludeRecipientFromFee;\n    } else {\n      require(\n        accountBalances[account] == 0,\n        \"HEROTokenEconomy#5\"\n      );\n\n      excludedAccounts[account].exists = true;\n      excludedAccounts[account].excludeRecipientFromFee = excludeRecipientFromFee;\n    }\n\n    emit AccountExcluded(\n      account,\n      excludeRecipientFromFee\n    );\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  )\n    internal\n  {\n    require(\n      owner != address(0),\n      \"HEROTokenEconomy#6\"\n    );\n\n    require(\n      spender != address(0),\n      \"HEROTokenEconomy#7\"\n    );\n\n    accountAllowances[owner][spender] = amount;\n\n    emit Approval(\n      owner,\n      spender,\n      amount\n    );\n  }\n\n  function _mint(\n    address account,\n    uint256 amount\n  )\n    internal\n  {\n    require(\n      account != address(0),\n      \"HEROTokenEconomy#8\"\n    );\n\n    require(\n      amount != 0,\n      \"HEROTokenEconomy#9\"\n    );\n\n    _excludeAccount(account, false);\n\n    summary.totalSupply = summary.totalSupply.add(amount);\n    summary.totalExcluded = summary.totalExcluded.add(amount);\n\n    accountBalances[account] = accountBalances[account].add(amount);\n\n    emit Transfer(\n      address(0),\n      account,\n      amount\n    );\n  }\n\n  function _burn(\n    address account,\n    uint256 amount\n  )\n    internal\n  {\n    require(\n      account != address(0),\n      \"HEROTokenEconomy#10\"\n    );\n\n    require(\n      amount != 0,\n      \"HEROTokenEconomy#11\"\n    );\n\n    require(\n      accountBalances[account] >= amount,\n      \"HEROTokenEconomy#12\"\n    );\n\n    require(\n      excludedAccounts[account].exists,\n      \"HEROTokenEconomy#13\"\n    );\n\n    summary.totalSupply = summary.totalSupply.sub(amount);\n    summary.totalExcluded = summary.totalExcluded.sub(amount);\n\n    accountBalances[account] = accountBalances[account].sub(amount);\n\n    emit Transfer(\n      account,\n      address(0),\n      amount\n    );\n  }\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    internal\n  {\n    require(\n      sender != address(0),\n      \"HEROTokenEconomy#14\"\n    );\n\n    require(\n      recipient != address(0),\n      \"HEROTokenEconomy#15\"\n    );\n\n    require(\n      sender != recipient,\n      \"HEROTokenEconomy#16\"\n    );\n\n    require(\n      amount != 0,\n      \"HEROTokenEconomy#17\"\n    );\n\n    require(\n      excludedAccounts[sender].exists ||\n      presaleFinished,\n      \"HEROTokenEconomy#18\"\n    );\n\n    if (\n      !excludedAccounts[sender].exists &&\n      !excludedAccounts[recipient].exists\n    ) {\n      _transferBetweenHolderAccounts(\n        sender,\n        recipient,\n        amount\n      );\n    } else if (\n      excludedAccounts[sender].exists &&\n      !excludedAccounts[recipient].exists\n    ) {\n      _transferFromExcludedAccount(\n        sender,\n        recipient,\n        amount\n      );\n    } else if (\n      !excludedAccounts[sender].exists &&\n      excludedAccounts[recipient].exists\n    ) {\n      _transferToExcludedAccount(\n        sender,\n        recipient,\n        amount\n      );\n    } else {\n      _transferBetweenExcludedAccounts(\n        sender,\n        recipient,\n        amount\n      );\n    }\n\n    emit Transfer(\n      sender,\n      recipient,\n      amount\n    );\n  }\n\n  function _transferBetweenHolderAccounts(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    internal\n  {\n    (\n      uint256 senderFee,\n      uint256 lpFee\n    ) = _calcTransferSenderFees(amount);\n\n    uint256 recipientFee;\n    uint256 totalFee = senderFee;\n\n    {\n      uint256 recipientLPFee;\n\n      (\n        recipientFee,\n        recipientLPFee\n      ) = _calcTransferRecipientFees(amount);\n\n      lpFee = lpFee.add(recipientLPFee);\n      totalFee = totalFee.add(recipientFee);\n    }\n\n    uint256 senderAmount = amount.add(senderFee);\n    uint256 recipientAmount = amount.sub(recipientFee);\n\n    if (summary.totalRewards != 0) {\n      uint256 totalHoldingWithRewards = summary.totalHolding.add(\n        summary.totalRewards\n      );\n\n      senderAmount = senderAmount.mul(summary.totalHolding).div(\n        totalHoldingWithRewards\n      );\n      recipientAmount = recipientAmount.mul(summary.totalHolding).div(\n        totalHoldingWithRewards\n      );\n      totalFee = totalFee.mul(summary.totalHolding).div(\n        totalHoldingWithRewards\n      );\n    }\n\n    require(\n      accountBalances[sender] >= senderAmount,\n      \"HEROTokenEconomy#19\"\n    );\n\n    accountBalances[sender] = accountBalances[sender].sub(senderAmount);\n    accountBalances[recipient] = accountBalances[recipient].add(recipientAmount);\n\n    summary.totalHolding = summary.totalHolding.sub(totalFee);\n\n    if (lpFee != 0) {\n      _increaseTotalLP(lpFee);\n    }\n\n    _updateTotalRewards();\n  }\n\n  function _transferFromExcludedAccount(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    internal\n  {\n    require(\n      accountBalances[sender] >= amount,\n      \"HEROTokenEconomy#20\"\n    );\n\n    uint256 recipientFee;\n    uint256 lpFee;\n\n    if (!excludedAccounts[sender].excludeRecipientFromFee) {\n      (\n        recipientFee,\n        lpFee\n      ) = _calcTransferSenderFees(amount);\n    }\n\n    uint256 recipientAmount = amount.sub(recipientFee);\n\n    accountBalances[sender] = accountBalances[sender].sub(amount);\n    accountBalances[recipient] = accountBalances[recipient].add(recipientAmount);\n\n    summary.totalExcluded = summary.totalExcluded.sub(amount);\n    summary.totalHolding = summary.totalHolding.add(recipientAmount);\n\n    if (lpFee != 0) {\n      _increaseTotalLP(lpFee);\n    }\n\n    _updateTotalRewards();\n  }\n\n  function _transferToExcludedAccount(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    internal\n  {\n    (\n      uint256 senderFee,\n      uint256 lpFee\n    ) = _calcTransferSenderFees(amount);\n\n    uint256 senderAmount = amount.add(senderFee);\n\n    if (summary.totalRewards != 0) {\n      uint256 totalHoldingWithRewards = summary.totalHolding.add(\n        summary.totalRewards\n      );\n\n      senderAmount = senderAmount.mul(summary.totalHolding).div(\n        totalHoldingWithRewards\n      );\n    }\n\n    require(\n      accountBalances[sender] >= senderAmount,\n      \"HEROTokenEconomy#21\"\n    );\n\n    accountBalances[sender] = accountBalances[sender].sub(senderAmount);\n    accountBalances[recipient] = accountBalances[recipient].add(amount);\n\n    summary.totalExcluded = summary.totalExcluded.add(amount);\n    summary.totalHolding = summary.totalHolding.sub(senderAmount);\n\n    if (lpFee != 0) {\n      _increaseTotalLP(lpFee);\n    }\n\n    _updateTotalRewards();\n  }\n\n  function _transferBetweenExcludedAccounts(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    internal\n  {\n    require(\n      accountBalances[sender] >= amount,\n      \"HEROTokenEconomy#22\"\n    );\n\n    accountBalances[sender] = accountBalances[sender].sub(amount);\n    accountBalances[recipient] = accountBalances[recipient].add(amount);\n  }\n\n  function _increaseTotalLP(\n    uint256 amount\n  )\n    internal\n    virtual\n  {\n    accountBalances[address(this)] = accountBalances[address(this)].add(amount);\n    summary.totalExcluded = summary.totalExcluded.add(amount);\n  }\n\n  // private functions\n\n  function _updateTotalRewards()\n    private\n  {\n    summary.totalRewards = summary.totalSupply\n    .sub(summary.totalExcluded)\n    .sub(summary.totalHolding);\n  }\n\n  // private functions (views)\n\n  function _calcRewards(\n    address account\n  )\n    private\n    view\n    returns (uint256 result)\n  {\n    if (\n      !excludedAccounts[account].exists &&\n      summary.totalRewards != 0\n    ) {\n      result = summary.totalRewards\n        .mul(accountBalances[account])\n        .div(summary.totalHolding);\n    }\n\n    return result;\n  }\n\n  function _calcTransferSenderFees(\n    uint256 amount\n  )\n    private\n    view\n    returns (\n      uint256 totalFee,\n      uint256 lpFee\n    )\n  {\n    uint256 rewardsFee = amount.percent(settings.rewardsFees.sender);\n\n    lpFee = amount.percent(settings.lpFees.sender);\n    totalFee = lpFee.add(rewardsFee);\n\n    return (totalFee, lpFee);\n  }\n\n  function _calcTransferRecipientFees(\n    uint256 amount\n  )\n    private\n    view\n    returns (\n      uint256 totalFee,\n      uint256 lpFee\n    )\n  {\n    uint256 rewardsFee = amount.percent(settings.rewardsFees.recipient);\n\n    lpFee = amount.percent(settings.lpFees.recipient);\n    totalFee = lpFee.add(rewardsFee);\n\n    return (totalFee, lpFee);\n  }\n}\n"
    },
    "src/external/UniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable func-name-mixedcase */\npragma solidity ^0.6.12;\n\ninterface UniswapV2Router01 {\n  // external functions (payable)\n\n  function addLiquidityETH(\n    address token,\n    uint amountTokenDesired,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  )\n    external\n    payable\n    returns (uint, uint, uint);\n\n  function swapExactETHForTokens(\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    payable\n    returns (uint[] memory);\n\n  // external functions\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n  )\n    external\n    returns (uint, uint, uint);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n  )\n    external\n    returns (uint, uint);\n\n  function removeLiquidityETH(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  )\n    external\n    returns (uint, uint);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external\n    returns (uint, uint);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external\n    returns (uint, uint);\n\n  function swapExactTokensForTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    returns (uint[] memory);\n\n  function swapTokensForExactTokens(\n    uint amountOut,\n    uint amountInMax,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    returns (uint[] memory);\n\n  function swapTokensForExactETH(\n    uint amountOut,\n    uint amountInMax,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    returns (uint[] memory);\n\n  function swapExactTokensForETH(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    returns (uint[] memory);\n\n  function swapETHForExactTokens(\n    uint amountOut,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    payable\n    returns (uint[] memory);\n\n  // external functions (views)\n\n  function getAmountsOut(\n    uint amountIn,\n    address[] calldata path\n  )\n    external\n    view\n    returns (uint[] memory);\n\n  function getAmountsIn(\n    uint amountOut,\n    address[] calldata path\n  )\n    external\n    view\n    returns (uint[] memory);\n\n  // external functions (pure)\n\n  function quote(\n    uint amountA,\n    uint reserveA,\n    uint reserveB\n  )\n    external\n    pure\n    returns (uint);\n\n  function getAmountOut(\n    uint amountIn,\n    uint reserveIn,\n    uint reserveOut\n  )\n    external\n    pure\n    returns (uint);\n\n  function getAmountIn(\n    uint amountOut,\n    uint reserveIn,\n    uint reserveOut\n  )\n    external\n    pure\n    returns (uint);\n\n  function factory()\n    external\n    pure\n    returns (address);\n\n  function WETH()\n    external\n    pure\n    returns (address);\n}\n"
    },
    "src/components/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\ninterface ERC20 {\n  // events\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  // external functions\n\n  function approve(\n    address spender,\n    uint256 value\n  )\n    external\n    returns (bool);\n\n  function transfer(\n    address to,\n    uint256 value\n  )\n    external\n    returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  )\n    external\n    returns (bool);\n\n  // external functions (views)\n\n  function totalSupply()\n    external\n    view\n    returns (uint256);\n\n  function balanceOf(\n    address owner\n  )\n    external\n    view\n    returns (uint256);\n\n  function allowance(\n    address owner,\n    address spender\n  )\n    external\n    view\n    returns (uint256);\n}\n"
    },
    "src/HEROTokenLPMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./HEROTokenLP.sol\";\n\n\n/**\n * @title HERO token liquidity pool module (mock)\n */\ncontract HEROTokenLPMock is HEROTokenLP {\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    HEROTokenLP()\n  {\n    //\n  }\n\n  // external functions\n\n  function initialize(\n    Fees calldata lpFees,\n    Fees calldata rewardsFees,\n    uint256 totalSupply_,\n    address[] calldata excluded_,\n    uint256 enableBurnLPAtValue,\n    address swapRouter_,\n    address stableCoin_\n  )\n    external\n  {\n    _initializeEconomy(\n      lpFees,\n      rewardsFees,\n      totalSupply_,\n      excluded_\n    );\n\n    _initializeLP(\n      enableBurnLPAtValue,\n      swapRouter_,\n      stableCoin_\n    );\n  }\n}\n"
    },
    "src/HEROTokenEconomyMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./HEROTokenEconomy.sol\";\n\n\n/**\n * @title HERO token economy module (mock)\n */\ncontract HEROTokenEconomyMock is HEROTokenEconomy {\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    HEROTokenEconomy()\n  {\n    //\n  }\n\n  // external functions\n\n  function initialize(\n    Fees calldata lpFees,\n    Fees calldata rewardsFees,\n    uint256 totalSupply_,\n    address[] calldata excluded_\n  )\n    external\n  {\n    _initializeEconomy(\n      lpFees,\n      rewardsFees,\n      totalSupply_,\n      excluded_\n    );\n  }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "istanbul",
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}