{
  "language": "Solidity",
  "sources": {
    "src/access/Controlled.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Controlled\n */\ncontract Controlled {\n  address public controller;\n\n  // modifiers\n\n  modifier onlyController() {\n    require(\n      msg.sender == controller,\n      \"Controlled#1\"\n    );\n\n    _;\n  }\n\n  // events\n\n  event ControllerUpdated(\n    address controller\n  );\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor()\n    internal\n  {\n    //\n  }\n\n  // internal functions\n\n  function _initializeController(\n    address controller_\n  )\n    internal\n  {\n    controller = controller_;\n  }\n\n  function _setController(\n    address controller_\n  )\n    internal\n  {\n    require(\n      controller_ != address(0),\n      \"Controlled#2\"\n    );\n\n    require(\n      controller_ != controller,\n      \"Controlled#3\"\n    );\n\n    controller = controller_;\n\n    emit ControllerUpdated(\n      controller_\n    );\n  }\n\n  function _removeController()\n    internal\n  {\n    require(\n      controller != address(0),\n      \"Controlled#4\"\n    );\n\n    controller = address(0);\n\n    emit ControllerUpdated(\n      address(0)\n    );\n  }\n}\n"
    },
    "src/HEROToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./access/Controlled.sol\";\nimport \"./access/Owned.sol\";\nimport \"./erc20/ERC20.sol\";\nimport \"./lifecycle/Initializable.sol\";\nimport \"./libs/MathLib.sol\";\nimport \"./HEROLPManager.sol\";\n\n\n/**\n * @title HERO token\n */\ncontract HEROToken is Controlled, Owned, ERC20, Initializable {\n  using MathLib for uint256;\n\n  struct Fees {\n    uint256 sender; // percent\n    uint256 recipient; // percent\n  }\n\n  struct Settings {\n    Fees lpFees;\n    Fees rewardsFees;\n  }\n\n  struct Summary {\n    uint256 totalExcluded;\n    uint256 totalHolding;\n    uint256 totalRewards;\n    uint256 totalSupply;\n  }\n\n  struct ExcludedAccount {\n    bool exists;\n    bool excludeRecipientFromFee;\n  }\n\n  // metadata\n\n  string private constant TOKEN_NAME = \"Metahero\";\n  string private constant TOKEN_SYMBOL = \"HERO\";\n  uint8 private constant TOKEN_DECIMALS = 18; // 0.000000000000000000\n\n  HEROLPManager public lpManager;\n  Settings public settings;\n  Summary public summary;\n  bool public presaleFinished;\n\n  mapping (address => uint256) private accountBalances;\n  mapping (address => mapping (address => uint256)) private accountAllowances;\n  mapping (address => ExcludedAccount) private excludedAccounts;\n\n  // events\n\n  event PresaleFinished();\n\n  event AccountExcluded(\n    address indexed account,\n    bool excludeRecipientFromFee\n  );\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    Controlled()\n    Owned()\n    ERC20(TOKEN_NAME, TOKEN_SYMBOL, TOKEN_DECIMALS)\n    Initializable()\n  {\n    //\n  }\n\n  // external functions\n\n  function initialize(\n    Fees memory lpFees,\n    Fees memory rewardsFees,\n    address payable lpManager_,\n    address controller_,\n    uint256 totalSupply_,\n    address[] calldata excludedAccounts_\n  )\n    external\n    onlyInitializer\n  {\n    settings.lpFees = lpFees;\n    settings.rewardsFees = rewardsFees;\n\n    if (\n      lpFees.sender != 0 ||\n      lpFees.recipient != 0\n    ) {\n      require(\n        lpManager_ != address(0),\n        \"HEROToken#1\"\n      );\n\n      lpManager = HEROLPManager(lpManager_);\n\n      _excludeAccount(lpManager_, false);\n    }\n\n    _initializeController(controller_);\n\n    if (totalSupply_ != 0) {\n      _excludeAccount(msg.sender, false);\n\n      _mint(\n        msg.sender,\n        totalSupply_\n      );\n    }\n\n    uint256 excludedAccountsLen = excludedAccounts_.length;\n\n    for (uint256 index; index < excludedAccountsLen; index++) {\n      _excludeAccount(excludedAccounts_[index], false);\n    }\n  }\n\n  function finishPresale()\n    external\n    onlyOwner\n  {\n    require(\n      !presaleFinished,\n      \"HEROToken#2\"\n    );\n\n    presaleFinished = true;\n\n    emit PresaleFinished();\n  }\n\n  function excludeAccount(\n    address account,\n    bool excludeRecipientFromFee\n  )\n    external\n    onlyOwner\n  {\n    _excludeAccount(\n      account,\n      excludeRecipientFromFee\n    );\n  }\n\n  function approve(\n    address spender,\n    uint256 amount\n  )\n    external\n    override\n    returns (bool)\n  {\n    _approve(\n      msg.sender,\n      spender,\n      amount\n    );\n\n    return true;\n  }\n\n  function mint(\n    address account,\n    uint256 amount\n  )\n    external\n    onlyController\n  {\n    _mint(\n      account,\n      amount\n    );\n  }\n\n  function burn(\n    uint256 amount\n  )\n    external\n  {\n    _burn(\n      msg.sender,\n      amount\n    );\n  }\n\n  function transfer(\n    address recipient,\n    uint256 amount\n  )\n    external\n    override\n    returns (bool)\n  {\n    _transfer(\n      msg.sender,\n      recipient,\n      amount\n    );\n\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    external\n    override\n    returns (bool)\n  {\n    _transfer(\n      sender,\n      recipient,\n      amount\n    );\n\n    uint256 allowance = accountAllowances[sender][msg.sender];\n\n    require(\n      allowance >= amount,\n      \"HEROToken#3\"\n    );\n\n    _approve(\n      sender,\n      msg.sender,\n      allowance.sub(amount)\n    );\n\n    return true;\n  }\n\n  // external functions (views)\n\n  function totalSupply()\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return summary.totalSupply;\n  }\n\n  function allowance(\n    address owner,\n    address spender\n  )\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return accountAllowances[owner][spender];\n  }\n\n  function balanceOf(\n    address account\n  )\n    external\n    view\n    override\n    returns (uint256 result)\n  {\n    result = accountBalances[account].add(\n      _calcRewards(account)\n    );\n\n    return result;\n  }\n\n  function getBalanceSummary(\n    address account\n  )\n    external\n    view\n    returns (\n      uint256 totalBalance,\n      uint256 holdingBalance,\n      uint256 totalRewards\n    )\n  {\n    holdingBalance = accountBalances[account];\n    totalRewards = _calcRewards(account);\n    totalBalance = holdingBalance.add(totalRewards);\n\n    return (totalBalance, holdingBalance, totalRewards);\n  }\n\n  // private functions\n\n  function _excludeAccount(\n    address account,\n    bool excludeRecipientFromFee\n  )\n    private\n  {\n    require(\n      account != address(0),\n      \"HEROToken#4\"\n    );\n\n    if (excludedAccounts[account].exists) {\n      require(\n        excludedAccounts[account].excludeRecipientFromFee != excludeRecipientFromFee,\n        \"HEROToken#5\"\n      );\n\n      excludedAccounts[account].excludeRecipientFromFee = excludeRecipientFromFee;\n    } else {\n      require(\n        accountBalances[account] == 0,\n        \"HEROToken#6\"\n      );\n\n      excludedAccounts[account].exists = true;\n      excludedAccounts[account].excludeRecipientFromFee = excludeRecipientFromFee;\n    }\n\n    emit AccountExcluded(\n      account,\n      excludeRecipientFromFee\n    );\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      owner != address(0),\n      \"HEROToken#7\"\n    );\n\n    require(\n      spender != address(0),\n      \"HEROToken#8\"\n    );\n\n    accountAllowances[owner][spender] = amount;\n\n    emit Approval(\n      owner,\n      spender,\n      amount\n    );\n  }\n\n  function _mint(\n    address account,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      account != address(0),\n      \"HEROToken#9\"\n    );\n\n    require(\n      amount != 0,\n      \"HEROToken#10\"\n    );\n\n    summary.totalSupply = summary.totalSupply.add(amount);\n\n    if (excludedAccounts[account].exists) {\n      summary.totalExcluded = summary.totalExcluded.add(amount);\n    } else {\n      summary.totalHolding = summary.totalHolding.add(amount);\n\n      _updateTotalRewards();\n    }\n\n    accountBalances[account] = accountBalances[account].add(amount);\n\n    emit Transfer(\n      address(0),\n      account,\n      amount\n    );\n  }\n\n  function _burn(\n    address account,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      account != address(0),\n      \"HEROToken#11\"\n    );\n\n    require(\n      amount != 0,\n      \"HEROToken#12\"\n    );\n\n    require(\n      accountBalances[account] >= amount,\n      \"HEROToken#13\"\n    );\n\n    summary.totalSupply = summary.totalSupply.sub(amount);\n\n    if (excludedAccounts[account].exists) {\n      summary.totalExcluded = summary.totalExcluded.sub(amount);\n    } else {\n      summary.totalHolding = summary.totalHolding.sub(amount);\n\n      _updateTotalRewards();\n    }\n\n    accountBalances[account] = accountBalances[account].sub(amount);\n\n    emit Transfer(\n      account,\n      address(0),\n      amount\n    );\n  }\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      sender != address(0),\n      \"HEROToken#14\"\n    );\n\n    require(\n      recipient != address(0),\n      \"HEROToken#15\"\n    );\n\n    require(\n      sender != recipient,\n      \"HEROToken#16\"\n    );\n\n    require(\n      amount != 0,\n      \"HEROToken#17\"\n    );\n\n    require(\n      excludedAccounts[sender].exists ||\n      presaleFinished,\n      \"HEROToken#18\"\n    );\n\n    if (\n      !excludedAccounts[sender].exists &&\n      !excludedAccounts[recipient].exists\n    ) {\n      _transferBetweenHolderAccounts(\n        sender,\n        recipient,\n        amount\n      );\n    } else if (\n      excludedAccounts[sender].exists &&\n      !excludedAccounts[recipient].exists\n    ) {\n      _transferFromExcludedAccount(\n        sender,\n        recipient,\n        amount\n      );\n    } else if (\n      !excludedAccounts[sender].exists &&\n      excludedAccounts[recipient].exists\n    ) {\n      _transferToExcludedAccount(\n        sender,\n        recipient,\n        amount\n      );\n    } else {\n      _transferBetweenExcludedAccounts(\n        sender,\n        recipient,\n        amount\n      );\n    }\n\n    emit Transfer(\n      sender,\n      recipient,\n      amount\n    );\n  }\n\n  function _transferBetweenHolderAccounts(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    (\n      uint256 senderFee,\n      uint256 lpFee\n    ) = _calcTransferSenderFees(amount);\n\n    uint256 recipientFee;\n    uint256 totalFee = senderFee;\n\n    {\n      uint256 recipientLPFee;\n\n      (\n        recipientFee,\n        recipientLPFee\n      ) = _calcTransferRecipientFees(amount);\n\n      lpFee = lpFee.add(recipientLPFee);\n      totalFee = totalFee.add(recipientFee);\n    }\n\n    uint256 senderAmount = amount.add(senderFee);\n    uint256 recipientAmount = amount.sub(recipientFee);\n\n    if (summary.totalRewards != 0) {\n      uint256 totalHoldingWithRewards = summary.totalHolding.add(\n        summary.totalRewards\n      );\n\n      senderAmount = senderAmount.mul(summary.totalHolding).div(\n        totalHoldingWithRewards\n      );\n      recipientAmount = recipientAmount.mul(summary.totalHolding).div(\n        totalHoldingWithRewards\n      );\n      totalFee = totalFee.mul(summary.totalHolding).div(\n        totalHoldingWithRewards\n      );\n    }\n\n    require(\n      accountBalances[sender] >= senderAmount,\n      \"HEROToken#19\"\n    );\n\n    accountBalances[sender] = accountBalances[sender].sub(senderAmount);\n    accountBalances[recipient] = accountBalances[recipient].add(recipientAmount);\n\n    summary.totalHolding = summary.totalHolding.sub(totalFee);\n\n    _increaseTotalLP(lpFee);\n\n    _updateTotalRewards();\n  }\n\n  function _transferFromExcludedAccount(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      accountBalances[sender] >= amount,\n      \"HEROToken#20\"\n    );\n\n    uint256 recipientFee;\n    uint256 lpFee;\n\n    if (!excludedAccounts[sender].excludeRecipientFromFee) {\n      (\n        recipientFee,\n        lpFee\n      ) = _calcTransferSenderFees(amount);\n    }\n\n    uint256 recipientAmount = amount.sub(recipientFee);\n\n    accountBalances[sender] = accountBalances[sender].sub(amount);\n    accountBalances[recipient] = accountBalances[recipient].add(recipientAmount);\n\n    summary.totalExcluded = summary.totalExcluded.sub(amount);\n    summary.totalHolding = summary.totalHolding.add(recipientAmount);\n\n    _increaseTotalLP(lpFee);\n\n    _updateTotalRewards();\n  }\n\n  function _transferToExcludedAccount(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    (\n      uint256 senderFee,\n      uint256 lpFee\n    ) = _calcTransferSenderFees(amount);\n\n    uint256 senderAmount = amount.add(senderFee);\n\n    if (summary.totalRewards != 0) {\n      uint256 totalHoldingWithRewards = summary.totalHolding.add(\n        summary.totalRewards\n      );\n\n      senderAmount = senderAmount.mul(summary.totalHolding).div(\n        totalHoldingWithRewards\n      );\n    }\n\n    require(\n      accountBalances[sender] >= senderAmount,\n      \"HEROToken#21\"\n    );\n\n    accountBalances[sender] = accountBalances[sender].sub(senderAmount);\n    accountBalances[recipient] = accountBalances[recipient].add(amount);\n\n    summary.totalExcluded = summary.totalExcluded.add(amount);\n    summary.totalHolding = summary.totalHolding.sub(senderAmount);\n\n    _increaseTotalLP(lpFee);\n\n    _updateTotalRewards();\n  }\n\n  function _transferBetweenExcludedAccounts(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      accountBalances[sender] >= amount,\n      \"HEROToken#22\"\n    );\n\n    accountBalances[sender] = accountBalances[sender].sub(amount);\n    accountBalances[recipient] = accountBalances[recipient].add(amount);\n  }\n\n  function _increaseTotalLP(\n    uint256 amount\n  )\n    private\n  {\n    if (amount != 0) {\n      accountBalances[address(lpManager)] = accountBalances[address(lpManager)].add(amount);\n\n      summary.totalExcluded = summary.totalExcluded.add(amount);\n\n      lpManager.syncLP();\n    }\n  }\n\n  function _updateTotalRewards()\n    private\n  {\n    summary.totalRewards = summary.totalSupply\n    .sub(summary.totalExcluded)\n    .sub(summary.totalHolding);\n  }\n\n  // private functions (views)\n\n  function _calcRewards(\n    address account\n  )\n    private\n    view\n    returns (uint256 result)\n  {\n    if (\n      !excludedAccounts[account].exists &&\n      summary.totalRewards != 0\n    ) {\n      result = summary.totalRewards\n        .mul(accountBalances[account])\n        .div(summary.totalHolding);\n    }\n\n    return result;\n  }\n\n  function _calcTransferSenderFees(\n    uint256 amount\n  )\n    private\n    view\n    returns (\n      uint256 totalFee,\n      uint256 lpFee\n    )\n  {\n    uint256 rewardsFee = amount.percent(settings.rewardsFees.sender);\n\n    lpFee = amount.percent(settings.lpFees.sender);\n    totalFee = lpFee.add(rewardsFee);\n\n    return (totalFee, lpFee);\n  }\n\n  function _calcTransferRecipientFees(\n    uint256 amount\n  )\n    private\n    view\n    returns (\n      uint256 totalFee,\n      uint256 lpFee\n    )\n  {\n    uint256 rewardsFee = amount.percent(settings.rewardsFees.recipient);\n\n    lpFee = amount.percent(settings.lpFees.recipient);\n    totalFee = lpFee.add(rewardsFee);\n\n    return (totalFee, lpFee);\n  }\n}\n"
    },
    "src/access/Owned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Owned\n */\ncontract Owned {\n  address public owner;\n\n  // modifiers\n\n  modifier onlyOwner() {\n    require(\n      msg.sender == owner,\n      \"Owned#1\"\n    );\n\n    _;\n  }\n\n  // events\n\n  event OwnerUpdated(\n    address owner\n  );\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor()\n    internal\n  {\n    owner = msg.sender;\n  }\n\n  // external functions\n\n  function setOwner(\n    address owner_\n  )\n    external\n    onlyOwner\n  {\n    require(\n      owner_ != address(0),\n      \"Owned#2\"\n    );\n\n    require(\n      owner_ != owner,\n      \"Owned#3\"\n    );\n\n    owner = owner_;\n\n    emit OwnerUpdated(\n      owner_\n    );\n  }\n}\n"
    },
    "src/erc20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./ERC20Metadata.sol\";\nimport \"./ERC20Standard.sol\";\n\n\nabstract contract ERC20 is ERC20Metadata, ERC20Standard {\n  string public override name;\n  string public override symbol;\n  uint8 public override decimals;\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor (\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  )\n    internal\n  {\n    name = name_;\n    symbol = symbol_;\n    decimals = decimals_;\n  }\n}\n"
    },
    "src/lifecycle/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Initializable\n */\ncontract Initializable {\n  address private initializer;\n\n  // events\n\n  event Initialized();\n\n  // modifiers\n\n  modifier onlyInitializer() {\n    require(\n      initializer != address(0),\n      \"Initializable#1\"\n    );\n\n    require(\n      msg.sender == initializer,\n      \"Initializable#2\"\n    );\n\n    initializer = address(0);\n\n    _;\n\n    emit Initialized();\n  }\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor()\n    internal\n  {\n    initializer = msg.sender;\n  }\n\n  // external functions (views)\n\n  function initialized()\n    external\n    view\n    returns (bool)\n  {\n    return initializer == address(0);\n  }\n}\n"
    },
    "src/libs/MathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Math library\n */\nlibrary MathLib {\n  function add(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    uint256 c = a + b;\n\n    require(\n      c >= a,\n      \"MathLib#1\"\n    );\n\n    return c;\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    require(\n      b <= a,\n      \"MathLib#2\"\n    );\n\n    return a - b;\n  }\n\n  function mul(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    if (a == 0 || b == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n\n    require(\n      c / a == b,\n      \"MathLib#3\"\n    );\n\n    return c;\n  }\n\n  function div(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    require(\n      b != 0,\n      \"MathLib#4\"\n    );\n\n    return a / b;\n  }\n\n  function percent(\n    uint256 a,\n    uint256 p\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    uint256 result;\n\n    if (a != 0 && p != 0) {\n      result = div(mul(a, p), 100);\n    }\n\n    return result;\n  }\n}\n"
    },
    "src/HEROLPManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./access/Owned.sol\";\nimport \"./lifecycle/Initializable.sol\";\nimport \"./libs/MathLib.sol\";\nimport \"./HEROToken.sol\";\n\n\n/**\n * @title HERO abstract liquidity pool manager\n */\nabstract contract HEROLPManager is Owned, Initializable {\n  using MathLib for uint256;\n\n  HEROToken public token;\n\n  bool private swapLocked;\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor ()\n    internal\n    Owned()\n    Initializable()\n  {\n    //\n  }\n\n  // external functions\n\n  receive()\n    external\n    payable\n  {\n    //\n  }\n\n  function syncLP()\n    external\n  {\n    if (!swapLocked) {\n      swapLocked = true;\n\n      _syncLP();\n\n      swapLocked = false;\n    }\n  }\n\n  function burnLP(\n    uint256 amount\n  )\n    external\n    onlyOwner\n  {\n    require(\n      amount > 1,\n      \"HEROLPManager#1\"\n    );\n\n    require(\n      !swapLocked,\n      \"HEROLPManager#2\"\n    );\n\n    swapLocked = true;\n\n    _burnLP(amount);\n\n    swapLocked = false;\n  }\n\n  // internal functions\n\n  function _initialize(\n    address token_\n  )\n    internal\n  {\n    require(\n      token_ != address(0),\n      \"HEROLPManager#3\"\n    );\n\n    token = HEROToken(token_);\n  }\n\n  function _syncLP()\n    internal\n    virtual;\n\n  function _burnLP(\n    uint256 amount\n  )\n    internal\n    virtual;\n}\n"
    },
    "src/erc20/ERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\ninterface ERC20Metadata {\n  // external functions (pure)\n\n  function name()\n    external\n    pure\n    returns (string memory);\n\n  function symbol()\n    external\n    pure\n    returns (string memory);\n\n  function decimals()\n    external\n    pure\n    returns (uint8);\n}\n"
    },
    "src/erc20/ERC20Standard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\ninterface ERC20Standard {\n  // events\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  // external functions\n\n  function approve(\n    address spender,\n    uint256 value\n  )\n    external\n    returns (bool);\n\n  function transfer(\n    address to,\n    uint256 value\n  )\n    external\n    returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  )\n    external\n    returns (bool);\n\n  // external functions (views)\n\n  function totalSupply()\n    external\n    view\n    returns (uint256);\n\n  function balanceOf(\n    address owner\n  )\n    external\n    view\n    returns (uint256);\n\n  function allowance(\n    address owner,\n    address spender\n  )\n    external\n    view\n    returns (uint256);\n}\n"
    },
    "src/HEROPresale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./access/Owned.sol\";\nimport \"./lifecycle/Initializable.sol\";\nimport \"./libs/MathLib.sol\";\nimport \"./HEROToken.sol\";\n\n\n/**\n * @title HERO presale\n */\ncontract HEROPresale is Owned, Initializable {\n  using MathLib for uint256;\n\n  struct Settings {\n    uint256 tokensAmountPerNative;\n    uint256 maxPurchasePrice; // max purchase price per whitelisted account\n  }\n\n  struct Summary {\n    uint256 totalAccounts;\n    uint256 totalTokens;\n  }\n\n  HEROToken public token;\n  Settings public settings;\n  Summary public summary;\n  uint256 public deadline;\n\n  mapping (address => bool) public whitelist;\n\n  // events\n\n  event TokensPurchased(\n    address indexed account,\n    uint256 tokensPrice,\n    uint256 tokensAmount\n  );\n\n  event SettingsUpdated(\n    uint256 tokensAmountPerNative,\n    uint256 maxPurchasePrice\n  );\n\n  event DeadlineUpdated(\n    uint256 deadline\n  );\n\n  event AccountAdded(\n    address indexed account\n  );\n\n  event AccountRemoved(\n    address indexed account\n  );\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    Owned()\n    Initializable()\n  {\n    //\n  }\n\n  // external functions\n\n  receive()\n    external\n    payable\n  {\n    require(\n      block.timestamp < deadline, // solhint-disable-line not-rely-on-time\n      \"HEROPresale#1\"\n    );\n\n    require(\n      whitelist[msg.sender],\n      \"HEROPresale#2\"\n    );\n\n    require(\n      msg.value != 0,\n      \"HEROPresale#3\"\n    );\n\n    require(\n      msg.value <= settings.maxPurchasePrice,\n      \"HEROPresale#4\"\n    );\n\n    uint256 tokensAmount = msg.value.mul(settings.tokensAmountPerNative);\n\n    require(\n      tokensAmount <= summary.totalTokens,\n      \"HEROPresale#5\"\n    );\n\n    whitelist[msg.sender] = false;\n\n    summary.totalAccounts = summary.totalAccounts.sub(1);\n    summary.totalTokens = summary.totalTokens.sub(tokensAmount);\n\n    token.transfer(\n      msg.sender,\n      tokensAmount\n    );\n\n    emit TokensPurchased(\n      msg.sender,\n      msg.value,\n      tokensAmount\n    );\n  }\n\n  function initialize(\n    address payable token_,\n    uint256 tokensAmountPerNative,\n    uint256 maxPurchasePrice,\n    uint256 deadlineIn, // in seconds\n    address[] calldata accounts\n  )\n    external\n    onlyInitializer\n  {\n    require(\n      token_ != address(0),\n      \"HEROPresale#6\"\n    );\n\n    token = HEROToken(token_);\n\n    summary.totalTokens = token.balanceOf(address(this));\n\n    _updateSettings(\n      tokensAmountPerNative,\n      maxPurchasePrice\n    );\n\n    _updateDeadline(deadlineIn);\n\n    if (accounts.length != 0) {\n      _addAccounts(accounts);\n    }\n  }\n\n  function updateSettings(\n    uint256 tokensAmountPerNative,\n    uint256 maxPurchasePrice\n  )\n    external\n    onlyOwner\n  {\n    _updateSettings(\n      tokensAmountPerNative,\n      maxPurchasePrice\n    );\n  }\n\n  function syncTotalTokens()\n    external\n  {\n    summary.totalTokens = token.balanceOf(address(this));\n  }\n\n  function updateDeadline(\n    uint256 deadlineIn_ // in seconds\n  )\n    external\n    onlyOwner\n  {\n    _updateDeadline(deadlineIn_);\n  }\n\n  function addAccounts(\n    address[] calldata accounts\n  )\n    external\n    onlyOwner\n  {\n    _addAccounts(accounts);\n  }\n\n  function removeAccounts(\n    address[] calldata accounts\n  )\n    external\n    onlyOwner\n  {\n    uint256 totalRemoved;\n    uint256 accountsLen = accounts.length;\n\n    for (uint256 index ; index < accountsLen ; index++) {\n      require(\n        accounts[index] != address(0),\n        \"HEROPresale#7\"\n      );\n\n      if (whitelist[accounts[index]]) {\n        whitelist[accounts[index]] = false;\n\n        totalRemoved = totalRemoved.add(1);\n\n        emit AccountRemoved(\n          accounts[index]\n        );\n      }\n    }\n\n    require(\n      totalRemoved != 0,\n      \"HEROPresale#8\"\n    );\n\n    summary.totalAccounts = summary.totalAccounts.sub(totalRemoved);\n  }\n\n  function finishPresale()\n    external\n    onlyOwner\n  {\n    require(\n      block.timestamp >= deadline, // solhint-disable-line not-rely-on-time\n      \"HEROPresale#9\"\n    );\n\n    uint256 totalTokens = token.balanceOf(address(this));\n\n    if (totalTokens != 0) {\n      token.burn(\n        totalTokens\n      );\n    }\n\n    selfdestruct(msg.sender);\n  }\n\n  // private functions\n\n  function _updateSettings(\n    uint256 tokensAmountPerNative,\n    uint256 maxPurchasePrice\n  )\n    private\n  {\n    require(\n      tokensAmountPerNative != 0,\n      \"HEROPresale#10\"\n    );\n\n    require(\n      maxPurchasePrice != 0,\n      \"HEROPresale#11\"\n    );\n\n    settings.tokensAmountPerNative = tokensAmountPerNative;\n    settings.maxPurchasePrice = maxPurchasePrice;\n\n    emit SettingsUpdated(\n      tokensAmountPerNative,\n      maxPurchasePrice\n    );\n  }\n\n  function _updateDeadline(\n    uint256 deadlineIn\n  )\n    private\n  {\n    deadline = block.timestamp.add(deadlineIn); // solhint-disable-line not-rely-on-time\n\n    emit DeadlineUpdated(\n      deadline\n    );\n  }\n\n  function _addAccounts(\n    address[] memory accounts\n  )\n    private\n  {\n    uint256 totalAdded;\n    uint256 accountsLen = accounts.length;\n\n    for (uint256 index ; index < accountsLen ; index++) {\n      require(\n        accounts[index] != address(0),\n        \"HEROPresale#12\"\n      );\n\n      if (!whitelist[accounts[index]]) {\n        whitelist[accounts[index]] = true;\n\n        totalAdded = totalAdded.add(1);\n\n        emit AccountAdded(\n          accounts[index]\n        );\n      }\n    }\n\n    require(\n      totalAdded != 0,\n      \"HEROPresale#13\"\n    );\n\n    summary.totalAccounts = summary.totalAccounts.add(totalAdded);\n  }\n}\n"
    },
    "src/HEROLPManagerUniswapV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./uniswap/UniswapV2Factory.sol\";\nimport \"./uniswap/UniswapV2Pair.sol\";\nimport \"./uniswap/UniswapV2Router02.sol\";\nimport \"./HEROLPManager.sol\";\n\n\n/**\n * @title HERO liquidity pool manager for Uniswap V2\n */\ncontract HEROLPManagerUniswapV2 is HEROLPManager {\n  struct Settings {\n    uint256 enableBurnLPAtValue;\n    address stableCoin;\n  }\n\n  Settings public settings;\n  UniswapV2Factory public uniswapFactory;\n  UniswapV2Pair public uniswapTokenPair;\n  UniswapV2Router02 public uniswapRouter;\n\n  address private wrappedNative;\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    HEROLPManager()\n  {\n    //\n  }\n\n  // external functions\n\n  function initialize(\n    uint256 enableBurnLPAtValue,\n    address stableCoin,\n    address token_,\n    address uniswapRouter_\n  )\n    external\n    onlyInitializer\n  {\n    _initialize(token_);\n\n    if (enableBurnLPAtValue != 0) {\n      require(\n        stableCoin != address(0),\n        \"HEROLPManagerUniswapV2#1\"\n      );\n\n      settings.enableBurnLPAtValue = enableBurnLPAtValue;\n      settings.stableCoin = stableCoin;\n    }\n\n    require(\n      uniswapRouter_ != address(0),\n      \"HEROLPManagerUniswapV2#2\"\n    );\n\n    uniswapRouter = UniswapV2Router02(uniswapRouter_);\n    uniswapFactory = UniswapV2Factory(uniswapRouter.factory());\n\n    wrappedNative = uniswapRouter.WETH();\n\n    uniswapTokenPair = UniswapV2Pair(uniswapFactory.createPair(\n      address(token),\n      wrappedNative\n    ));\n  }\n\n  // internal functions\n\n  function _syncLP()\n    internal\n    override\n  {\n    uint256 tokensAmount = token.balanceOf(address(this));\n    uint256 nativeAmount = address(this).balance;\n\n    if (tokensAmount != 0 && nativeAmount != 0) {\n      uint256 half = tokensAmount.div(2);\n      uint256 otherHalf = tokensAmount.sub(half);\n\n      _swapTokensForNative(half);\n\n      _addLiquidity(\n        otherHalf,\n        nativeAmount\n      );\n    }\n  }\n\n  function _burnLP(\n    uint256 amount\n  )\n    internal\n    override\n  {\n    uint256 tokenAmount;\n\n    if (settings.enableBurnLPAtValue != 0) {\n      (tokenAmount, ) = _getLiquidityReserves();\n\n      require(\n        tokenAmount != 0,\n        \"HEROLPManagerUniswapV2#3\"\n      );\n\n      require(\n        amount <= tokenAmount,\n        \"HEROLPManagerUniswapV2#4\"\n      );\n\n      address[] memory path = new address[](3);\n\n      path[0] = address(token);\n      path[1] = wrappedNative;\n      path[2] = settings.stableCoin;\n\n      uint256[] memory amounts = uniswapRouter.getAmountsOut(amount, path);\n\n      uint256 tokensValue = amounts[2];\n\n      require(\n        tokensValue > settings.enableBurnLPAtValue,\n        \"HEROLPManagerUniswapV2#5\"\n      );\n\n      uint256 amountValue = amount.mul(tokensValue).div(tokenAmount);\n      uint256 maxValue = tokensValue.div(settings.enableBurnLPAtValue);\n\n      require(\n        maxValue >= amountValue,\n        \"HEROLPManagerUniswapV2#6\"\n      );\n    }\n\n    (tokenAmount, ) = _removeLiquidity(\n      uniswapTokenPair.balanceOf(address(this))\n    );\n\n    require(\n      tokenAmount >= amount,\n      \"HEROLPManagerUniswapV2#7\"\n    );\n\n    token.burn(amount);\n\n    _addLiquidity(\n      token.balanceOf(address(this)),\n      address(this).balance\n    );\n  }\n\n  function _swapTokensForNative(\n    uint256 tokenAmount\n  )\n    private\n  {\n    if (tokenAmount != 0) {\n      token.approve(\n        address(uniswapRouter),\n        tokenAmount\n      );\n\n      address[] memory path = new address[](2);\n\n      path[0] = address(token);\n      path[1] = wrappedNative;\n\n      uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\n        tokenAmount,\n        0,\n        path,\n        address(this),\n        block.timestamp // solhint-disable-line not-rely-on-time\n      );\n    }\n  }\n\n  function _addLiquidity(\n    uint256 tokenAmount,\n    uint256 nativeAmount\n  )\n    private\n  {\n    if (tokenAmount != 0 && nativeAmount != 0) {\n      token.approve(\n        address(uniswapRouter),\n        tokenAmount\n      );\n\n      uniswapRouter.addLiquidityETH{value : nativeAmount}(\n        address(token),\n        tokenAmount,\n        0,\n        0,\n        address(this),\n        block.timestamp // solhint-disable-line not-rely-on-time\n      );\n    }\n  }\n\n  function _removeLiquidity(\n    uint256 liquidity\n  )\n    private\n    returns (\n      uint256 tokenAmount,\n      uint256 nativeAmount\n    )\n  {\n    uniswapTokenPair.approve(\n      address(uniswapRouter),\n      liquidity\n    );\n\n    return uniswapRouter.removeLiquidityETH(\n      address(token),\n      liquidity,\n      0,\n      0,\n      address(this),\n      block.timestamp // solhint-disable-line not-rely-on-time\n    );\n  }\n\n  // private functions (views)\n\n  function _getLiquidityReserves()\n    private\n    view\n    returns (\n      uint256 tokenAmount,\n      uint256 nativeAmount\n    )\n  {\n    (\n      uint112 reserve0,\n      uint112 reserve1,\n    )= uniswapTokenPair.getReserves();\n\n    (tokenAmount, nativeAmount) = address(token) < wrappedNative\n      ? (reserve0, reserve1)\n      : (reserve1, reserve0);\n\n    return (tokenAmount, nativeAmount);\n  }\n}\n"
    },
    "src/uniswap/UniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\ninterface UniswapV2Factory {\n  // events\n\n  event PairCreated(\n    address indexed token0,\n    address indexed token1,\n    address pair,\n    uint256\n  );\n\n  // external functions\n\n  function createPair(\n    address tokenA,\n    address tokenB\n  )\n    external\n    returns (address);\n\n  function setFeeTo(\n    address\n  )\n    external;\n\n  function setFeeToSetter(\n    address\n  )\n    external;\n\n  // external functions (views)\n\n  function feeTo()\n    external\n    view\n    returns (address);\n\n  function feeToSetter()\n    external\n    view\n    returns (address);\n\n  function getPair(\n    address tokenA,\n    address tokenB\n  )\n    external\n    view\n    returns (address);\n\n  function allPairs(\n    uint256\n  )\n    external\n    view\n    returns (address);\n\n  function allPairsLength()\n    external\n    view\n    returns (uint256);\n}\n\n"
    },
    "src/uniswap/UniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable func-name-mixedcase */\npragma solidity ^0.6.12;\n\nimport \"../erc20/ERC20Metadata.sol\";\nimport \"../erc20/ERC20Standard.sol\";\n\n\ninterface UniswapV2Pair is ERC20Metadata, ERC20Standard {\n  // events\n\n  event Mint(\n    address indexed sender,\n    uint amount0,\n    uint amount1\n  );\n\n  event Burn(\n    address indexed sender,\n    uint amount0,\n    uint amount1,\n    address indexed to\n  );\n\n  event Swap(\n    address indexed sender,\n    uint amount0In,\n    uint amount1In,\n    uint amount0Out,\n    uint amount1Out,\n    address indexed to\n  );\n\n  event Sync(\n    uint112 reserve0,\n    uint112 reserve1\n  );\n\n  // external functions\n\n  function initialize(\n    address,\n    address\n  )\n    external;\n\n  function mint(\n    address to\n  )\n    external\n    returns (uint);\n\n  function burn(\n    address to\n  )\n    external\n    returns (uint, uint);\n\n  function swap(\n    uint amount0Out,\n    uint amount1Out,\n    address to,\n    bytes calldata data\n  )\n    external;\n\n  function skim(\n    address to\n  )\n    external;\n\n  function sync()\n    external;\n\n  function permit(\n    address owner,\n    address spender,\n    uint value,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external;\n\n  // external functions (views)\n\n  function DOMAIN_SEPARATOR()\n    external\n    view\n    returns (bytes32);\n\n  function nonces(\n    address owner\n  )\n    external\n    view\n    returns (uint);\n\n  function factory()\n    external\n    view\n    returns (address);\n\n  function token0()\n    external\n    view\n    returns (address);\n\n  function token1()\n    external\n    view\n    returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (uint112, uint112, uint32);\n\n  function price0CumulativeLast()\n    external\n    view\n    returns (uint);\n\n  function price1CumulativeLast()\n    external\n    view\n    returns (uint);\n\n  function kLast()\n    external\n    view\n    returns (uint);\n\n  // external functions (pure)\n\n  function PERMIT_TYPEHASH()\n    external\n    pure\n    returns (bytes32);\n\n  function MINIMUM_LIQUIDITY()\n    external\n    pure\n    returns (uint);\n}\n"
    },
    "src/uniswap/UniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./UniswapV2Router01.sol\";\n\n\ninterface UniswapV2Router02 is UniswapV2Router01 {\n  // external functions\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    payable;\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  )\n    external\n    returns (uint);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external\n    returns (uint);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external;\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external;\n}\n"
    },
    "src/uniswap/UniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable func-name-mixedcase */\npragma solidity ^0.6.12;\n\ninterface UniswapV2Router01 {\n  // external functions\n\n  function addLiquidityETH(\n    address token,\n    uint amountTokenDesired,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  )\n    external\n    payable\n    returns (uint, uint, uint);\n\n  function swapExactETHForTokens(\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    payable\n    returns (uint[] memory);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n  )\n    external\n    returns (uint, uint, uint);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n  )\n    external\n    returns (uint, uint);\n\n  function removeLiquidityETH(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  )\n    external\n    returns (uint, uint);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external\n    returns (uint, uint);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external\n    returns (uint, uint);\n\n  function swapExactTokensForTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    returns (uint[] memory);\n\n  function swapTokensForExactTokens(\n    uint amountOut,\n    uint amountInMax,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    returns (uint[] memory);\n\n  function swapTokensForExactETH(\n    uint amountOut,\n    uint amountInMax,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    returns (uint[] memory);\n\n  function swapExactTokensForETH(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    returns (uint[] memory);\n\n  function swapETHForExactTokens(\n    uint amountOut,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    payable\n    returns (uint[] memory);\n\n  // external functions (views)\n\n  function getAmountsOut(\n    uint amountIn,\n    address[] calldata path\n  )\n    external\n    view\n    returns (uint[] memory);\n\n  function getAmountsIn(\n    uint amountOut,\n    address[] calldata path\n  )\n    external\n    view\n    returns (uint[] memory);\n\n  // external functions (pure)\n\n  function quote(\n    uint amountA,\n    uint reserveA,\n    uint reserveB\n  )\n    external\n    pure\n    returns (uint);\n\n  function getAmountOut(\n    uint amountIn,\n    uint reserveIn,\n    uint reserveOut\n  )\n    external\n    pure\n    returns (uint);\n\n  function getAmountIn(\n    uint amountOut,\n    uint reserveIn,\n    uint reserveOut\n  )\n    external\n    pure\n    returns (uint);\n\n  function factory()\n    external\n    pure\n    returns (address);\n\n  function WETH()\n    external\n    pure\n    returns (address);\n}\n"
    },
    "src/HEROLPManagerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./HEROLPManager.sol\";\n\n\n/**\n * @title HERO liquidity pool manager mock\n */\ncontract HEROLPManagerMock is HEROLPManager {\n  uint256 public totalLP;\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    HEROLPManager()\n  {\n    //\n  }\n\n  // external functions\n\n  function initialize(\n    address token_\n  )\n    external\n    onlyInitializer\n  {\n    _initialize(token_);\n  }\n\n  // internal functions\n\n  function _syncLP()\n    internal\n    override\n  {\n    totalLP = token.balanceOf(address(this));\n  }\n\n  function _burnLP(\n    uint256 amount\n  )\n    internal\n    override\n  {\n    token.burn(\n      amount\n    );\n\n    totalLP = token.balanceOf(address(this));\n  }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "istanbul",
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}