{
  "language": "Solidity",
  "sources": {
    "src/core/access/Controlled.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Controlled\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract Controlled {\n  /**\n   * @return controller address\n   */\n  address public controller;\n\n  // modifiers\n\n  /**\n   * @dev Throws if msg.sender is not the controller\n   */\n  modifier onlyController() {\n    require(\n      msg.sender == controller,\n      \"Controlled#1\" // msg.sender is not the controller\n    );\n\n    _;\n  }\n\n  // events\n\n  /**\n   * @dev Emitted when the controller is updated\n   * @param controller new controller address\n   */\n  event ControllerUpdated(\n    address controller\n  );\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor()\n    internal\n  {\n    //\n  }\n\n  // internal functions\n\n  function _initializeController(\n    address controller_\n  )\n    internal\n  {\n    controller = controller_;\n  }\n\n  function _setController(\n    address controller_\n  )\n    internal\n  {\n    require(\n      controller_ != address(0),\n      \"Controlled#2\" // controller is the zero address\n    );\n\n    require(\n      controller_ != controller,\n      \"Controlled#3\" // does not update the controller\n    );\n\n    controller = controller_;\n\n    emit ControllerUpdated(\n      controller_\n    );\n  }\n\n  function _removeController()\n    internal\n  {\n    require(\n      controller != address(0),\n      \"Controlled#4\" // controller is the zero address\n    );\n\n    controller = address(0);\n\n    emit ControllerUpdated(\n      address(0)\n    );\n  }\n}\n"
    },
    "src/MetaheroToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./core/access/Controlled.sol\";\nimport \"./core/access/Owned.sol\";\nimport \"./core/erc20/ERC20.sol\";\nimport \"./core/lifecycle/Initializable.sol\";\nimport \"./core/math/MathLib.sol\";\nimport \"./core/math/SafeMathLib.sol\";\nimport \"./IMetaheroDAO.sol\";\nimport \"./MetaheroLPM.sol\";\n\n\n/**\n * @title Metahero token\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract MetaheroToken is Controlled, Owned, ERC20, Initializable {\n  using MathLib for uint256;\n  using SafeMathLib for uint256;\n\n  struct Fees {\n    uint256 sender; // percent from sender\n    uint256 recipient; // percent from recipient\n  }\n\n  struct Settings {\n    Fees burnFees; // fee taken and burned\n    Fees lpFees; // fee taken and added to the liquidity pool manager\n    Fees rewardsFees; // fee taken and added to rewards\n    uint256 minTotalSupply; // min amount of tokens total supply\n  }\n\n  struct Summary {\n    uint256 totalExcluded; // total held by excluded accounts\n    uint256 totalHolding; // total held by holder accounts\n    uint256 totalRewards; // total rewards\n    uint256 totalSupply; // total supply\n  }\n\n  struct ExcludedAccount {\n    bool exists; // true if exists\n    bool excludeSenderFromFee; // removes the fee from all sender accounts on incoming transfers\n    bool excludeRecipientFromFee; // removes the fee from all recipient accounts on outgoing transfers\n  }\n\n  // globals\n\n  uint256 private constant MAX_FEE = 30; // max sum of all fees - 30%\n\n  // metadata\n\n  string private constant TOKEN_NAME = \"Metahero\";\n  string private constant TOKEN_SYMBOL = \"HERO\";\n  uint8 private constant TOKEN_DECIMALS = 18; // 0.000000000000000000\n\n  /**\n   * @return dao address\n   */\n  IMetaheroDAO public dao;\n\n  /**\n   * @return liquidity pool manager address\n   */\n  MetaheroLPM public lpm;\n\n  /**\n   * @return settings object\n   */\n  Settings public settings;\n\n  /**\n   * @return summary object\n   */\n  Summary public summary;\n\n  /**\n   * @return return true when presale is finished\n   */\n  bool public presaleFinished;\n\n  mapping (address => uint256) private accountBalances;\n  mapping (address => mapping (address => uint256)) private accountAllowances;\n  mapping (address => ExcludedAccount) private excludedAccounts;\n\n  // events\n\n  /**\n   * @dev Emitted when the contract is initialized\n   * @param burnFees burn fees\n   * @param lpFees liquidity pool fees\n   * @param rewardsFees rewards fees\n   * @param minTotalSupply min total supply\n   * @param lpm liquidity pool manager address\n   * @param controller controller address\n   */\n  event Initialized(\n    Fees burnFees,\n    Fees lpFees,\n    Fees rewardsFees,\n    uint256 minTotalSupply,\n    address lpm,\n    address controller\n  );\n\n  /**\n   * @dev Emitted when the dao is updated\n   * @param dao dao address\n   */\n  event DAOUpdated(\n    address dao\n  );\n\n  /**\n   * @dev Emitted when fees are updated\n   * @param burnFees burn fees\n   * @param lpFees liquidity pool fees\n   * @param rewardsFees rewards fees\n   */\n  event FeesUpdated(\n    Fees burnFees,\n    Fees lpFees,\n    Fees rewardsFees\n  );\n\n  /**\n   * @dev Emitted when the presale is finished\n   */\n  event PresaleFinished();\n\n  /**\n   * @dev Emitted when account is excluded\n   * @param account account address\n   * @param excludeSenderFromFee exclude sender from fee\n   * @param excludeRecipientFromFee exclude recipient from fee\n   */\n  event AccountExcluded(\n    address indexed account,\n    bool excludeSenderFromFee,\n    bool excludeRecipientFromFee\n  );\n\n  /**\n   * @dev Emitted when total rewards amount is updated\n   * @param totalRewards total rewards amount\n   */\n  event TotalRewardsUpdated(\n    uint256 totalRewards\n  );\n\n  // modifiers\n\n  /**\n   * @dev Throws if msg.sender is not the dao\n   */\n  modifier onlyDAO() {\n    require(\n      msg.sender == address(dao),\n      \"MetaheroToken#1\" // msg.sender is not the dao\n    );\n\n    _;\n  }\n\n  /**\n   * @dev Throws if msg.sender is not the excluded account\n   */\n  modifier onlyExcludedAccount() {\n    require(\n      excludedAccounts[msg.sender].exists,\n      \"MetaheroToken#2\" // msg.sender is not the excluded account\n    );\n\n    _;\n  }\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    Controlled()\n    Owned()\n    ERC20(TOKEN_NAME, TOKEN_SYMBOL, TOKEN_DECIMALS) // sets metadata\n    Initializable()\n  {\n    //\n  }\n\n  // external functions\n\n  /**\n   * @dev Initializes the contract\n   * @param burnFees burn fees\n   * @param lpFees liquidity pool fees\n   * @param rewardsFees rewards fees\n   * @param minTotalSupply min total supply\n   * @param lpm_ liquidity pool manager address\n   * @param controller_ controller address\n   * @param totalSupply_ total supply\n   */\n  function initialize(\n    Fees memory burnFees,\n    Fees memory lpFees,\n    Fees memory rewardsFees,\n    uint256 minTotalSupply,\n    address payable lpm_,\n    address controller_,\n    uint256 totalSupply_,\n    address[] calldata excludedAccounts_\n  )\n    external\n    onlyInitializer\n  {\n    _verifyFees(burnFees, lpFees, rewardsFees);\n\n    settings.burnFees = burnFees;\n    settings.lpFees = lpFees;\n    settings.rewardsFees = rewardsFees;\n    settings.minTotalSupply = minTotalSupply;\n\n    if (\n      lpFees.sender != 0 ||\n      lpFees.recipient != 0\n    ) {\n      require(\n        lpm_ != address(0),\n        \"MetaheroToken#3\" // lpm is the zero address\n      );\n\n      lpm = MetaheroLPM(lpm_);\n    }\n\n    _initializeController(controller_);\n\n    emit Initialized(\n      burnFees,\n      lpFees,\n      rewardsFees,\n      minTotalSupply,\n      lpm_,\n      controller_\n    );\n\n    // excludes owner account\n    _excludeAccount(msg.sender, true, true);\n\n    if (totalSupply_ != 0) {\n      _mint(\n        msg.sender,\n        totalSupply_\n      );\n    }\n\n    // adds predefined excluded accounts\n    uint256 excludedAccountsLen = excludedAccounts_.length;\n\n    for (uint256 index; index < excludedAccountsLen; index++) {\n      _excludeAccount(excludedAccounts_[index], false, false);\n    }\n  }\n\n  /**\n   * @dev Sets the dao\n   * @param dao_ dao address\n   */\n  function setDAO(\n    address dao_\n  )\n    external\n    onlyOwner\n  {\n    require(\n      dao_ != address(0),\n      \"MetaheroToken#4\" // lpm is the zero address\n    );\n\n    dao = IMetaheroDAO(dao_);\n\n    emit DAOUpdated(\n      dao_\n    );\n\n    // makes a dao an owner\n    _setOwner(dao_);\n  }\n\n  /**\n   * @dev Updates fees\n   * @param burnFees burn fees\n   * @param lpFees liquidity pool fees\n   * @param rewardsFees rewards fees\n   */\n  function updateFees(\n    Fees memory burnFees,\n    Fees memory lpFees,\n    Fees memory rewardsFees\n  )\n    external\n    onlyDAO // only for dao\n  {\n    _verifyFees(burnFees, lpFees, rewardsFees);\n\n    settings.burnFees = burnFees;\n    settings.lpFees = lpFees;\n    settings.rewardsFees = rewardsFees;\n\n    emit FeesUpdated(\n      burnFees,\n      lpFees,\n      rewardsFees\n    );\n  }\n\n  /**\n   * @dev Set the presale as finished\n   */\n  function setPresaleAsFinished()\n    external\n    onlyOwner\n  {\n    require(\n      !presaleFinished,\n      \"MetaheroToken#5\" // the presale is already finished\n    );\n\n    presaleFinished = true;\n\n    emit PresaleFinished();\n  }\n\n  /**\n   * @dev Excludes account\n   * @param account account address\n   * @param excludeSenderFromFee exclude sender from fee\n   * @param excludeRecipientFromFee exclude recipient from fee\n   */\n  function excludeAccount(\n    address account,\n    bool excludeSenderFromFee,\n    bool excludeRecipientFromFee\n  )\n    external\n    onlyOwner\n  {\n    _excludeAccount(\n      account,\n      excludeSenderFromFee,\n      excludeRecipientFromFee\n    );\n  }\n\n  /**\n   * @dev Approve spending limit\n   * @param spender spender address\n   * @param amount spending limit\n   */\n  function approve(\n    address spender,\n    uint256 amount\n  )\n    external\n    override\n    returns (bool)\n  {\n    _approve(\n      msg.sender,\n      spender,\n      amount\n    );\n\n    return true;\n  }\n\n  /**\n   * @dev Mints tokens to recipient\n   * @param recipient recipient address\n   * @param amount tokens amount\n   */\n  function mintTo(\n    address recipient,\n    uint256 amount\n  )\n    external\n    onlyController\n  {\n    _mint(\n      recipient,\n      amount\n    );\n  }\n\n  /**\n   * @dev Burns tokens from msg.sender\n   * @param amount tokens amount\n   */\n  function burn(\n    uint256 amount\n  )\n    external\n    onlyExcludedAccount\n  {\n    _burn(\n      msg.sender,\n      amount\n    );\n  }\n\n  /**\n   * @dev Burns tokens from sender\n   * @param sender sender address\n   * @param amount tokens amount\n   */\n  function burnFrom(\n    address sender,\n    uint256 amount\n  )\n    external\n    onlyController\n  {\n    _burn(\n      sender,\n      amount\n    );\n  }\n\n  /**\n   * @dev Transfers tokens to recipient\n   * @param recipient recipient address\n   * @param amount tokens amount\n   */\n  function transfer(\n    address recipient,\n    uint256 amount\n  )\n    external\n    override\n    returns (bool)\n  {\n    _transfer(\n      msg.sender,\n      recipient,\n      amount\n    );\n\n    return true;\n  }\n\n  /**\n   * @dev Transfers tokens from sender to recipient\n   * @param sender sender address\n   * @param recipient recipient address\n   * @param amount tokens amount\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    external\n    override\n    returns (bool)\n  {\n    _transfer(\n      sender,\n      recipient,\n      amount\n    );\n\n    uint256 allowance = accountAllowances[sender][msg.sender];\n\n    require(\n      allowance >= amount,\n      \"MetaheroToken#6\"  // amount exceeds allowance\n    );\n\n    _approve( // update allowance\n      sender,\n      msg.sender,\n      allowance.sub(amount)\n    );\n\n    return true;\n  }\n\n  // external functions (views)\n\n  /**\n   * @dev Gets excluded account\n   * @param account account address\n   */\n  function getExcludedAccount(\n    address account\n  )\n    external\n    view\n    returns (\n      bool exists,\n      bool excludeSenderFromFee,\n      bool excludeRecipientFromFee\n    )\n  {\n    return (\n      excludedAccounts[account].exists,\n      excludedAccounts[account].excludeSenderFromFee,\n      excludedAccounts[account].excludeRecipientFromFee\n    );\n  }\n\n  /**\n   * @dev Gets total supply\n   * @return total supply\n   */\n  function totalSupply()\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return summary.totalSupply;\n  }\n\n  /**\n   * @dev Gets allowance\n   * @param owner owner address\n   * @param spender spender address\n   * @return allowance\n   */\n  function allowance(\n    address owner,\n    address spender\n  )\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return accountAllowances[owner][spender];\n  }\n\n  /**\n   * @dev Gets balance of\n   * @param account account address\n   * @return result account balance\n   */\n  function balanceOf(\n    address account\n  )\n    external\n    view\n    override\n    returns (uint256 result)\n  {\n    result = accountBalances[account].add(\n      _calcRewards(account)\n    );\n\n    return result;\n  }\n\n  /**\n   * @dev Gets balance summary\n   * @param account account address\n   */\n  function getBalanceSummary(\n    address account\n  )\n    external\n    view\n    returns (\n      uint256 totalBalance,\n      uint256 holdingBalance,\n      uint256 totalRewards\n    )\n  {\n    holdingBalance = accountBalances[account];\n    totalRewards = _calcRewards(account);\n    totalBalance = holdingBalance.add(totalRewards);\n\n    return (totalBalance, holdingBalance, totalRewards);\n  }\n\n  // private functions\n\n  function _excludeAccount(\n    address account,\n    bool excludeSenderFromFee,\n    bool excludeRecipientFromFee\n  )\n    private\n  {\n    require(\n      account != address(0),\n      \"MetaheroToken#7\" // account is the zero address\n    );\n\n    // if already excluded\n    if (excludedAccounts[account].exists) {\n      require(\n        excludedAccounts[account].excludeSenderFromFee != excludeSenderFromFee ||\n        excludedAccounts[account].excludeRecipientFromFee != excludeRecipientFromFee,\n        \"MetaheroToken#8\" // does not update exclude account\n      );\n\n      excludedAccounts[account].excludeSenderFromFee = excludeSenderFromFee;\n      excludedAccounts[account].excludeRecipientFromFee = excludeRecipientFromFee;\n    } else {\n      require(\n        accountBalances[account] == 0,\n        \"MetaheroToken#9\" // can not exclude holder account\n      );\n\n      excludedAccounts[account].exists = true;\n      excludedAccounts[account].excludeSenderFromFee = excludeSenderFromFee;\n      excludedAccounts[account].excludeRecipientFromFee = excludeRecipientFromFee;\n    }\n\n    emit AccountExcluded(\n      account,\n      excludeSenderFromFee,\n      excludeRecipientFromFee\n    );\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      spender != address(0),\n      \"MetaheroToken#11\" // spender is the zero address\n    );\n\n    accountAllowances[owner][spender] = amount;\n\n    emit Approval(\n      owner,\n      spender,\n      amount\n    );\n  }\n\n  function _mint(\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      recipient != address(0),\n      \"MetaheroToken#12\" // recipient is the zero address\n    );\n\n    require(\n      amount != 0,\n      \"MetaheroToken#13\" // amount is zero\n    );\n\n    summary.totalSupply = summary.totalSupply.add(amount);\n\n    // if exclude account\n    if (excludedAccounts[recipient].exists) {\n      summary.totalExcluded = summary.totalExcluded.add(amount);\n\n      accountBalances[recipient] = accountBalances[recipient].add(amount);\n    } else {\n      _updateHoldingBalance(\n        recipient,\n        accountBalances[recipient].add(amount),\n        summary.totalHolding.add(amount)\n      );\n    }\n\n    _emitTransfer(\n      address(0),\n      recipient,\n      amount\n    );\n  }\n\n  function _burn(\n    address sender,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      sender != address(0),\n      \"MetaheroToken#14\" // sender is the zero address\n    );\n\n    require(\n      amount != 0,\n      \"MetaheroToken#15\" // amount is zero\n    );\n\n    require(\n      accountBalances[sender] >= amount,\n      \"MetaheroToken#16\" // amount exceeds sender balance\n    );\n\n    uint256 totalSupply_ = summary.totalSupply.sub(amount);\n\n    if (settings.minTotalSupply != 0) {\n      require(\n        totalSupply_ >= settings.minTotalSupply,\n        \"MetaheroToken#17\" // new total supply exceeds min total supply\n      );\n    }\n\n    summary.totalSupply = totalSupply_;\n\n    // if exclude account\n    if (excludedAccounts[sender].exists) {\n      summary.totalExcluded = summary.totalExcluded.sub(amount);\n\n      accountBalances[sender] = accountBalances[sender].sub(amount);\n    } else {\n      _updateHoldingBalance(\n        sender,\n        accountBalances[sender].sub(amount),\n        summary.totalHolding.sub(amount)\n      );\n    }\n\n    _emitTransfer(\n      sender,\n      address(0),\n      amount\n    );\n  }\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      sender != address(0),\n      \"MetaheroToken#18\" // sender is the zero address\n    );\n\n    require(\n      recipient != address(0),\n      \"MetaheroToken#19\" // recipient is the zero address\n    );\n\n    if (sender == recipient) { // special transfer type\n      _syncLP(); // sync only LP\n\n      _emitTransfer(\n        sender,\n        recipient,\n        0\n      );\n    } else {\n      require(\n        excludedAccounts[sender].exists ||\n        presaleFinished,\n        \"MetaheroToken#20\" // presale not finished yet\n      );\n\n      require(\n        amount != 0,\n        \"MetaheroToken#21\" // amount is zero\n      );\n\n      if (\n        !excludedAccounts[sender].exists &&\n        !excludedAccounts[recipient].exists\n      ) {\n        _transferBetweenHolderAccounts(\n          sender,\n          recipient,\n          amount\n        );\n      } else if (\n        excludedAccounts[sender].exists &&\n        !excludedAccounts[recipient].exists\n      ) {\n        _transferFromExcludedAccount(\n          sender,\n          recipient,\n          amount\n        );\n      } else if (\n        !excludedAccounts[sender].exists &&\n        excludedAccounts[recipient].exists\n      ) {\n        _transferToExcludedAccount(\n          sender,\n          recipient,\n          amount\n        );\n      } else {\n        _transferBetweenExcludedAccounts(\n          sender,\n          recipient,\n          amount\n        );\n      }\n    }\n  }\n\n  function _transferBetweenHolderAccounts(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    uint256 senderAmount;\n    uint256 senderBurnFee;\n    uint256 senderLpFee;\n\n    uint256 recipientAmount;\n    uint256 recipientBurnFee;\n    uint256 recipientLpFee;\n\n    uint256 totalFee;\n\n    {\n      uint256 totalSupply_ = summary.totalSupply;\n\n      // calc fees for sender and recipient\n      {\n        uint256 senderTotalFee;\n        uint256 recipientTotalFee;\n\n        (\n          senderTotalFee,\n          senderBurnFee,\n          senderLpFee\n        ) = _calcTransferSenderFees(amount);\n\n        (\n          totalSupply_,\n          senderTotalFee,\n          senderBurnFee\n        ) = _matchTotalSupplyWithFees(totalSupply_, senderTotalFee, senderBurnFee);\n\n        (\n          recipientTotalFee,\n          recipientBurnFee,\n          recipientLpFee\n        ) = _calcTransferRecipientFees(amount);\n\n        (\n          totalSupply_,\n          recipientTotalFee,\n          recipientBurnFee\n        ) = _matchTotalSupplyWithFees(totalSupply_, recipientTotalFee, recipientBurnFee);\n\n        totalFee = senderTotalFee.add(recipientTotalFee);\n        senderAmount = amount.add(senderTotalFee);\n        recipientAmount = amount.sub(recipientTotalFee);\n      }\n\n      // appends total rewards\n      if (summary.totalRewards != 0) {\n        uint256 totalHoldingWithRewards = summary.totalHolding.add(\n          summary.totalRewards\n        );\n\n        senderAmount = senderAmount.mul(summary.totalHolding).div(\n          totalHoldingWithRewards\n        );\n        recipientAmount = recipientAmount.mul(summary.totalHolding).div(\n          totalHoldingWithRewards\n        );\n        totalFee = totalFee.mul(summary.totalHolding).div(\n          totalHoldingWithRewards\n        );\n      }\n\n      require(\n        accountBalances[sender] >= senderAmount,\n        \"MetaheroToken#22\" // amount exceeds sender balance\n      );\n\n      summary.totalSupply = totalSupply_;\n\n      // reduce local vars\n      senderAmount = accountBalances[sender].sub(senderAmount);\n      recipientAmount = accountBalances[recipient].add(recipientAmount);\n\n      _updateHoldingBalances(\n        sender,\n        senderAmount,\n        recipient,\n        recipientAmount,\n        summary.totalHolding.sub(totalFee)\n      );\n\n      _increaseTotalLP(senderLpFee.add(recipientLpFee));\n    }\n\n    // emits events\n\n    {\n      _emitTransfer(\n        sender,\n        recipient,\n        amount\n      );\n\n      _emitTransfer(\n        sender,\n        address(0),\n        senderBurnFee\n      );\n\n      _emitTransfer(\n        sender,\n        address(lpm),\n        senderLpFee\n      );\n\n      _emitTransfer(\n        recipient,\n        address(0),\n        recipientBurnFee\n      );\n\n      _emitTransfer(\n        recipient,\n        address(lpm),\n        recipientLpFee\n      );\n\n      _updateTotalRewards();\n\n      _syncLP();\n    }\n  }\n\n  function _transferFromExcludedAccount(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      accountBalances[sender] >= amount,\n      \"MetaheroToken#23\" // amount exceeds sender balance\n    );\n\n    (\n      bool shouldSyncLPBefore,\n      bool shouldSyncLPAfter\n    ) = _canSyncLP(\n      sender,\n      address(0)\n    );\n\n    if (shouldSyncLPBefore) {\n      lpm.syncLP();\n    }\n\n    uint256 recipientTotalFee;\n    uint256 recipientBurnFee;\n    uint256 recipientLPFee;\n\n    uint256 totalSupply_ = summary.totalSupply;\n\n    // when sender does not remove the fee from the recipient\n    if (!excludedAccounts[sender].excludeRecipientFromFee) {\n      (\n        recipientTotalFee,\n        recipientBurnFee,\n        recipientLPFee\n      ) = _calcTransferRecipientFees(amount);\n\n      (\n        totalSupply_,\n        recipientTotalFee,\n        recipientBurnFee\n      ) = _matchTotalSupplyWithFees(totalSupply_, recipientTotalFee, recipientBurnFee);\n    }\n\n    uint256 recipientAmount = amount.sub(recipientTotalFee);\n\n    summary.totalSupply = totalSupply_;\n    summary.totalExcluded = summary.totalExcluded.sub(amount);\n\n    accountBalances[sender] = accountBalances[sender].sub(amount);\n\n    _updateHoldingBalance(\n      recipient,\n      accountBalances[recipient].add(recipientAmount),\n      summary.totalHolding.add(recipientAmount)\n    );\n\n    _increaseTotalLP(recipientLPFee);\n\n    // emits events\n\n    _emitTransfer(\n      sender,\n      recipient,\n      amount\n    );\n\n    _emitTransfer(\n      recipient,\n      address(0),\n      recipientBurnFee\n    );\n\n    _emitTransfer(\n      recipient,\n      address(lpm),\n      recipientLPFee\n    );\n\n    _updateTotalRewards();\n\n    if (shouldSyncLPAfter) {\n      lpm.syncLP();\n    }\n  }\n\n  function _transferToExcludedAccount(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    (\n      bool shouldSyncLPBefore,\n      bool shouldSyncLPAfter\n    ) = _canSyncLP(\n      address(0),\n      recipient\n    );\n\n    if (shouldSyncLPBefore) {\n      lpm.syncLP();\n    }\n\n    uint256 senderTotalFee;\n    uint256 senderBurnFee;\n    uint256 senderLpFee;\n\n    uint256 totalSupply_ = summary.totalSupply;\n\n    // when recipient does not remove the fee from the sender\n    if (!excludedAccounts[recipient].excludeSenderFromFee) {\n      (\n        senderTotalFee,\n        senderBurnFee,\n        senderLpFee\n      ) = _calcTransferSenderFees(amount);\n\n      (\n        totalSupply_,\n        senderTotalFee,\n        senderBurnFee\n      ) = _matchTotalSupplyWithFees(totalSupply_, senderTotalFee, senderBurnFee);\n    }\n\n    uint256 senderAmount = amount.add(senderTotalFee);\n\n    // append total rewards\n    if (summary.totalRewards != 0) {\n      uint256 totalHoldingWithRewards = summary.totalHolding.add(\n        summary.totalRewards\n      );\n\n      senderAmount = senderAmount.mul(summary.totalHolding).div(\n        totalHoldingWithRewards\n      );\n    }\n\n    require(\n      accountBalances[sender] >= senderAmount,\n      \"MetaheroToken#24\" // amount exceeds sender balance\n    );\n\n    summary.totalSupply = totalSupply_;\n    summary.totalExcluded = summary.totalExcluded.add(amount);\n\n    accountBalances[recipient] = accountBalances[recipient].add(amount);\n\n    _updateHoldingBalance(\n      sender,\n      accountBalances[sender].sub(senderAmount),\n      summary.totalHolding.sub(senderAmount)\n    );\n\n    _increaseTotalLP(senderLpFee);\n\n    // emits events\n\n    _emitTransfer(\n      sender,\n      recipient,\n      amount\n    );\n\n    _emitTransfer(\n      sender,\n      address(0),\n      senderBurnFee\n    );\n\n    _emitTransfer(\n      sender,\n      address(lpm),\n      senderLpFee\n    );\n\n    _updateTotalRewards();\n\n    if (shouldSyncLPAfter) {\n      lpm.syncLP();\n    }\n  }\n\n  function _transferBetweenExcludedAccounts(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      accountBalances[sender] >= amount,\n      \"MetaheroToken#25\" // amount exceeds sender balance\n    );\n\n    (\n      bool shouldSyncLPBefore,\n      bool shouldSyncLPAfter\n    ) = _canSyncLP(\n      address(0),\n      recipient\n    );\n\n    if (shouldSyncLPBefore) {\n      lpm.syncLP();\n    }\n\n    accountBalances[sender] = accountBalances[sender].sub(amount);\n    accountBalances[recipient] = accountBalances[recipient].add(amount);\n\n    _emitTransfer(\n      sender,\n      recipient,\n      amount\n    );\n\n    if (shouldSyncLPAfter) {\n      lpm.syncLP();\n    }\n  }\n\n  function _updateHoldingBalance(\n    address holder,\n    uint256 holderBalance,\n    uint256 totalHolding\n  )\n    private\n  {\n    accountBalances[holder] = holderBalance;\n    summary.totalHolding = totalHolding;\n\n    if (address(dao) != address(0)) { // if dao is not the zero address\n      dao.syncMember(\n        holder,\n        holderBalance,\n        totalHolding\n      );\n    }\n  }\n\n  function _updateHoldingBalances(\n    address holderA,\n    uint256 holderABalance,\n    address holderB,\n    uint256 holderBBalance,\n    uint256 totalHolding\n  )\n    private\n  {\n    accountBalances[holderA] = holderABalance;\n    accountBalances[holderB] = holderBBalance;\n    summary.totalHolding = totalHolding;\n\n    if (address(dao) != address(0)) { // if dao is not the zero address\n      dao.syncMembers(\n        holderA,\n        holderABalance,\n        holderB,\n        holderBBalance,\n        totalHolding\n      );\n    }\n  }\n\n  function _emitTransfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    if (amount != 0) { // when amount is not zero\n      emit Transfer(\n        sender,\n        recipient,\n        amount\n      );\n    }\n  }\n\n  function _increaseTotalLP(\n    uint256 amount\n  )\n    private\n  {\n    if (amount != 0) { // when amount is not zero\n      accountBalances[address(lpm)] = accountBalances[address(lpm)].add(amount);\n\n      summary.totalExcluded = summary.totalExcluded.add(amount);\n    }\n  }\n\n  function _syncLP()\n    private\n  {\n    if (address(lpm) != address(0)) { // if lpm is not the zero address\n      lpm.syncLP();\n    }\n  }\n\n  function _updateTotalRewards()\n    private\n  {\n    // totalRewards = totalSupply - totalExcluded - totalHolding\n    uint256 totalRewards = summary.totalSupply\n    .sub(summary.totalExcluded)\n    .sub(summary.totalHolding);\n\n    if (totalRewards != summary.totalRewards) {\n      summary.totalRewards = totalRewards;\n\n      emit TotalRewardsUpdated(\n        totalRewards\n      );\n    }\n  }\n\n  // private functions (views)\n\n  function _matchTotalSupplyWithFees(\n    uint256 totalSupply_,\n    uint256 totalFee,\n    uint256 burnFee\n  )\n    private\n    view\n    returns (uint256, uint256, uint256)\n  {\n    if (burnFee != 0) {\n      uint256 newTotalSupply = totalSupply_.sub(burnFee);\n\n      if (newTotalSupply >= settings.minTotalSupply) {\n        totalSupply_ = newTotalSupply;\n      } else  { // turn of burn fee\n        totalFee = totalFee.sub(burnFee);\n        burnFee = 0;\n      }\n    }\n\n    return (totalSupply_, totalFee, burnFee);\n  }\n\n\n  function _canSyncLP(\n    address sender,\n    address recipient\n  )\n    private\n    view\n    returns (\n      bool shouldSyncLPBefore,\n      bool shouldSyncLPAfter\n    )\n  {\n    if (address(lpm) != address(0)) { // if lpm is not the zero address\n      (shouldSyncLPBefore, shouldSyncLPAfter) = lpm.canSyncLP(\n        sender,\n        recipient\n      );\n    }\n\n    return (shouldSyncLPBefore, shouldSyncLPAfter);\n  }\n\n  function _calcRewards(\n    address account\n  )\n    private\n    view\n    returns (uint256 result)\n  {\n    if (\n      !excludedAccounts[account].exists && // only for holders\n      summary.totalRewards != 0\n    ) {\n      result = summary.totalRewards\n        .mul(accountBalances[account])\n        .div(summary.totalHolding);\n    }\n\n    return result;\n  }\n\n  function _calcTransferSenderFees(\n    uint256 amount\n  )\n    private\n    view\n    returns (\n      uint256 totalFee,\n      uint256 burnFee,\n      uint256 lpFee\n    )\n  {\n    uint256 rewardsFee = amount.percent(settings.rewardsFees.sender);\n\n    lpFee = amount.percent(settings.lpFees.sender);\n    burnFee = amount.percent(settings.burnFees.sender);\n\n    totalFee = lpFee.add(rewardsFee).add(burnFee);\n\n    return (totalFee, burnFee, lpFee);\n  }\n\n  function _calcTransferRecipientFees(\n    uint256 amount\n  )\n    private\n    view\n    returns (\n      uint256 totalFee,\n      uint256 burnFee,\n      uint256 lpFee\n    )\n  {\n    uint256 rewardsFee = amount.percent(settings.rewardsFees.recipient);\n\n    lpFee = amount.percent(settings.lpFees.recipient);\n    burnFee = amount.percent(settings.burnFees.recipient);\n\n    totalFee = lpFee.add(rewardsFee).add(burnFee);\n\n    return (totalFee, burnFee, lpFee);\n  }\n\n  // private functions (pure)\n\n  function _verifyFees(\n    Fees memory burnFees,\n    Fees memory lpFees,\n    Fees memory rewardsFees\n  )\n    private\n    pure\n  {\n    uint256 totalFee = burnFees.sender.add(\n      burnFees.recipient\n    ).add(\n      lpFees.sender.add(lpFees.recipient)\n    ).add(\n      rewardsFees.sender.add(rewardsFees.recipient)\n    );\n\n    require(\n      totalFee <= MAX_FEE,\n      \"MetaheroToken#26\" // the total fee is too high\n    );\n  }\n}\n"
    },
    "src/core/access/Owned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Owned\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract Owned {\n  /**\n   * @return owner address\n   */\n  address public owner;\n\n  // modifiers\n\n  /**\n   * @dev Throws if msg.sender is not the owner\n   */\n  modifier onlyOwner() {\n    require(\n      msg.sender == owner,\n      \"Owned#1\" // msg.sender is not the owner\n    );\n\n    _;\n  }\n\n  // events\n\n  /**\n   * @dev Emitted when the owner is updated\n   * @param owner new owner address\n   */\n  event OwnerUpdated(\n    address owner\n  );\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor()\n    internal\n  {\n    owner = msg.sender;\n  }\n\n  // external functions\n\n  /**\n   * @notice Sets a new owner\n   * @param owner_ owner address\n   */\n  function setOwner(\n    address owner_\n  )\n    external\n    onlyOwner\n  {\n    _setOwner(owner_);\n  }\n\n  // internal functions\n\n  function _setOwner(\n    address owner_\n  )\n    internal\n  {\n    require(\n      owner_ != address(0),\n      \"Owned#2\" // owner is the zero address\n    );\n\n    require(\n      owner_ != owner,\n      \"Owned#3\" // does not update the owner\n    );\n\n    owner = owner_;\n\n    emit OwnerUpdated(\n      owner_\n    );\n  }\n}\n"
    },
    "src/core/erc20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./IERC20.sol\";\n\n\n/**\n * @title ERC20 abstract token\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\nabstract contract ERC20 is IERC20 {\n  string public override name;\n  string public override symbol;\n  uint8 public override decimals;\n\n  /**\n   * @dev Internal constructor\n   * @param name_ name\n   * @param symbol_ symbol\n   * @param decimals_ decimals amount\n   */\n  constructor (\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  )\n    internal\n  {\n    name = name_;\n    symbol = symbol_;\n    decimals = decimals_;\n  }\n}\n"
    },
    "src/core/lifecycle/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Initializable\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract Initializable {\n  address private initializer;\n\n  // modifiers\n\n  /**\n   * @dev Throws if msg.sender is not the initializer\n   */\n  modifier onlyInitializer() {\n    require(\n      initializer != address(0),\n      \"Initializable#1\" // already initialized\n    );\n\n    require(\n      msg.sender == initializer,\n      \"Initializable#2\" // msg.sender is not the initializer\n    );\n\n    /// @dev removes initializer\n    initializer = address(0);\n\n    _;\n  }\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor()\n    internal\n  {\n    initializer = msg.sender;\n  }\n\n  // external functions (views)\n\n  /**\n   * @notice Checks if contract is initialized\n   * @return true when contract is initialized\n   */\n  function initialized()\n    external\n    view\n    returns (bool)\n  {\n    return initializer == address(0);\n  }\n}\n"
    },
    "src/core/math/MathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./SafeMathLib.sol\";\n\n\n/**\n * @title Math library\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\nlibrary MathLib {\n  using SafeMathLib for uint256;\n\n  // internal functions (pure)\n\n  /**\n   * @notice Calcs a x p / 100\n   */\n  function percent(\n    uint256 a,\n    uint256 p\n  )\n    internal\n    pure\n    returns (uint256 result)\n  {\n    if (a != 0 && p != 0) {\n      result = a.mul(p).div(100);\n    }\n\n    return result;\n  }\n}\n"
    },
    "src/core/math/SafeMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Safe math library\n *\n * @notice Based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5fe8f4e93bd1d4f5cc9a6899d7f24f5ffe4c14aa/contracts/math/SafeMath.sol\n */\nlibrary SafeMathLib {\n  // internal functions (pure)\n\n  /**\n   * @notice Calcs a + b\n   */\n  function add(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    uint256 c = a + b;\n\n    require(\n      c >= a,\n      \"SafeMathLib#1\"\n    );\n\n    return c;\n  }\n\n  /**\n   * @notice Calcs a - b\n   */\n  function sub(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    require(\n      b <= a,\n      \"SafeMathLib#2\"\n    );\n\n    return a - b;\n  }\n\n  /**\n   * @notice Calcs a x b\n   */\n  function mul(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256 result)\n  {\n    if (a != 0 && b != 0) {\n      result = a * b;\n\n      require(\n        result / a == b,\n        \"SafeMathLib#3\"\n      );\n    }\n\n    return result;\n  }\n\n  /**\n   * @notice Calcs a / b\n   */\n  function div(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    require(\n      b != 0,\n      \"SafeMathLib#4\"\n    );\n\n    return a / b;\n  }\n}\n"
    },
    "src/IMetaheroDAO.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Metahero DAO interface\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ninterface IMetaheroDAO {\n  // external functions\n\n  /**\n   * @notice Called by a token to sync a dao member\n   * @param member member address\n   * @param memberWeight member weight\n   * @param totalWeight all members weight\n   */\n  function syncMember(\n    address member,\n    uint256 memberWeight,\n    uint256 totalWeight\n  )\n    external;\n\n  /**\n   * @notice Called by a token to sync a dao members\n   * @param memberA member A address\n   * @param memberAWeight member A weight\n   * @param memberB member B address\n   * @param memberBWeight member B weight\n   * @param totalWeight all members weight\n   */\n  function syncMembers(\n    address memberA,\n    uint256 memberAWeight,\n    address memberB,\n    uint256 memberBWeight,\n    uint256 totalWeight\n  )\n    external;\n}\n"
    },
    "src/MetaheroLPM.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./core/access/Lockable.sol\";\nimport \"./core/access/Owned.sol\";\nimport \"./core/lifecycle/Initializable.sol\";\nimport \"./core/math/SafeMathLib.sol\";\nimport \"./MetaheroToken.sol\";\n\n\n/**\n * @title Metahero abstract liquidity pool manager\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\nabstract contract MetaheroLPM is Lockable, Owned, Initializable {\n  using SafeMathLib for uint256;\n\n  /**\n   * @return token address\n   */\n  MetaheroToken public token;\n\n  // modifiers\n\n  /**\n   * @dev Throws if msg.sender is not the token\n   */\n  modifier onlyToken() {\n    require(\n      msg.sender == address(token),\n      \"MetaheroLPM#1\" // msg.sender is not the token\n    );\n\n    _;\n  }\n\n  // events\n\n  /**\n   * @dev Emitted when tokens from the liquidity pool are burned\n   * @param amount burnt amount\n   */\n  event LPBurnt(\n    uint256 amount\n  );\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor ()\n    internal\n    Lockable()\n    Owned()\n    Initializable()\n  {\n    //\n  }\n\n  // external functions\n\n  /**\n   * @notice Syncs liquidity pool\n   */\n  function syncLP()\n    external\n    onlyToken\n    lock\n  {\n    _syncLP();\n  }\n\n  /**\n   * @notice Burns tokens from the liquidity pool\n   * @param amount tokens amount\n   */\n  function burnLP(\n    uint256 amount\n  )\n    external\n    onlyOwner\n    lockOrThrowError\n  {\n    require(\n      amount != 0,\n      \"MetaheroLPM#2\" // amount is zero\n    );\n\n    _burnLP(amount);\n\n    emit LPBurnt(\n      amount\n    );\n  }\n\n  // external functions (views)\n\n  function canSyncLP(\n    address sender,\n    address recipient\n  )\n    external\n    view\n    virtual\n    returns (\n      bool shouldSyncLPBefore,\n      bool shouldSyncLPAfter\n    );\n\n  // internal functions\n\n  function _initialize(\n    address token_\n  )\n    internal\n  {\n    require(\n      token_ != address(0),\n      \"MetaheroLPM#3\" // token is the zero address\n    );\n\n    token = MetaheroToken(token_);\n  }\n\n  function _syncLP()\n    internal\n    virtual;\n\n  function _burnLP(\n    uint256 amount\n  )\n    internal\n    virtual;\n}\n"
    },
    "src/core/erc20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title ERC20 token interface\n *\n * @notice See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n */\ninterface IERC20 {\n  // events\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  // external functions\n\n  function approve(\n    address spender,\n    uint256 value\n  )\n    external\n    returns (bool);\n\n  function transfer(\n    address to,\n    uint256 value\n  )\n    external\n    returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  )\n    external\n    returns (bool);\n\n  // external functions (views)\n\n  function totalSupply()\n    external\n    view\n    returns (uint256);\n\n  function balanceOf(\n    address owner\n  )\n    external\n    view\n    returns (uint256);\n\n  function allowance(\n    address owner,\n    address spender\n  )\n    external\n    view\n    returns (uint256);\n\n  // external functions (pure)\n\n  function name()\n    external\n    pure\n    returns (string memory);\n\n  function symbol()\n    external\n    pure\n    returns (string memory);\n\n  function decimals()\n    external\n    pure\n    returns (uint8);\n}\n"
    },
    "src/core/access/Lockable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Lockable\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract Lockable {\n  /**\n   * @return true when contract is locked\n   */\n  bool public locked;\n\n  // modifiers\n\n\n  /**\n   * @dev Calls only when contract is unlocked\n   */\n  modifier lock() {\n    if (!locked) {\n      locked = true;\n\n      _;\n\n      locked = false;\n    }\n  }\n\n  /**\n   * @dev Throws if contract is locked\n   */\n  modifier lockOrThrowError() {\n    require(\n      !locked,\n      \"Lockable#1\" // contract is locked\n    );\n\n    locked = true;\n\n    _;\n\n    locked = false;\n  }\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor()\n    internal\n  {\n    //\n  }\n}\n"
    },
    "src/MetaheroTimeLockWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./core/lifecycle/Initializable.sol\";\nimport \"./core/math/SafeMathLib.sol\";\nimport \"./MetaheroToken.sol\";\n\n\n/**\n * @title Metahero time lock wallet\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract MetaheroTimeLockWallet {\n  bytes4 private constant ERC20_TRANSFER_SELECTOR = 0xa9059cbb; // bytes4(keccak256(bytes('transfer(address,uint256)')));\n\n  /**\n   * @return token address\n   */\n  address public token;\n\n  /**\n   * @return registry address\n   */\n  address public registry;\n\n  /**\n   * @dev Public constructor\n   * @param token_ token address\n   */\n  constructor (\n    address token_\n  )\n    public\n  {\n    token = token_;\n    registry = msg.sender;\n  }\n\n  // external functions\n\n  /**\n   * @dev Transfers tokens\n   * @param recipient recipient address\n   * @param amount tokens amount\n   */\n  function transferTokens(\n    address recipient,\n    uint256 amount\n  )\n    external\n  {\n    require(\n      msg.sender == registry,\n      \"MetaheroTimeLockWallet#1\" // msg.sender is not the registry\n    );\n\n    (bool success, bytes memory response) = address(token).call( // solhint-disable-line avoid-low-level-calls\n      abi.encodeWithSelector(ERC20_TRANSFER_SELECTOR, recipient, amount)\n    );\n\n    require(\n      success && (\n        response.length == 0 ||\n        abi.decode(response, (bool))\n      ),\n      \"MetaheroTimeLockWallet#2\" // transfer failed\n    );\n  }\n}\n"
    },
    "src/MetaheroTimeLockRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./core/lifecycle/Initializable.sol\";\nimport \"./core/math/SafeMathLib.sol\";\nimport \"./MetaheroTimeLockWallet.sol\";\nimport \"./MetaheroToken.sol\";\n\n\n/**\n * @title Metahero time lock registry\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract MetaheroTimeLockRegistry is Initializable {\n  using SafeMathLib for uint256;\n\n  struct TimeLock {\n    address spender;\n    uint256 amount;\n    uint256 deadline;\n  }\n\n  /**\n   * @return token address\n   */\n  MetaheroToken public token;\n\n  mapping (address => address) private claimerWallets;\n  mapping (address => TimeLock[]) private claimerTimeLocks;\n\n  // events\n\n  /**\n   * @dev Emitted when the contract is initialized\n   * @param token token address\n   */\n  event Initialized(\n    address token\n  );\n\n  /**\n   * @dev Emitted when the claimer wallet is created\n   * @param claimer claimer address\n   * @param claimerWallet claimer wallet address\n   */\n  event ClaimerWalletCreated(\n    address indexed claimer,\n    address claimerWallet\n  );\n\n  /**\n   * @dev Emitted when tokens are locked\n   * @param spender spender address\n   * @param claimer claimer address\n   * @param claimerWallet claimer wallet address\n   * @param amount tokens amount\n   * @param deadline deadline in seconds\n   */\n  event TokensLocked(\n    address indexed spender,\n    address indexed claimer,\n    address claimerWallet,\n    uint256 amount,\n    uint256 deadline\n  );\n\n  /**\n   * @dev Emitted when tokens are unlocked\n   * @param spender spender address\n   * @param claimer claimer address\n   * @param claimerWallet claimer wallet address\n   * @param recipient recipient address\n   * @param amount tokens amount\n   * @param deadline deadline in seconds\n   */\n  event TokensUnlocked(\n    address indexed spender,\n    address indexed claimer,\n    address claimerWallet,\n    address recipient,\n    uint256 amount,\n    uint256 deadline\n  );\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    Initializable()\n  {\n    //\n  }\n\n  // external functions\n\n  /**\n   * @dev Initializes the contract\n   * @param token_ token address\n   */\n  function initialize(\n    address token_\n  )\n    external\n    onlyInitializer\n  {\n    require(\n      token_ != address(0),\n      \"MetaheroTimeLockRegistry#1\" // token is the zero address\n    );\n\n    token = MetaheroToken(token_);\n\n    emit Initialized(\n      token_\n    );\n  }\n\n  /**\n   * @dev Creates claimer wallet\n   * @param claimer claimer address\n   */\n  function createClaimerWallet(\n    address claimer\n  )\n    external\n  {\n    require(\n      claimer != address(0),\n      \"MetaheroTimeLockRegistry#2\" // claimer is the zero address\n    );\n\n    require(\n      claimerWallets[claimer] == address(0),\n      \"MetaheroTimeLockRegistry#3\" // claimer wallet already created\n    );\n\n    _createClaimerWallet(claimer);\n  }\n\n  /**\n   * @dev Locks tokens to claimer\n   * @param claimer claimer address\n   * @param amount tokens amount\n   * @param unlockedIn seconds to unlock\n   */\n  function lockTokensTo(\n    address claimer,\n    uint256 amount,\n    uint256 unlockedIn\n  )\n    external\n  {\n    _lockTokens(\n      msg.sender,\n      claimer,\n      amount,\n      unlockedIn\n    );\n  }\n\n  /**\n   * @dev Locks own tokens\n   * @param amount tokens amount\n   * @param unlockedIn seconds to unlock\n   */\n  function lockTokens(\n    uint256 amount,\n    uint256 unlockedIn\n  )\n    external\n  {\n    _lockTokens(\n      msg.sender,\n      msg.sender,\n      amount,\n      unlockedIn\n    );\n  }\n\n  /**\n   * @dev Claims tokens\n   */\n  function claimTokens()\n    external\n  {\n    _claimTokens(\n      msg.sender,\n      msg.sender\n    );\n  }\n\n  /**\n   * @dev Claims tokens to recipient\n   * @param recipient recipient address\n   */\n  function claimTokensTo(\n    address recipient\n  )\n    external\n  {\n    _claimTokens(\n      msg.sender,\n      recipient\n    );\n  }\n\n  // external functions (views)\n\n  /**\n   * @dev Computes claimer wallet\n   * @param claimer claimer address\n   * @return result claimer wallet address\n   */\n  function computeClaimerWallet(\n    address claimer\n  )\n    external\n    view\n    returns (address result)\n  {\n    if (claimer != address(0)) {\n      if (claimerWallets[claimer] != address(0)) {\n        result = claimerWallets[claimer];\n      } else {\n        bytes32 salt = keccak256(abi.encodePacked(claimer));\n\n        bytes memory creationCode = abi.encodePacked(\n          type(MetaheroTimeLockWallet).creationCode,\n          bytes12(0),\n          address(token)\n        );\n\n        bytes32 hash = keccak256(\n          abi.encodePacked(\n            bytes1(0xff),\n            address(this),\n            salt,\n            keccak256(creationCode)\n          )\n        );\n\n        return address(uint160(uint256(hash)));\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * @dev Gets claimer time locks\n   * @param claimer claimer address\n   * @return array of time locks\n   */\n  function getClaimerTimeLocks(\n    address claimer\n  )\n    external\n    view\n    returns (TimeLock[] memory)\n  {\n    return claimerTimeLocks[claimer];\n  }\n\n  // private functions\n\n  function _createClaimerWallet(\n    address claimer\n  )\n    private\n  {\n    bytes32 salt = keccak256(abi.encodePacked(claimer));\n\n    address claimerWallet = address(new MetaheroTimeLockWallet{salt: salt}(\n        address(token)\n      ));\n\n    claimerWallets[claimer] = claimerWallet;\n\n    emit ClaimerWalletCreated(\n      claimer,\n      claimerWallet\n    );\n  }\n\n  function _lockTokens(\n    address spender,\n    address claimer,\n    uint256 amount,\n    uint256 unlockedIn\n  )\n    private\n  {\n    require(\n      claimer != address(0),\n      \"MetaheroTimeLockRegistry#4\" // claimer is the zero address\n    );\n\n    require(\n      amount != 0,\n      \"MetaheroTimeLockRegistry#5\" // amount is zero\n    );\n\n    // create claimer wallet if not created yet\n    if (claimerWallets[claimer] == address(0)) {\n      _createClaimerWallet(claimer);\n    }\n\n    uint256 deadline = block.timestamp.add(unlockedIn); // solhint-disable-line not-rely-on-time\n\n    address claimerWallet = claimerWallets[claimer];\n\n    bool excluded;\n\n    if (spender != claimer) {\n      (excluded,,) = token.getExcludedAccount(spender);\n\n      require(\n        excluded,\n        \"MetaheroTimeLockRegistry#6\" // spender is not the excluded account\n      );\n    }\n\n    (excluded,,) = token.getExcludedAccount(claimer);\n\n    require(\n      excluded,\n      \"MetaheroTimeLockRegistry#7\" // claimer is not the excluded account\n    );\n\n    (excluded,,) = token.getExcludedAccount(claimerWallet);\n\n    require(\n      excluded,\n      \"MetaheroTimeLockRegistry#8\" // claimer wallet is not the excluded account\n    );\n\n    token.transferFrom(\n      spender,\n      claimerWallet,\n      amount\n    );\n\n    TimeLock memory timeLock;\n\n    timeLock.spender = spender;\n    timeLock.amount = amount;\n    timeLock.deadline = deadline;\n\n    claimerTimeLocks[claimer].push(timeLock);\n\n    emit TokensLocked(\n      spender,\n      claimer,\n      claimerWallet,\n      amount,\n      deadline\n    );\n  }\n\n  function _claimTokens(\n    address claimer,\n    address recipient\n  )\n    private\n  {\n    require(\n      claimerWallets[claimer] != address(0),\n      \"MetaheroTimeLockRegistry#9\" // claimer wallet doesn't exist\n    );\n\n    require(\n      recipient != address(0),\n      \"MetaheroTimeLockRegistry#10\" // claimer is the zero address\n    );\n\n    if (recipient != claimer) {\n      (bool excluded,,) = token.getExcludedAccount(recipient);\n\n      require(\n        excluded,\n        \"MetaheroTimeLockRegistry#11\" // recipient is not the excluded account\n      );\n    }\n\n    uint256 amount;\n    uint256 len = claimerTimeLocks[claimer].length;\n\n    if (len != 0) {\n      uint256 lastIndex = len - 1;\n\n      TimeLock memory timeLock;\n\n      for (uint256 index; index <= lastIndex; ) {\n        timeLock = claimerTimeLocks[claimer][index];\n\n        if (timeLock.deadline <= block.timestamp) { // solhint-disable-line not-rely-on-time\n          if (index != lastIndex) {\n            claimerTimeLocks[claimer][index] = claimerTimeLocks[claimer][lastIndex];\n            lastIndex--;\n          } else {\n            index++;\n          }\n\n          amount = amount.add(timeLock.amount);\n\n          emit TokensUnlocked(\n            timeLock.spender,\n            claimer,\n            claimerWallets[claimer],\n            recipient,\n            timeLock.amount,\n            timeLock.deadline\n          );\n\n          claimerTimeLocks[claimer].pop();\n        } else {\n          index++;\n        }\n      }\n    }\n\n    require(\n      amount != 0,\n      \"MetaheroTimeLockRegistry#12\" // amount is zero\n    );\n\n    MetaheroTimeLockWallet(claimerWallets[claimer]).transferTokens(recipient, amount);\n  }\n}\n"
    },
    "src/MetaheroPresale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./core/access/Owned.sol\";\nimport \"./core/lifecycle/Initializable.sol\";\nimport \"./core/math/SafeMathLib.sol\";\nimport \"./MetaheroToken.sol\";\n\n\n/**\n * @title Metahero presale\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract MetaheroPresale is Owned, Initializable {\n  using SafeMathLib for uint256;\n\n  struct Settings {\n    uint256 tokensAmountPerNative;\n    uint256 minPurchasePrice; // min purchase price per whitelisted account\n    uint256 maxPurchasePrice; // max purchase price per whitelisted account\n  }\n\n  struct Summary {\n    uint256 totalAccounts; // total accounts in presale\n    uint256 totalTokens; // total tokens in presale\n  }\n\n  /**\n   * @return token address\n   */\n  MetaheroToken public token;\n\n  /**\n   * @return settings object\n   */\n  Settings public settings;\n\n  /**\n   * @return summary object\n   */\n  Summary public summary;\n\n  /**\n   * @return true when presale started\n   */\n  bool public started;\n\n  /**\n   * @return map with whitelisted accounts\n   */\n  mapping (address => bool) public whitelist;\n\n  // events\n\n  /**\n   * @dev Emitted the contract is initialized\n   * @param token token address\n   * @param tokensAmountPerNative tokens amount per native\n   * @param minPurchasePrice min purchase price in native\n   * @param maxPurchasePrice max purchase price in native\n   */\n  event Initialized(\n    address token,\n    uint256 tokensAmountPerNative,\n    uint256 minPurchasePrice,\n    uint256 maxPurchasePrice\n  );\n\n  /**\n   * @dev Emitted after the presale starts\n   */\n  event PresaleStarted();\n\n  /**\n   * @dev Emitted after purchasing tokens\n   * @param account account address\n   * @param tokensPrice tokens price\n   * @param tokensAmount tokens amount\n   */\n  event TokensPurchased(\n    address indexed account,\n    uint256 tokensPrice,\n    uint256 tokensAmount\n  );\n\n  /**\n   * @dev Emitted after account is added to the whitelist\n   * @param account account address\n   */\n  event AccountAdded(\n    address indexed account\n  );\n\n  /**\n   * @dev Emitted after account is removed from the whitelist\n   * @param account account address\n   */\n  event AccountRemoved(\n    address indexed account\n  );\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    Owned()\n    Initializable()\n  {\n    //\n  }\n\n  // external functions\n\n  /**\n   * @dev Alias for buyTokens\n   */\n  receive()\n    external\n    payable\n  {\n    _buyTokens(\n      msg.sender,\n      msg.value\n    );\n  }\n\n  /**\n   * @dev Starts the process of buying tokens\n   */\n  function buyTokens()\n    external\n    payable\n  {\n    _buyTokens(\n      msg.sender,\n      msg.value\n    );\n  }\n\n  /**\n   * @dev Initializes the contract\n   * @param token_ token address\n   * @param tokensAmountPerNative tokens amount per native\n   * @param minPurchasePrice min purchase price\n   * @param maxPurchasePrice max purchase price\n   */\n  function initialize(\n    address payable token_,\n    uint256 tokensAmountPerNative,\n    uint256 minPurchasePrice,\n    uint256 maxPurchasePrice\n  )\n    external\n    onlyInitializer\n  {\n    require(\n      token_ != address(0),\n      \"MetaheroPresale#7\" // token is the zero address\n    );\n\n    require(\n      tokensAmountPerNative != 0,\n      \"MetaheroPresale#8\" // tokens amount per native is zero\n    );\n\n    require(\n      minPurchasePrice <= maxPurchasePrice,\n      \"MetaheroPresale#9\" // max purchase price is lower than min\n    );\n\n    require(\n      maxPurchasePrice != 0,\n      \"MetaheroPresale#10\" // max purchase price is zero\n    );\n\n    token = MetaheroToken(token_);\n\n    settings.tokensAmountPerNative = tokensAmountPerNative;\n    settings.minPurchasePrice = minPurchasePrice;\n    settings.maxPurchasePrice = maxPurchasePrice;\n\n    // sync balance\n    summary.totalTokens = token.balanceOf(address(this));\n\n    emit Initialized(\n      token_,\n      tokensAmountPerNative,\n      minPurchasePrice,\n      maxPurchasePrice\n    );\n  }\n\n  /**\n   * @dev Starts the presale\n   */\n  function startPresale()\n    external\n    onlyOwner\n  {\n    require(\n      !started,\n      \"MetaheroPresale#11\" // presale already started\n    );\n\n    started = true;\n\n    emit PresaleStarted();\n  }\n\n  /**\n   * @dev Syncs total tokens\n   */\n  function syncTotalTokens()\n    external\n  {\n    summary.totalTokens = token.balanceOf(address(this));\n  }\n\n  /**\n   * @dev Adds accounts to the whitelist\n   * @param accounts array of accounts addresses\n   */\n  function addAccounts(\n    address[] calldata accounts\n  )\n    external\n    onlyOwner\n  {\n    _addAccounts(accounts);\n  }\n\n  /**\n   * @dev Removes accounts from the whitelist\n   * @param accounts array of accounts addresses\n   */\n  function removeAccounts(\n    address[] calldata accounts\n  )\n    external\n    onlyOwner\n  {\n    uint256 totalRemoved;\n    uint256 accountsLen = accounts.length;\n\n    for (uint256 index ; index < accountsLen ; index++) {\n      require(\n        accounts[index] != address(0),\n        \"MetaheroPresale#12\" // account is the zero address\n      );\n\n      if (whitelist[accounts[index]]) {\n        whitelist[accounts[index]] = false;\n\n        totalRemoved = totalRemoved.add(1);\n\n        emit AccountRemoved(\n          accounts[index]\n        );\n      }\n    }\n\n    require(\n      totalRemoved != 0,\n      \"MetaheroPresale#13\" // no accounts to remove\n    );\n\n    summary.totalAccounts = summary.totalAccounts.sub(totalRemoved);\n  }\n\n  /**\n   * @dev Finishes the presale\n   */\n  function finishPresale()\n    external\n    onlyOwner\n  {\n    uint256 totalTokens = token.balanceOf(address(this));\n\n    if (totalTokens != 0) {\n      // burn all pending presale tokens\n      token.burn(\n        totalTokens\n      );\n    }\n\n    selfdestruct(msg.sender); // destroy and transfer all native to the sender\n  }\n\n  // private functions\n\n  function _addAccounts(\n    address[] memory accounts\n  )\n    private\n  {\n    uint256 totalAdded;\n    uint256 accountsLen = accounts.length;\n\n    for (uint256 index ; index < accountsLen ; index++) {\n      require(\n        accounts[index] != address(0),\n        \"MetaheroPresale#14\" // account is the zero address\n      );\n\n      if (!whitelist[accounts[index]]) {\n        whitelist[accounts[index]] = true;\n\n        totalAdded = totalAdded.add(1);\n\n        emit AccountAdded(\n          accounts[index]\n        );\n      }\n    }\n\n    require(\n      totalAdded != 0,\n      \"MetaheroPresale#15\" // not accounts to add\n    );\n\n    summary.totalAccounts = summary.totalAccounts.add(totalAdded);\n  }\n\n  function _buyTokens(\n    address sender,\n    uint256 tokensPrice\n  )\n    private\n  {\n    require(\n      started,\n      \"MetaheroPresale#1\" // the presale has not started\n    );\n\n    require(\n      whitelist[sender],\n      \"MetaheroPresale#2\" // sender not on the whitelist\n    );\n\n    require(\n      tokensPrice != 0,\n      \"MetaheroPresale#3\" // token prize is zero\n    );\n\n    require(\n      tokensPrice >= settings.minPurchasePrice,\n      \"MetaheroPresale#4\" // token prize is too low\n    );\n\n    require(\n      tokensPrice <= settings.maxPurchasePrice,\n      \"MetaheroPresale#5\" // token prize is too high\n    );\n\n    uint256 tokensAmount = tokensPrice.mul(settings.tokensAmountPerNative);\n\n    require(\n      tokensAmount <= summary.totalTokens,\n      \"MetaheroPresale#6\" // not enough tokens in presale\n    );\n\n    // remove sender from the whitelist\n    whitelist[sender] = false;\n\n    // update summary\n    summary.totalAccounts = summary.totalAccounts.sub(1);\n    summary.totalTokens = summary.totalTokens.sub(tokensAmount);\n\n    token.transfer(\n      sender,\n      tokensAmount\n    );\n\n    emit TokensPurchased(\n      sender,\n      tokensPrice,\n      tokensAmount\n    );\n  }\n}\n"
    },
    "src/MetaheroLPMMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./MetaheroLPM.sol\";\n\n\n/**\n * @title Metahero liquidity pool manager mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract MetaheroLPMMock is MetaheroLPM {\n  bool private shouldSyncLPBefore;\n  bool private shouldSyncLPAfter;\n\n  // events\n\n  event Triggered();\n\n  event LPSynced();\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    MetaheroLPM()\n  {\n    //\n  }\n\n  // external functions\n\n  function triggerOnlyToken()\n    external\n    onlyToken\n  {\n    emit Triggered();\n  }\n\n  function initialize(\n    address token_\n  )\n    external\n  {\n    _initialize(token_);\n  }\n\n  function setLocked(\n    bool locked_\n  )\n    external\n  {\n    locked = locked_;\n  }\n\n  function allowSyncLP(\n    bool shouldSyncLPBefore_,\n    bool shouldSyncLPAfter_\n  )\n    external\n  {\n    shouldSyncLPBefore = shouldSyncLPBefore_;\n    shouldSyncLPAfter = shouldSyncLPAfter_;\n  }\n\n  // external functions (views)\n\n  function canSyncLP(\n    address,\n    address\n  )\n    external\n    view\n    override\n    returns (bool, bool)\n  {\n    return (shouldSyncLPBefore, shouldSyncLPAfter);\n  }\n\n  // internal functions\n\n  function _syncLP()\n    internal\n    override\n  {\n    emit LPSynced();\n  }\n\n  function _burnLP(\n    uint256\n  )\n    internal\n    override\n  {\n    emit Triggered();\n  }\n}\n"
    },
    "src/MetaheroLPMForUniswapV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./core/erc20/IWrappedNative.sol\";\nimport \"./uniswapV2/IUniswapV2Factory.sol\";\nimport \"./uniswapV2/IUniswapV2Pair.sol\";\nimport \"./uniswapV2/IUniswapV2Router02.sol\";\nimport \"./MetaheroLPM.sol\";\n\n\n/**\n * @title Metahero liquidity pool manager for Uniswap v2\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract MetaheroLPMForUniswapV2 is MetaheroLPM {\n  struct Settings {\n    uint256 enableBurnLPAtValue; // value of the tokens that turned on the burnLP method\n    address stableCoin; // stable coin address eg. BUSD, DAI\n  }\n\n  /**\n   * @return settings object\n   */\n  Settings public settings;\n\n  /**\n   * @return Uniswap V2 factory address\n   */\n  IUniswapV2Factory public uniswapFactory;\n\n  /**\n   * @return Uniswap V2 pair address\n   */\n  IUniswapV2Pair public uniswapPair;\n\n  /**\n   * @return Uniswap V2 router02 address\n   */\n  IUniswapV2Router02 public uniswapRouter;\n\n  IWrappedNative private wrappedNative;\n  bool private correctPairOrder;\n\n  // events\n\n  /**\n   * @dev Emitted the contract is initialized\n   * @param enableBurnLPAtValue value of the tokens that turned on the burnLP method\n   * @param stableCoin stable coin address eg. BUSD, DAI\n   * @param token token address\n   * @param uniswapRouter Uniswap V2 router02 address\n   * @param uniswapPair Uniswap V2 pair address\n   */\n  event Initialized(\n    uint256 enableBurnLPAtValue,\n    address stableCoin,\n    address token,\n    address uniswapRouter,\n    address uniswapPair\n  );\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    MetaheroLPM()\n  {\n    //\n  }\n\n  // external functions\n\n  /**\n   * @dev Mints stable coins to the contract\n   */\n  receive()\n    external\n    payable\n  {\n    _deposit(msg.value);\n  }\n\n  /**\n   * @dev Mints stable coins to the contract\n   */\n  function deposit()\n    external\n    payable\n  {\n    _deposit(msg.value);\n  }\n\n  /**\n   * @dev Initializes the contract\n   * @param enableBurnLPAtValue value of the tokens that turned on the burnLP method\n   * @param stableCoin stable coin address eg. BUSD, DAI\n   * @param token_ token address\n   * @param uniswapRouter_ Uniswap V2 router02 address\n   */\n  function initialize(\n    uint256 enableBurnLPAtValue,\n    address stableCoin,\n    address token_,\n    address uniswapRouter_\n  )\n    external\n    onlyInitializer\n  {\n    _initialize(token_);\n\n    if (enableBurnLPAtValue != 0) {\n      require(\n        stableCoin != address(0),\n        \"MetaheroLPMForUniswapV2#2\" // stable coin is the zero address\n      );\n\n      settings.enableBurnLPAtValue = enableBurnLPAtValue;\n      settings.stableCoin = stableCoin;\n    }\n\n    require(\n      uniswapRouter_ != address(0),\n      \"MetaheroLPMForUniswapV2#3\" // Uniswap V2 router02 is the zero address\n    );\n\n    uniswapRouter = IUniswapV2Router02(uniswapRouter_);\n    uniswapFactory = IUniswapV2Factory(uniswapRouter.factory());\n\n    wrappedNative = IWrappedNative(uniswapRouter.WETH());\n\n    // create a pair\n    uniswapPair = IUniswapV2Pair(uniswapFactory.createPair(\n      address(token),\n      address(wrappedNative)\n    ));\n\n    correctPairOrder = address(token) < address(wrappedNative);\n\n    emit Initialized(\n      enableBurnLPAtValue,\n      stableCoin,\n      token_,\n      uniswapRouter_,\n      address(uniswapPair)\n    );\n  }\n\n  // external functions (views)\n\n  /**\n   * @notice Checks when to sync the liquidity pool\n   * @param sender sender address\n   * @param recipient recipient address\n   */\n  function canSyncLP(\n    address sender,\n    address recipient\n  )\n    external\n    view\n    override\n    returns (\n      bool shouldSyncLPBefore,\n      bool shouldSyncLPAfter\n    )\n  {\n    if (sender != address(uniswapPair)) { // omit when swap HERO > BNB\n      if (recipient == address(uniswapPair)) {\n        shouldSyncLPBefore = true; // swap BNB > HERO\n      } else {\n        shouldSyncLPAfter = true;\n      }\n    }\n\n    return (shouldSyncLPBefore, shouldSyncLPAfter);\n  }\n\n  // internal functions\n\n  function _syncLP()\n    internal\n    override\n  {\n    uint256 totalAmount = token.balanceOf(address(this));\n\n    if (totalAmount >= 2) {\n      uint256 swapAmount = totalAmount.div(2);\n      uint256 liquidityAmount = totalAmount.sub(swapAmount);\n\n      // swap half for native\n      _swapTokens(swapAmount);\n\n      // add other half with received native\n      _addTokensToLiquidity(liquidityAmount);\n    }\n  }\n\n  function _burnLP(\n    uint256 amount\n  )\n    internal\n    override\n  {\n    if (settings.enableBurnLPAtValue != 0) {\n      (uint256 tokenReserve, ) = _getLiquidityReserves();\n\n      require(\n        tokenReserve != 0,\n        \"MetaheroLPMForUniswapV2#4\" // token reserve is zero\n      );\n\n      require(\n        amount <= tokenReserve,\n        \"MetaheroLPMForUniswapV2#5\" // amount higher than token reserve\n      );\n\n      uint256 tokenReserveValue = _calcTokensValue(tokenReserve);\n\n      require(\n        tokenReserveValue > settings.enableBurnLPAtValue,\n        \"MetaheroLPMForUniswapV2#6\" // burnLP disabled\n      );\n\n      uint256 amountValue = _calcTokensValue(amount);\n      uint256 maxAmountValue = tokenReserveValue.sub(settings.enableBurnLPAtValue);\n\n      require(\n        amountValue <= maxAmountValue,\n        \"MetaheroLPMForUniswapV2#7\" // amount is too high\n      );\n    }\n\n    // remove liquidity\n    _removeLiquidity();\n\n    uint256 totalAmount = token.balanceOf(address(this));\n\n    require(\n      totalAmount >= amount,\n      \"MetaheroLPMForUniswapV2#8\" // amount is too high\n    );\n\n    token.burn(amount); // burn tokens\n\n    _addTokensToLiquidity( // adds others to liquidity\n      totalAmount.sub(amount)\n    );\n  }\n\n  // private functions\n\n  function _deposit(\n    uint256 amount\n  )\n    private\n  {\n    require(\n      amount != 0,\n      \"MetaheroLPMForUniswapV2#1\" // amount is zero\n    );\n\n    wrappedNative.deposit{value: amount}();\n  }\n\n  function _swapTokens(\n    uint256 amount\n  )\n    private\n  {\n    token.approve(\n      address(uniswapRouter),\n      amount\n    );\n\n    address[] memory path = new address[](2);\n\n    path[0] = address(token);\n    path[1] = address(wrappedNative);\n\n    // omit revert, let's use those tokens on the next swap\n    try uniswapRouter.swapExactTokensForTokens(\n      amount,\n      0,\n      path,\n      address(this),\n      block.timestamp // solhint-disable-line not-rely-on-time\n    ) {\n      //\n    } catch {\n      //\n    }\n  }\n\n  function _addTokensToLiquidity(\n    uint256 tokensAmount\n  )\n    private\n  {\n    uint256 wrappedNativeAmount = wrappedNative.balanceOf(address(this));\n\n    if (\n      tokensAmount != 0 &&\n      wrappedNativeAmount != 0\n    ) {\n      token.approve(\n        address(uniswapRouter),\n        tokensAmount\n      );\n\n      wrappedNative.approve(\n        address(uniswapRouter),\n        wrappedNativeAmount\n      );\n\n      // omit revert, let's use those tokens on the next swap\n      try uniswapRouter.addLiquidity(\n        address(token),\n        address(wrappedNative),\n        tokensAmount,\n        wrappedNativeAmount,\n        0,\n        0,\n        address(this),\n        block.timestamp // solhint-disable-line not-rely-on-time\n      ) {\n        //\n      } catch {\n        //\n      }\n    }\n  }\n\n  function _removeLiquidity()\n    private\n  {\n    uint256 liquidity = uniswapPair.balanceOf(address(this));\n\n    if (liquidity != 0) {\n      uniswapPair.approve(\n        address(uniswapRouter),\n        liquidity\n      );\n\n      uniswapRouter.removeLiquidity(\n        address(token),\n        address(wrappedNative),\n        liquidity,\n        0,\n        0,\n        address(this),\n        block.timestamp // solhint-disable-line not-rely-on-time\n      );\n    }\n  }\n\n  // private functions (views)\n\n  function _calcTokensValue(\n    uint256 amount\n  )\n    private\n    view\n    returns (uint256)\n  {\n    address[] memory path = new address[](3);\n\n    path[0] = address(token);\n    path[1] = address(wrappedNative);\n    path[2] = settings.stableCoin;\n\n    uint256[] memory amounts = uniswapRouter.getAmountsOut(amount, path);\n\n    return amounts[2];\n  }\n\n  function _getLiquidityReserves()\n    private\n    view\n    returns (\n      uint256 tokenReserve,\n      uint256 wrappedNativeReserve\n    )\n  {\n    (\n      uint112 reserve0,\n      uint112 reserve1,\n    ) = uniswapPair.getReserves();\n\n    (tokenReserve, wrappedNativeReserve) = correctPairOrder\n      ? (reserve0, reserve1)\n      : (reserve1, reserve0);\n\n    return (tokenReserve, wrappedNativeReserve);\n  }\n}\n"
    },
    "src/core/erc20/IWrappedNative.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\nimport \"./IERC20.sol\";\n\n\n/**\n * @title Wrapped native (eg. WBNB, WETH) token interface\n *\n * @notice Based on https://github.com/Uniswap/uniswap-v2-periphery/blob/dda62473e2da448bc9cb8f4514dadda4aeede5f4/contracts/interfaces/IWETH.sol\n */\ninterface IWrappedNative is IERC20 {\n  // external functions\n\n  function deposit()\n    external\n    payable;\n\n  function withdraw(\n    uint256 amount\n  )\n    external;\n}\n"
    },
    "src/uniswapV2/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\n/**\n * @title Uniswap v2 factory interface\n *\n * @notice Based on https://github.com/Uniswap/uniswap-v2-core/blob/4dd59067c76dea4a0e8e4bfdda41877a6b16dedc/contracts/interfaces/IUniswapV2Factory.sol\n */\ninterface IUniswapV2Factory {\n  // events\n\n  event PairCreated(\n    address indexed token0,\n    address indexed token1,\n    address pair,\n    uint256\n  );\n\n  // external functions\n\n  function createPair(\n    address tokenA,\n    address tokenB\n  )\n    external\n    returns (address);\n\n  function setFeeTo(\n    address\n  )\n    external;\n\n  function setFeeToSetter(\n    address\n  )\n    external;\n\n  // external functions (views)\n\n  function feeTo()\n    external\n    view\n    returns (address);\n\n  function feeToSetter()\n    external\n    view\n    returns (address);\n\n  function getPair(\n    address tokenA,\n    address tokenB\n  )\n    external\n    view\n    returns (address);\n\n  function allPairs(\n    uint256\n  )\n    external\n    view\n    returns (address);\n\n  function allPairsLength()\n    external\n    view\n    returns (uint256);\n}\n\n"
    },
    "src/uniswapV2/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/* solhint-disable func-name-mixedcase */\npragma solidity ^0.6.12;\n\nimport \"../core/erc20/IERC20.sol\";\n\n\n/**\n * @title Uniswap V2 pair interface\n *\n * @notice Based on https://github.com/Uniswap/uniswap-v2-core/blob/4dd59067c76dea4a0e8e4bfdda41877a6b16dedc/contracts/interfaces/IUniswapV2Pair.sol\n */\ninterface IUniswapV2Pair is IERC20 {\n  // events\n\n  event Mint(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1\n  );\n\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n\n  event Sync(\n    uint112 reserve0,\n    uint112 reserve1\n  );\n\n  // external functions\n\n  function initialize(\n    address,\n    address\n  )\n    external;\n\n  function mint(\n    address to\n  )\n    external\n    returns (uint256);\n\n  function burn(\n    address to\n  )\n    external\n    returns (uint256, uint256);\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  )\n    external;\n\n  function skim(\n    address to\n  )\n    external;\n\n  function sync()\n    external;\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external;\n\n  // external functions (views)\n\n  function DOMAIN_SEPARATOR()\n    external\n    view\n    returns (bytes32);\n\n  function nonces(\n    address owner\n  )\n    external\n    view\n    returns (uint256);\n\n  function factory()\n    external\n    view\n    returns (address);\n\n  function token0()\n    external\n    view\n    returns (address);\n\n  function token1()\n    external\n    view\n    returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (uint112, uint112, uint32);\n\n  function price0CumulativeLast()\n    external\n    view\n    returns (uint256);\n\n  function price1CumulativeLast()\n    external\n    view\n    returns (uint256);\n\n  function kLast()\n    external\n    view\n    returns (uint256);\n\n  // external functions (pure)\n\n  function PERMIT_TYPEHASH()\n    external\n    pure\n    returns (bytes32);\n\n  function MINIMUM_LIQUIDITY()\n    external\n    pure\n    returns (uint256);\n}\n"
    },
    "src/uniswapV2/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\nimport \"./IUniswapV2Router01.sol\";\n\n\n/**\n * @title Uniswap V2 router02 interface\n *\n * @notice Based on https://github.com/Uniswap/uniswap-v2-periphery/blob/dda62473e2da448bc9cb8f4514dadda4aeede5f4/contracts/interfaces/IUniswapV2Router02.sol\n */\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n  // external functions\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable;\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (uint256);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external\n    returns (uint256);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external;\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external;\n}\n"
    },
    "src/uniswapV2/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/* solhint-disable func-name-mixedcase */\npragma solidity ^0.6.12;\n\n/**\n * @title Uniswap V2 router01 interface\n *\n * @notice Based on https://github.com/Uniswap/uniswap-v2-periphery/blob/dda62473e2da448bc9cb8f4514dadda4aeede5f4/contracts/interfaces/IUniswapV2Router01.sol\n */\ninterface IUniswapV2Router01 {\n  // external functions\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable\n    returns (uint256, uint256, uint256);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable\n    returns (uint256[] memory);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (uint256, uint256, uint256);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (uint256, uint256);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (uint256, uint256);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external\n    returns (uint256, uint256);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external\n    returns (uint256, uint256);\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (uint256[] memory);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (uint256[] memory);\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (uint256[] memory);\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (uint256[] memory);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable\n    returns (uint256[] memory);\n\n  // external functions (views)\n\n  function getAmountsOut(\n    uint256 amountIn,\n    address[] calldata path\n  )\n    external\n    view\n    returns (uint256[] memory);\n\n  function getAmountsIn(\n    uint256 amountOut,\n    address[] calldata path\n  )\n    external\n    view\n    returns (uint256[] memory);\n\n  // external functions (pure)\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  )\n    external\n    pure\n    returns (uint256);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  )\n    external\n    pure\n    returns (uint256);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  )\n    external\n    pure\n    returns (uint256);\n\n  function factory()\n    external\n    pure\n    returns (address);\n\n  function WETH()\n    external\n    pure\n    returns (address);\n}\n"
    },
    "src/core/erc20/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"../math/SafeMathLib.sol\";\nimport \"./ERC20.sol\";\n\n\n/**\n * @title ERC20 token mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract ERC20Mock is ERC20 {\n  using SafeMathLib for uint256;\n\n  // metadata\n\n  string private constant TOKEN_NAME = \"ERC20Mock\";\n  string private constant TOKEN_SYMBOL = \"MOCK\";\n  uint8 private constant TOKEN_DECIMALS = 18; // 0.000000000000000000\n\n  uint256 public override totalSupply;\n  mapping(address => uint256) public override balanceOf;\n  mapping(address => mapping(address => uint256)) public override allowance;\n\n  /**\n   * @dev Public constructor\n   */\n  constructor ()\n    public\n    ERC20(TOKEN_NAME, TOKEN_SYMBOL, TOKEN_DECIMALS)\n  {\n    //\n  }\n\n  // external functions\n\n  function setBalance(\n    address account,\n    uint256 balance\n  )\n    external\n  {\n    require(\n      account != address(0),\n      \"ERC20Mock#1\"\n    );\n\n    uint256 diff;\n\n    if (balance > balanceOf[account]) {\n      diff = balance.sub(balanceOf[account]);\n\n      totalSupply = totalSupply.add(diff);\n      balanceOf[account] = balanceOf[account].add(diff);\n\n      emit Transfer(\n        address(0),\n        account,\n          diff\n      );\n    } else {\n      diff = balanceOf[account].sub(balance);\n\n      totalSupply = totalSupply.sub(diff);\n      balanceOf[account] = balanceOf[account].sub(diff);\n\n      emit Transfer(\n        account,\n        address(0),\n        diff\n      );\n    }\n  }\n\n  function transfer(\n    address recipient,\n    uint256 amount\n  )\n    external\n    override\n    returns (bool)\n  {\n    _transfer(msg.sender, recipient, amount);\n\n    return true;\n  }\n\n  function approve(\n    address spender,\n    uint256 amount\n  )\n    external\n    override\n    returns (bool)\n  {\n    _approve(msg.sender, spender, amount);\n\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    external\n    override\n    returns (bool)\n  {\n    _transfer(sender, recipient, amount);\n\n    require(\n      allowance[sender][msg.sender] >= amount,\n      \"ERC20Mock#2\"\n    );\n\n    _approve(\n      sender,\n      msg.sender,\n      allowance[sender][msg.sender].sub(amount)\n    );\n\n    return true;\n  }\n\n  // private functions\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      sender != address(0),\n      \"ERC20Mock#3\"\n    );\n\n    require(\n      recipient != address(0),\n      \"ERC20Mock#4\"\n    );\n\n    require(\n      balanceOf[sender] >= amount,\n      \"ERC20Mock#5\"\n    );\n\n    balanceOf[sender] = balanceOf[sender].sub(amount);\n    balanceOf[recipient] = balanceOf[recipient].add(amount);\n\n    emit Transfer(\n      sender,\n      recipient,\n      amount\n    );\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  )\n    private\n  {\n    require(\n      owner != address(0),\n      \"ERC20Mock#6\"\n    );\n\n    require(\n      spender != address(0),\n      \"ERC20Mock#7\"\n    );\n\n    allowance[owner][spender] = amount;\n\n    emit Approval(\n      owner,\n      spender,\n      amount\n    );\n  }\n}\n"
    },
    "src/core/access/LockableMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./Lockable.sol\";\n\n\n/**\n * @title Lockable mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract LockableMock is Lockable {\n  // events\n\n  event Triggered();\n\n  /**\n   * @dev Public constructor\n   */\n  constructor()\n    public\n  {\n    //\n  }\n\n  // external functions\n\n  function setLocked(\n    bool locked_\n  )\n    external\n  {\n    locked = locked_;\n  }\n\n  // external functions\n\n  function triggerLock()\n    external\n    lock\n  {\n    emit Triggered();\n  }\n\n  function triggerLockOrThrowError()\n    external\n    lockOrThrowError\n  {\n    emit Triggered();\n  }\n}\n"
    },
    "src/core/access/OwnedMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./Owned.sol\";\n\n\n/**\n * @title Owned mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract OwnedMock is Owned {\n  // events\n\n  event Triggered();\n\n  /**\n   * @dev Public constructor\n   */\n  constructor()\n    public\n    Owned()\n  {\n    //\n  }\n\n  // external functions\n\n  function triggerOnlyOwner()\n    external\n    onlyOwner\n  {\n    emit Triggered();\n  }\n}\n"
    },
    "src/core/lifecycle/InitializableMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./Initializable.sol\";\n\n\n/**\n * @title Initializable mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract InitializableMock is Initializable {\n  // events\n\n  event Triggered();\n\n  /**\n   * @dev Public constructor\n   */\n  constructor()\n    public\n    Initializable()\n  {\n    //\n  }\n\n  // external functions\n\n  function triggerOnlyInitializer()\n    external\n    onlyInitializer\n  {\n    emit Triggered();\n  }\n}\n"
    },
    "src/core/math/SafeMathLibMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./SafeMathLib.sol\";\n\n\n/**\n * @title Safe math library mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract SafeMathLibMock {\n  using SafeMathLib for uint256;\n\n  // external functions (pure)\n\n  function add(\n    uint256 a,\n    uint256 b\n  )\n    external\n    pure\n    returns (uint256)\n  {\n    return a.add(b);\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b\n  )\n    external\n    pure\n    returns (uint256)\n  {\n    return a.sub(b);\n  }\n\n  function mul(\n    uint256 a,\n    uint256 b\n  )\n    external\n    pure\n    returns (uint256)\n  {\n    return a.mul(b);\n  }\n\n  function div(\n    uint256 a,\n    uint256 b\n  )\n    external\n    pure\n    returns (uint256)\n  {\n    return a.div(b);\n  }\n}\n"
    },
    "src/core/math/MathLibMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./MathLib.sol\";\n\n\n/**\n * @title Math library mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract MathLibMock {\n  using MathLib for uint256;\n\n  // external functions (pure)\n\n  function percent(\n    uint256 a,\n    uint256 p\n  )\n    external\n    pure\n    returns (uint256)\n  {\n    return a.percent(p);\n  }\n}\n"
    },
    "src/MetaheroDAOMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./IMetaheroDAO.sol\";\n\n\n/**\n * @title Metahero DAO mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract MetaheroDAOMock is IMetaheroDAO {\n  // events\n\n  event MemberWeightSynced(\n    address member,\n    uint256 memberWeight\n  );\n\n  event TotalWeightSynced(\n    uint256 totalWeight\n  );\n\n  // external functions\n\n  function syncMember(\n    address member,\n    uint256 memberWeight,\n    uint256 totalWeight\n  )\n    external\n    override\n  {\n    emit MemberWeightSynced(\n      member,\n      memberWeight\n    );\n\n    emit TotalWeightSynced(\n      totalWeight\n    );\n  }\n\n  function syncMembers(\n    address memberA,\n    uint256 memberAWeight,\n    address memberB,\n    uint256 memberBWeight,\n    uint256 totalWeight\n  )\n    external\n    override\n  {\n    emit MemberWeightSynced(\n      memberA,\n      memberAWeight\n    );\n\n    emit MemberWeightSynced(\n      memberB,\n      memberBWeight\n    );\n\n    emit TotalWeightSynced(\n      totalWeight\n    );\n  }\n}\n"
    },
    "src/core/access/ControlledMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./Controlled.sol\";\n\n\n/**\n * @title Controlled mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract ControlledMock is Controlled {\n  // events\n\n  event Triggered();\n\n  /**\n   * @dev Public constructor\n   */\n  constructor()\n    public\n    Controlled()\n  {\n    //\n  }\n\n  // external functions\n\n  function triggerOnlyController()\n    external\n    onlyController\n  {\n    emit Triggered();\n  }\n\n  function initializeController(\n    address controller_\n  )\n    external\n  {\n    _initializeController(controller_);\n  }\n\n  function setController(\n    address controller_\n  )\n    external\n  {\n    _setController(controller_);\n  }\n\n  function removeController()\n    external\n  {\n    _removeController();\n  }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "istanbul",
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}