{
  "language": "Solidity",
  "sources": {
    "src/core/access/Controlled.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Controlled\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract Controlled {\n  /**\n   * @return controller address\n   */\n  address public controller;\n\n  // modifiers\n\n  /**\n   * @dev Throws if msg.sender is not the controller\n   */\n  modifier onlyController() {\n    require(\n      msg.sender == controller,\n      \"Controlled#1\" // msg.sender is not the controller\n    );\n\n    _;\n  }\n\n  // events\n\n  /**\n   * @dev Emitted when the controller is updated\n   * @param controller new controller address\n   */\n  event ControllerUpdated(address controller);\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor() internal {\n    //\n  }\n\n  // internal functions\n\n  function _initializeController(address controller_) internal {\n    controller = controller_;\n  }\n\n  function _setController(address controller_) internal {\n    require(\n      controller_ != address(0),\n      \"Controlled#2\" // controller is the zero address\n    );\n\n    require(\n      controller_ != controller,\n      \"Controlled#3\" // does not update the controller\n    );\n\n    controller = controller_;\n\n    emit ControllerUpdated(controller_);\n  }\n\n  function _removeController() internal {\n    require(\n      controller != address(0),\n      \"Controlled#4\" // controller is the zero address\n    );\n\n    controller = address(0);\n\n    emit ControllerUpdated(address(0));\n  }\n}\n"
    },
    "src/MetaheroToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./core/access/Controlled.sol\";\nimport \"./core/access/Owned.sol\";\nimport \"./core/erc20/ERC20.sol\";\nimport \"./core/lifecycle/Initializable.sol\";\nimport \"./core/math/MathLib.sol\";\nimport \"./core/math/SafeMathLib.sol\";\nimport \"./IMetaheroDAO.sol\";\nimport \"./MetaheroLPM.sol\";\n\n/**\n * @title Metahero token\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract MetaheroToken is Controlled, Owned, ERC20, Initializable {\n  using MathLib for uint256;\n  using SafeMathLib for uint256;\n\n  struct Fees {\n    uint256 sender; // percent from sender\n    uint256 recipient; // percent from recipient\n  }\n\n  struct Settings {\n    Fees burnFees; // fee taken and burned\n    Fees lpFees; // fee taken and added to the liquidity pool manager\n    Fees rewardsFees; // fee taken and added to rewards\n    uint256 minTotalSupply; // min amount of tokens total supply\n  }\n\n  struct Summary {\n    uint256 totalExcluded; // total held by excluded accounts\n    uint256 totalHolding; // total held by holder accounts\n    uint256 totalRewards; // total rewards\n    uint256 totalSupply; // total supply\n  }\n\n  struct ExcludedAccount {\n    bool exists; // true if exists\n    bool excludeSenderFromFee; // removes the fee from all sender accounts on incoming transfers\n    bool excludeRecipientFromFee; // removes the fee from all recipient accounts on outgoing transfers\n  }\n\n  // globals\n\n  uint256 private constant MAX_FEE = 30; // max sum of all fees - 30%\n\n  // metadata\n\n  string private constant TOKEN_NAME = \"Metahero\";\n  string private constant TOKEN_SYMBOL = \"HERO\";\n  uint8 private constant TOKEN_DECIMALS = 18; // 0.000000000000000000\n\n  /**\n   * @return dao address\n   */\n  IMetaheroDAO public dao;\n\n  /**\n   * @return liquidity pool manager address\n   */\n  MetaheroLPM public lpm;\n\n  /**\n   * @return settings object\n   */\n  Settings public settings;\n\n  /**\n   * @return summary object\n   */\n  Summary public summary;\n\n  /**\n   * @return return true when presale is finished\n   */\n  bool public presaleFinished;\n\n  mapping(address => uint256) private accountBalances;\n  mapping(address => mapping(address => uint256)) private accountAllowances;\n  mapping(address => ExcludedAccount) private excludedAccounts;\n\n  // events\n\n  /**\n   * @dev Emitted when the contract is initialized\n   * @param burnFees burn fees\n   * @param lpFees liquidity pool fees\n   * @param rewardsFees rewards fees\n   * @param minTotalSupply min total supply\n   * @param lpm liquidity pool manager address\n   * @param controller controller address\n   */\n  event Initialized(\n    Fees burnFees,\n    Fees lpFees,\n    Fees rewardsFees,\n    uint256 minTotalSupply,\n    address lpm,\n    address controller\n  );\n\n  /**\n   * @dev Emitted when the dao is updated\n   * @param dao dao address\n   */\n  event DAOUpdated(address dao);\n\n  /**\n   * @dev Emitted when fees are updated\n   * @param burnFees burn fees\n   * @param lpFees liquidity pool fees\n   * @param rewardsFees rewards fees\n   */\n  event FeesUpdated(Fees burnFees, Fees lpFees, Fees rewardsFees);\n\n  /**\n   * @dev Emitted when the presale is finished\n   */\n  event PresaleFinished();\n\n  /**\n   * @dev Emitted when account is excluded\n   * @param account account address\n   * @param excludeSenderFromFee exclude sender from fee\n   * @param excludeRecipientFromFee exclude recipient from fee\n   */\n  event AccountExcluded(\n    address indexed account,\n    bool excludeSenderFromFee,\n    bool excludeRecipientFromFee\n  );\n\n  /**\n   * @dev Emitted when total rewards amount is updated\n   * @param totalRewards total rewards amount\n   */\n  event TotalRewardsUpdated(uint256 totalRewards);\n\n  // modifiers\n\n  /**\n   * @dev Throws if msg.sender is not the dao\n   */\n  modifier onlyDAO() {\n    require(\n      msg.sender == address(dao),\n      \"MetaheroToken#1\" // msg.sender is not the dao\n    );\n\n    _;\n  }\n\n  /**\n   * @dev Throws if msg.sender is not the excluded account\n   */\n  modifier onlyExcludedAccount() {\n    require(\n      excludedAccounts[msg.sender].exists,\n      \"MetaheroToken#2\" // msg.sender is not the excluded account\n    );\n\n    _;\n  }\n\n  /**\n   * @dev Public constructor\n   */\n  constructor()\n    public\n    Controlled()\n    Owned()\n    ERC20(TOKEN_NAME, TOKEN_SYMBOL, TOKEN_DECIMALS) // sets metadata\n    Initializable()\n  {\n    //\n  }\n\n  // external functions\n\n  /**\n   * @dev Initializes the contract\n   * @param burnFees burn fees\n   * @param lpFees liquidity pool fees\n   * @param rewardsFees rewards fees\n   * @param minTotalSupply min total supply\n   * @param lpm_ liquidity pool manager address\n   * @param controller_ controller address\n   * @param totalSupply_ total supply\n   */\n  function initialize(\n    Fees memory burnFees,\n    Fees memory lpFees,\n    Fees memory rewardsFees,\n    uint256 minTotalSupply,\n    address payable lpm_,\n    address controller_,\n    uint256 totalSupply_,\n    address[] calldata excludedAccounts_\n  ) external onlyInitializer {\n    _verifyFees(burnFees, lpFees, rewardsFees);\n\n    settings.burnFees = burnFees;\n    settings.lpFees = lpFees;\n    settings.rewardsFees = rewardsFees;\n    settings.minTotalSupply = minTotalSupply;\n\n    if (lpFees.sender != 0 || lpFees.recipient != 0) {\n      require(\n        lpm_ != address(0),\n        \"MetaheroToken#3\" // lpm is the zero address\n      );\n\n      lpm = MetaheroLPM(lpm_);\n    }\n\n    _initializeController(controller_);\n\n    emit Initialized(\n      burnFees,\n      lpFees,\n      rewardsFees,\n      minTotalSupply,\n      lpm_,\n      controller_\n    );\n\n    // excludes owner account\n    _excludeAccount(msg.sender, true, true);\n\n    if (totalSupply_ != 0) {\n      _mint(msg.sender, totalSupply_);\n    }\n\n    // adds predefined excluded accounts\n    uint256 excludedAccountsLen = excludedAccounts_.length;\n\n    for (uint256 index; index < excludedAccountsLen; index++) {\n      _excludeAccount(excludedAccounts_[index], false, false);\n    }\n  }\n\n  /**\n   * @dev Sets the dao\n   * @param dao_ dao address\n   */\n  function setDAO(address dao_) external onlyOwner {\n    require(\n      dao_ != address(0),\n      \"MetaheroToken#4\" // dao is the zero address\n    );\n\n    dao = IMetaheroDAO(dao_);\n\n    emit DAOUpdated(dao_);\n\n    // makes a dao an owner\n    _setOwner(dao_);\n  }\n\n  /**\n   * @dev Updates fees\n   * @param burnFees burn fees\n   * @param lpFees liquidity pool fees\n   * @param rewardsFees rewards fees\n   */\n  function updateFees(\n    Fees memory burnFees,\n    Fees memory lpFees,\n    Fees memory rewardsFees\n  )\n    external\n    onlyDAO // only for dao\n  {\n    _verifyFees(burnFees, lpFees, rewardsFees);\n\n    settings.burnFees = burnFees;\n    settings.lpFees = lpFees;\n    settings.rewardsFees = rewardsFees;\n\n    emit FeesUpdated(burnFees, lpFees, rewardsFees);\n  }\n\n  /**\n   * @dev Set the presale as finished\n   */\n  function setPresaleAsFinished() external onlyOwner {\n    require(\n      !presaleFinished,\n      \"MetaheroToken#5\" // the presale is already finished\n    );\n\n    presaleFinished = true;\n\n    emit PresaleFinished();\n  }\n\n  /**\n   * @dev Excludes account\n   * @param account account address\n   * @param excludeSenderFromFee exclude sender from fee\n   * @param excludeRecipientFromFee exclude recipient from fee\n   */\n  function excludeAccount(\n    address account,\n    bool excludeSenderFromFee,\n    bool excludeRecipientFromFee\n  ) external onlyOwner {\n    _excludeAccount(account, excludeSenderFromFee, excludeRecipientFromFee);\n  }\n\n  /**\n   * @dev Approve spending limit\n   * @param spender spender address\n   * @param amount spending limit\n   */\n  function approve(address spender, uint256 amount)\n    external\n    override\n    returns (bool)\n  {\n    _approve(msg.sender, spender, amount);\n\n    return true;\n  }\n\n  /**\n   * @dev Mints tokens to recipient\n   * @param recipient recipient address\n   * @param amount tokens amount\n   */\n  function mintTo(address recipient, uint256 amount) external onlyController {\n    _mint(recipient, amount);\n  }\n\n  /**\n   * @dev Burns tokens from msg.sender\n   * @param amount tokens amount\n   */\n  function burn(uint256 amount) external onlyExcludedAccount {\n    _burn(msg.sender, amount);\n  }\n\n  /**\n   * @dev Burns tokens from sender\n   * @param sender sender address\n   * @param amount tokens amount\n   */\n  function burnFrom(address sender, uint256 amount) external onlyController {\n    _burn(sender, amount);\n  }\n\n  /**\n   * @dev Transfers tokens to recipient\n   * @param recipient recipient address\n   * @param amount tokens amount\n   */\n  function transfer(address recipient, uint256 amount)\n    external\n    override\n    returns (bool)\n  {\n    _transfer(msg.sender, recipient, amount);\n\n    return true;\n  }\n\n  /**\n   * @dev Transfers tokens from sender to recipient\n   * @param sender sender address\n   * @param recipient recipient address\n   * @param amount tokens amount\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external override returns (bool) {\n    _transfer(sender, recipient, amount);\n\n    uint256 allowance = accountAllowances[sender][msg.sender];\n\n    require(\n      allowance >= amount,\n      \"MetaheroToken#6\" // amount exceeds allowance\n    );\n\n    _approve(sender, msg.sender, allowance.sub(amount)); // update allowance\n\n    return true;\n  }\n\n  // external functions (views)\n\n  /**\n   * @dev Gets excluded account\n   * @param account account address\n   */\n  function getExcludedAccount(address account)\n    external\n    view\n    returns (\n      bool exists,\n      bool excludeSenderFromFee,\n      bool excludeRecipientFromFee\n    )\n  {\n    return (\n      excludedAccounts[account].exists,\n      excludedAccounts[account].excludeSenderFromFee,\n      excludedAccounts[account].excludeRecipientFromFee\n    );\n  }\n\n  /**\n   * @dev Gets total supply\n   * @return total supply\n   */\n  function totalSupply() external view override returns (uint256) {\n    return summary.totalSupply;\n  }\n\n  /**\n   * @dev Gets allowance\n   * @param owner owner address\n   * @param spender spender address\n   * @return allowance\n   */\n  function allowance(address owner, address spender)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return accountAllowances[owner][spender];\n  }\n\n  /**\n   * @dev Gets balance of\n   * @param account account address\n   * @return result account balance\n   */\n  function balanceOf(address account)\n    external\n    view\n    override\n    returns (uint256 result)\n  {\n    result = accountBalances[account].add(_calcRewards(account));\n\n    return result;\n  }\n\n  /**\n   * @dev Gets balance summary\n   * @param account account address\n   */\n  function getBalanceSummary(address account)\n    external\n    view\n    returns (\n      uint256 totalBalance,\n      uint256 holdingBalance,\n      uint256 totalRewards\n    )\n  {\n    holdingBalance = accountBalances[account];\n    totalRewards = _calcRewards(account);\n    totalBalance = holdingBalance.add(totalRewards);\n\n    return (totalBalance, holdingBalance, totalRewards);\n  }\n\n  // private functions\n\n  function _excludeAccount(\n    address account,\n    bool excludeSenderFromFee,\n    bool excludeRecipientFromFee\n  ) private {\n    require(\n      account != address(0),\n      \"MetaheroToken#7\" // account is the zero address\n    );\n\n    // if already excluded\n    if (excludedAccounts[account].exists) {\n      require(\n        excludedAccounts[account].excludeSenderFromFee !=\n          excludeSenderFromFee ||\n          excludedAccounts[account].excludeRecipientFromFee !=\n          excludeRecipientFromFee,\n        \"MetaheroToken#8\" // does not update exclude account\n      );\n\n      excludedAccounts[account].excludeSenderFromFee = excludeSenderFromFee;\n      excludedAccounts[account]\n        .excludeRecipientFromFee = excludeRecipientFromFee;\n    } else {\n      require(\n        accountBalances[account] == 0,\n        \"MetaheroToken#9\" // can not exclude holder account\n      );\n\n      excludedAccounts[account].exists = true;\n      excludedAccounts[account].excludeSenderFromFee = excludeSenderFromFee;\n      excludedAccounts[account]\n        .excludeRecipientFromFee = excludeRecipientFromFee;\n    }\n\n    emit AccountExcluded(\n      account,\n      excludeSenderFromFee,\n      excludeRecipientFromFee\n    );\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) private {\n    require(\n      spender != address(0),\n      \"MetaheroToken#11\" // spender is the zero address\n    );\n\n    accountAllowances[owner][spender] = amount;\n\n    emit Approval(owner, spender, amount);\n  }\n\n  function _mint(address recipient, uint256 amount) private {\n    require(\n      recipient != address(0),\n      \"MetaheroToken#12\" // recipient is the zero address\n    );\n\n    require(\n      amount != 0,\n      \"MetaheroToken#13\" // amount is zero\n    );\n\n    summary.totalSupply = summary.totalSupply.add(amount);\n\n    // if exclude account\n    if (excludedAccounts[recipient].exists) {\n      summary.totalExcluded = summary.totalExcluded.add(amount);\n\n      accountBalances[recipient] = accountBalances[recipient].add(amount);\n    } else {\n      _updateHoldingBalance(\n        recipient,\n        accountBalances[recipient].add(amount),\n        summary.totalHolding.add(amount)\n      );\n    }\n\n    _emitTransfer(address(0), recipient, amount);\n  }\n\n  function _burn(address sender, uint256 amount) private {\n    require(\n      sender != address(0),\n      \"MetaheroToken#14\" // sender is the zero address\n    );\n\n    require(\n      amount != 0,\n      \"MetaheroToken#15\" // amount is zero\n    );\n\n    require(\n      accountBalances[sender] >= amount,\n      \"MetaheroToken#16\" // amount exceeds sender balance\n    );\n\n    uint256 totalSupply_ = summary.totalSupply.sub(amount);\n\n    if (settings.minTotalSupply != 0) {\n      require(\n        totalSupply_ >= settings.minTotalSupply,\n        \"MetaheroToken#17\" // new total supply exceeds min total supply\n      );\n    }\n\n    summary.totalSupply = totalSupply_;\n\n    // if exclude account\n    if (excludedAccounts[sender].exists) {\n      summary.totalExcluded = summary.totalExcluded.sub(amount);\n\n      accountBalances[sender] = accountBalances[sender].sub(amount);\n    } else {\n      _updateHoldingBalance(\n        sender,\n        accountBalances[sender].sub(amount),\n        summary.totalHolding.sub(amount)\n      );\n    }\n\n    _emitTransfer(sender, address(0), amount);\n  }\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) private {\n    require(\n      sender != address(0),\n      \"MetaheroToken#18\" // sender is the zero address\n    );\n\n    require(\n      recipient != address(0),\n      \"MetaheroToken#19\" // recipient is the zero address\n    );\n\n    if (sender == recipient) {\n      // special transfer type\n      _syncLP(); // sync only LP\n\n      _emitTransfer(sender, recipient, 0);\n    } else {\n      require(\n        excludedAccounts[sender].exists || presaleFinished,\n        \"MetaheroToken#20\" // presale not finished yet\n      );\n\n      require(\n        amount != 0,\n        \"MetaheroToken#21\" // amount is zero\n      );\n\n      if (\n        !excludedAccounts[sender].exists && !excludedAccounts[recipient].exists\n      ) {\n        _transferBetweenHolderAccounts(sender, recipient, amount);\n      } else if (\n        excludedAccounts[sender].exists && !excludedAccounts[recipient].exists\n      ) {\n        _transferFromExcludedAccount(sender, recipient, amount);\n      } else if (\n        !excludedAccounts[sender].exists && excludedAccounts[recipient].exists\n      ) {\n        _transferToExcludedAccount(sender, recipient, amount);\n      } else {\n        _transferBetweenExcludedAccounts(sender, recipient, amount);\n      }\n    }\n  }\n\n  function _transferBetweenHolderAccounts(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) private {\n    uint256 senderAmount;\n    uint256 senderBurnFee;\n    uint256 senderLpFee;\n\n    uint256 recipientAmount;\n    uint256 recipientBurnFee;\n    uint256 recipientLpFee;\n\n    uint256 totalFee;\n\n    {\n      uint256 totalSupply_ = summary.totalSupply;\n\n      // calc fees for sender and recipient\n      {\n        uint256 senderTotalFee;\n        uint256 recipientTotalFee;\n\n        (senderTotalFee, senderBurnFee, senderLpFee) = _calcTransferSenderFees(\n          amount\n        );\n\n        (\n          totalSupply_,\n          senderTotalFee,\n          senderBurnFee\n        ) = _matchTotalSupplyWithFees(\n          totalSupply_,\n          senderTotalFee,\n          senderBurnFee\n        );\n\n        (\n          recipientTotalFee,\n          recipientBurnFee,\n          recipientLpFee\n        ) = _calcTransferRecipientFees(amount);\n\n        (\n          totalSupply_,\n          recipientTotalFee,\n          recipientBurnFee\n        ) = _matchTotalSupplyWithFees(\n          totalSupply_,\n          recipientTotalFee,\n          recipientBurnFee\n        );\n\n        totalFee = senderTotalFee.add(recipientTotalFee);\n        senderAmount = amount.add(senderTotalFee);\n        recipientAmount = amount.sub(recipientTotalFee);\n      }\n\n      // appends total rewards\n      if (summary.totalRewards != 0) {\n        uint256 totalHoldingWithRewards = summary.totalHolding.add(\n          summary.totalRewards\n        );\n\n        senderAmount = senderAmount.mul(summary.totalHolding).div(\n          totalHoldingWithRewards\n        );\n        recipientAmount = recipientAmount.mul(summary.totalHolding).div(\n          totalHoldingWithRewards\n        );\n        totalFee = totalFee.mul(summary.totalHolding).div(\n          totalHoldingWithRewards\n        );\n      }\n\n      require(\n        accountBalances[sender] >= senderAmount,\n        \"MetaheroToken#22\" // amount exceeds sender balance\n      );\n\n      summary.totalSupply = totalSupply_;\n\n      // reduce local vars\n      senderAmount = accountBalances[sender].sub(senderAmount);\n      recipientAmount = accountBalances[recipient].add(recipientAmount);\n\n      _updateHoldingBalances(\n        sender,\n        senderAmount,\n        recipient,\n        recipientAmount,\n        summary.totalHolding.sub(totalFee)\n      );\n\n      _increaseTotalLP(senderLpFee.add(recipientLpFee));\n    }\n\n    // emits events\n\n    {\n      _emitTransfer(sender, recipient, amount);\n\n      _emitTransfer(sender, address(0), senderBurnFee);\n\n      _emitTransfer(sender, address(lpm), senderLpFee);\n\n      _emitTransfer(recipient, address(0), recipientBurnFee);\n\n      _emitTransfer(recipient, address(lpm), recipientLpFee);\n\n      _updateTotalRewards();\n\n      _syncLP();\n    }\n  }\n\n  function _transferFromExcludedAccount(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) private {\n    require(\n      accountBalances[sender] >= amount,\n      \"MetaheroToken#23\" // amount exceeds sender balance\n    );\n\n    (bool shouldSyncLPBefore, bool shouldSyncLPAfter) = _canSyncLP(\n      sender,\n      address(0)\n    );\n\n    if (shouldSyncLPBefore) {\n      lpm.syncLP();\n    }\n\n    uint256 recipientTotalFee;\n    uint256 recipientBurnFee;\n    uint256 recipientLPFee;\n\n    uint256 totalSupply_ = summary.totalSupply;\n\n    // when sender does not remove the fee from the recipient\n    if (!excludedAccounts[sender].excludeRecipientFromFee) {\n      (\n        recipientTotalFee,\n        recipientBurnFee,\n        recipientLPFee\n      ) = _calcTransferRecipientFees(amount);\n\n      (\n        totalSupply_,\n        recipientTotalFee,\n        recipientBurnFee\n      ) = _matchTotalSupplyWithFees(\n        totalSupply_,\n        recipientTotalFee,\n        recipientBurnFee\n      );\n    }\n\n    uint256 recipientAmount = amount.sub(recipientTotalFee);\n\n    summary.totalSupply = totalSupply_;\n    summary.totalExcluded = summary.totalExcluded.sub(amount);\n\n    accountBalances[sender] = accountBalances[sender].sub(amount);\n\n    _updateHoldingBalance(\n      recipient,\n      accountBalances[recipient].add(recipientAmount),\n      summary.totalHolding.add(recipientAmount)\n    );\n\n    _increaseTotalLP(recipientLPFee);\n\n    // emits events\n\n    _emitTransfer(sender, recipient, amount);\n\n    _emitTransfer(recipient, address(0), recipientBurnFee);\n\n    _emitTransfer(recipient, address(lpm), recipientLPFee);\n\n    _updateTotalRewards();\n\n    if (shouldSyncLPAfter) {\n      lpm.syncLP();\n    }\n  }\n\n  function _transferToExcludedAccount(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) private {\n    (bool shouldSyncLPBefore, bool shouldSyncLPAfter) = _canSyncLP(\n      address(0),\n      recipient\n    );\n\n    if (shouldSyncLPBefore) {\n      lpm.syncLP();\n    }\n\n    uint256 senderTotalFee;\n    uint256 senderBurnFee;\n    uint256 senderLpFee;\n\n    uint256 totalSupply_ = summary.totalSupply;\n\n    // when recipient does not remove the fee from the sender\n    if (!excludedAccounts[recipient].excludeSenderFromFee) {\n      (senderTotalFee, senderBurnFee, senderLpFee) = _calcTransferSenderFees(\n        amount\n      );\n\n      (totalSupply_, senderTotalFee, senderBurnFee) = _matchTotalSupplyWithFees(\n        totalSupply_,\n        senderTotalFee,\n        senderBurnFee\n      );\n    }\n\n    uint256 senderAmount = amount.add(senderTotalFee);\n\n    // append total rewards\n    if (summary.totalRewards != 0) {\n      uint256 totalHoldingWithRewards = summary.totalHolding.add(\n        summary.totalRewards\n      );\n\n      senderAmount = senderAmount.mul(summary.totalHolding).div(\n        totalHoldingWithRewards\n      );\n    }\n\n    require(\n      accountBalances[sender] >= senderAmount,\n      \"MetaheroToken#24\" // amount exceeds sender balance\n    );\n\n    summary.totalSupply = totalSupply_;\n    summary.totalExcluded = summary.totalExcluded.add(amount);\n\n    accountBalances[recipient] = accountBalances[recipient].add(amount);\n\n    _updateHoldingBalance(\n      sender,\n      accountBalances[sender].sub(senderAmount),\n      summary.totalHolding.sub(senderAmount)\n    );\n\n    _increaseTotalLP(senderLpFee);\n\n    // emits events\n\n    _emitTransfer(sender, recipient, amount);\n\n    _emitTransfer(sender, address(0), senderBurnFee);\n\n    _emitTransfer(sender, address(lpm), senderLpFee);\n\n    _updateTotalRewards();\n\n    if (shouldSyncLPAfter) {\n      lpm.syncLP();\n    }\n  }\n\n  function _transferBetweenExcludedAccounts(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) private {\n    require(\n      accountBalances[sender] >= amount,\n      \"MetaheroToken#25\" // amount exceeds sender balance\n    );\n\n    (bool shouldSyncLPBefore, bool shouldSyncLPAfter) = _canSyncLP(\n      address(0),\n      recipient\n    );\n\n    if (shouldSyncLPBefore) {\n      lpm.syncLP();\n    }\n\n    accountBalances[sender] = accountBalances[sender].sub(amount);\n    accountBalances[recipient] = accountBalances[recipient].add(amount);\n\n    _emitTransfer(sender, recipient, amount);\n\n    if (shouldSyncLPAfter) {\n      lpm.syncLP();\n    }\n  }\n\n  function _updateHoldingBalance(\n    address holder,\n    uint256 holderBalance,\n    uint256 totalHolding\n  ) private {\n    accountBalances[holder] = holderBalance;\n    summary.totalHolding = totalHolding;\n\n    if (address(dao) != address(0)) {\n      // if dao is not the zero address\n      dao.syncMember(holder, holderBalance, totalHolding);\n    }\n  }\n\n  function _updateHoldingBalances(\n    address holderA,\n    uint256 holderABalance,\n    address holderB,\n    uint256 holderBBalance,\n    uint256 totalHolding\n  ) private {\n    accountBalances[holderA] = holderABalance;\n    accountBalances[holderB] = holderBBalance;\n    summary.totalHolding = totalHolding;\n\n    if (address(dao) != address(0)) {\n      // if dao is not the zero address\n      dao.syncMembers(\n        holderA,\n        holderABalance,\n        holderB,\n        holderBBalance,\n        totalHolding\n      );\n    }\n  }\n\n  function _emitTransfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) private {\n    if (amount != 0) {\n      // when amount is not zero\n      emit Transfer(sender, recipient, amount);\n    }\n  }\n\n  function _increaseTotalLP(uint256 amount) private {\n    if (amount != 0) {\n      // when amount is not zero\n      accountBalances[address(lpm)] = accountBalances[address(lpm)].add(amount);\n\n      summary.totalExcluded = summary.totalExcluded.add(amount);\n    }\n  }\n\n  function _syncLP() private {\n    if (address(lpm) != address(0)) {\n      // if lpm is not the zero address\n      lpm.syncLP();\n    }\n  }\n\n  function _updateTotalRewards() private {\n    // totalRewards = totalSupply - totalExcluded - totalHolding\n    uint256 totalRewards = summary.totalSupply.sub(summary.totalExcluded).sub(\n      summary.totalHolding\n    );\n\n    if (totalRewards != summary.totalRewards) {\n      summary.totalRewards = totalRewards;\n\n      emit TotalRewardsUpdated(totalRewards);\n    }\n  }\n\n  // private functions (views)\n\n  function _matchTotalSupplyWithFees(\n    uint256 totalSupply_,\n    uint256 totalFee,\n    uint256 burnFee\n  )\n    private\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    if (burnFee != 0) {\n      uint256 newTotalSupply = totalSupply_.sub(burnFee);\n\n      if (newTotalSupply >= settings.minTotalSupply) {\n        totalSupply_ = newTotalSupply;\n      } else {\n        // turn of burn fee\n        totalFee = totalFee.sub(burnFee);\n        burnFee = 0;\n      }\n    }\n\n    return (totalSupply_, totalFee, burnFee);\n  }\n\n  function _canSyncLP(address sender, address recipient)\n    private\n    view\n    returns (bool shouldSyncLPBefore, bool shouldSyncLPAfter)\n  {\n    if (address(lpm) != address(0)) {\n      // if lpm is not the zero address\n      (shouldSyncLPBefore, shouldSyncLPAfter) = lpm.canSyncLP(\n        sender,\n        recipient\n      );\n    }\n\n    return (shouldSyncLPBefore, shouldSyncLPAfter);\n  }\n\n  function _calcRewards(address account) private view returns (uint256 result) {\n    if (\n      !excludedAccounts[account].exists && summary.totalRewards != 0 // only for holders\n    ) {\n      result = summary.totalRewards.mul(accountBalances[account]).div(\n        summary.totalHolding\n      );\n    }\n\n    return result;\n  }\n\n  function _calcTransferSenderFees(uint256 amount)\n    private\n    view\n    returns (\n      uint256 totalFee,\n      uint256 burnFee,\n      uint256 lpFee\n    )\n  {\n    uint256 rewardsFee = amount.percent(settings.rewardsFees.sender);\n\n    lpFee = amount.percent(settings.lpFees.sender);\n    burnFee = amount.percent(settings.burnFees.sender);\n\n    totalFee = lpFee.add(rewardsFee).add(burnFee);\n\n    return (totalFee, burnFee, lpFee);\n  }\n\n  function _calcTransferRecipientFees(uint256 amount)\n    private\n    view\n    returns (\n      uint256 totalFee,\n      uint256 burnFee,\n      uint256 lpFee\n    )\n  {\n    uint256 rewardsFee = amount.percent(settings.rewardsFees.recipient);\n\n    lpFee = amount.percent(settings.lpFees.recipient);\n    burnFee = amount.percent(settings.burnFees.recipient);\n\n    totalFee = lpFee.add(rewardsFee).add(burnFee);\n\n    return (totalFee, burnFee, lpFee);\n  }\n\n  // private functions (pure)\n\n  function _verifyFees(\n    Fees memory burnFees,\n    Fees memory lpFees,\n    Fees memory rewardsFees\n  ) private pure {\n    uint256 totalFee = burnFees\n      .sender\n      .add(burnFees.recipient)\n      .add(lpFees.sender.add(lpFees.recipient))\n      .add(rewardsFees.sender.add(rewardsFees.recipient));\n\n    require(\n      totalFee <= MAX_FEE,\n      \"MetaheroToken#26\" // the total fee is too high\n    );\n  }\n}\n"
    },
    "src/core/access/Owned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Owned\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract Owned {\n  /**\n   * @return owner address\n   */\n  address public owner;\n\n  // modifiers\n\n  /**\n   * @dev Throws if msg.sender is not the owner\n   */\n  modifier onlyOwner() {\n    require(\n      msg.sender == owner,\n      \"Owned#1\" // msg.sender is not the owner\n    );\n\n    _;\n  }\n\n  // events\n\n  /**\n   * @dev Emitted when the owner is updated\n   * @param owner new owner address\n   */\n  event OwnerUpdated(address owner);\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor() internal {\n    owner = msg.sender;\n  }\n\n  // external functions\n\n  /**\n   * @notice Sets a new owner\n   * @param owner_ owner address\n   */\n  function setOwner(address owner_) external onlyOwner {\n    _setOwner(owner_);\n  }\n\n  // internal functions\n\n  function _setOwner(address owner_) internal {\n    require(\n      owner_ != address(0),\n      \"Owned#2\" // owner is the zero address\n    );\n\n    require(\n      owner_ != owner,\n      \"Owned#3\" // does not update the owner\n    );\n\n    owner = owner_;\n\n    emit OwnerUpdated(owner_);\n  }\n}\n"
    },
    "src/core/erc20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./IERC20.sol\";\n\n/**\n * @title ERC20 abstract token\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\nabstract contract ERC20 is IERC20 {\n  string public override name;\n  string public override symbol;\n  uint8 public override decimals;\n\n  /**\n   * @dev Internal constructor\n   * @param name_ name\n   * @param symbol_ symbol\n   * @param decimals_ decimals amount\n   */\n  constructor(\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) internal {\n    name = name_;\n    symbol = symbol_;\n    decimals = decimals_;\n  }\n}\n"
    },
    "src/core/lifecycle/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Initializable\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract Initializable {\n  address private initializer;\n\n  // modifiers\n\n  /**\n   * @dev Throws if msg.sender is not the initializer\n   */\n  modifier onlyInitializer() {\n    require(\n      initializer != address(0),\n      \"Initializable#1\" // already initialized\n    );\n\n    require(\n      msg.sender == initializer,\n      \"Initializable#2\" // msg.sender is not the initializer\n    );\n\n    /// @dev removes initializer\n    initializer = address(0);\n\n    _;\n  }\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor() internal {\n    initializer = msg.sender;\n  }\n\n  // external functions (views)\n\n  /**\n   * @notice Checks if contract is initialized\n   * @return true when contract is initialized\n   */\n  function initialized() external view returns (bool) {\n    return initializer == address(0);\n  }\n}\n"
    },
    "src/core/math/MathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./SafeMathLib.sol\";\n\n/**\n * @title Math library\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\nlibrary MathLib {\n  using SafeMathLib for uint256;\n\n  // internal functions (pure)\n\n  /**\n   * @notice Calcs a x p / 100\n   */\n  function percent(uint256 a, uint256 p)\n    internal\n    pure\n    returns (uint256 result)\n  {\n    if (a != 0 && p != 0) {\n      result = a.mul(p).div(100);\n    }\n\n    return result;\n  }\n}\n"
    },
    "src/core/math/SafeMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Safe math library\n *\n * @notice Based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5fe8f4e93bd1d4f5cc9a6899d7f24f5ffe4c14aa/contracts/math/SafeMath.sol\n */\nlibrary SafeMathLib {\n  // internal functions (pure)\n\n  /**\n   * @notice Calcs a + b\n   */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n\n    require(c >= a, \"SafeMathLib#1\");\n\n    return c;\n  }\n\n  /**\n   * @notice Calcs a - b\n   */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, \"SafeMathLib#2\");\n\n    return a - b;\n  }\n\n  /**\n   * @notice Calcs a x b\n   */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 result) {\n    if (a != 0 && b != 0) {\n      result = a * b;\n\n      require(result / a == b, \"SafeMathLib#3\");\n    }\n\n    return result;\n  }\n\n  /**\n   * @notice Calcs a / b\n   */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, \"SafeMathLib#4\");\n\n    return a / b;\n  }\n}\n"
    },
    "src/IMetaheroDAO.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Metahero DAO interface\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ninterface IMetaheroDAO {\n  // external functions\n\n  /**\n   * @notice Called by a token to sync a dao member\n   * @param member member address\n   * @param memberWeight member weight\n   * @param totalWeight all members weight\n   */\n  function syncMember(\n    address member,\n    uint256 memberWeight,\n    uint256 totalWeight\n  ) external;\n\n  /**\n   * @notice Called by a token to sync a dao members\n   * @param memberA member A address\n   * @param memberAWeight member A weight\n   * @param memberB member B address\n   * @param memberBWeight member B weight\n   * @param totalWeight all members weight\n   */\n  function syncMembers(\n    address memberA,\n    uint256 memberAWeight,\n    address memberB,\n    uint256 memberBWeight,\n    uint256 totalWeight\n  ) external;\n}\n"
    },
    "src/MetaheroLPM.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./core/access/Lockable.sol\";\nimport \"./core/access/Owned.sol\";\nimport \"./core/lifecycle/Initializable.sol\";\nimport \"./core/math/SafeMathLib.sol\";\nimport \"./MetaheroToken.sol\";\n\n/**\n * @title Metahero abstract liquidity pool manager\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\nabstract contract MetaheroLPM is Lockable, Owned, Initializable {\n  using SafeMathLib for uint256;\n\n  /**\n   * @return token address\n   */\n  MetaheroToken public token;\n\n  // modifiers\n\n  /**\n   * @dev Throws if msg.sender is not the token\n   */\n  modifier onlyToken() {\n    require(\n      msg.sender == address(token),\n      \"MetaheroLPM#1\" // msg.sender is not the token\n    );\n\n    _;\n  }\n\n  // events\n\n  /**\n   * @dev Emitted when tokens from the liquidity pool are burned\n   * @param amount burnt amount\n   */\n  event LPBurnt(uint256 amount);\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor() internal Lockable() Owned() Initializable() {\n    //\n  }\n\n  // external functions\n\n  /**\n\n   * @notice Syncs liquidity pool\n   */\n  function syncLP() external onlyToken lock {\n    _syncLP();\n  }\n\n  /**\n   * @notice Burns tokens from the liquidity pool\n   * @param amount tokens amount\n   */\n  function burnLP(uint256 amount) external onlyOwner lockOrThrowError {\n    require(\n      amount != 0,\n      \"MetaheroLPM#2\" // amount is zero\n    );\n\n    _burnLP(amount);\n\n    emit LPBurnt(amount);\n  }\n\n  // external functions (views)\n\n  function canSyncLP(address sender, address recipient)\n    external\n    view\n    virtual\n    returns (bool shouldSyncLPBefore, bool shouldSyncLPAfter);\n\n  // internal functions\n\n  function _initialize(address token_) internal {\n    require(\n      token_ != address(0),\n      \"MetaheroLPM#3\" // token is the zero address\n    );\n\n    token = MetaheroToken(token_);\n  }\n\n  function _syncLP() internal virtual;\n\n  function _burnLP(uint256 amount) internal virtual;\n}\n"
    },
    "src/core/erc20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title ERC20 token interface\n *\n * @notice See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n */\ninterface IERC20 {\n  // events\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  // external functions\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n\n  // external functions (views)\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  // external functions (pure)\n\n  function name() external pure returns (string memory);\n\n  function symbol() external pure returns (string memory);\n\n  function decimals() external pure returns (uint8);\n}\n"
    },
    "src/core/access/Lockable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title Lockable\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract Lockable {\n  /**\n   * @return true when contract is locked\n   */\n  bool public locked;\n\n  // modifiers\n\n  /**\n   * @dev Calls only when contract is unlocked\n   */\n  modifier lock() {\n    if (!locked) {\n      locked = true;\n\n      _;\n\n      locked = false;\n    }\n  }\n\n  /**\n   * @dev Throws if contract is locked\n   */\n  modifier lockOrThrowError() {\n    require(\n      !locked,\n      \"Lockable#1\" // contract is locked\n    );\n\n    locked = true;\n\n    _;\n\n    locked = false;\n  }\n\n  /**\n   * @dev Internal constructor\n   */\n  constructor() internal {\n    //\n  }\n}\n"
    },
    "src/MetaheroLPMMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./MetaheroLPM.sol\";\n\n/**\n * @title Metahero liquidity pool manager mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract MetaheroLPMMock is MetaheroLPM {\n  bool private shouldSyncLPBefore;\n  bool private shouldSyncLPAfter;\n\n  // events\n\n  event Triggered();\n\n  event LPSynced();\n\n  /**\n   * @dev Public constructor\n   */\n  constructor() public MetaheroLPM() {\n    //\n  }\n\n  // external functions\n\n  function triggerOnlyToken() external onlyToken {\n    emit Triggered();\n  }\n\n  function initialize(address token_) external {\n    _initialize(token_);\n  }\n\n  function setLocked(bool locked_) external {\n    locked = locked_;\n  }\n\n  function allowSyncLP(bool shouldSyncLPBefore_, bool shouldSyncLPAfter_)\n    external\n  {\n    shouldSyncLPBefore = shouldSyncLPBefore_;\n    shouldSyncLPAfter = shouldSyncLPAfter_;\n  }\n\n  // external functions (views)\n\n  function canSyncLP(address, address)\n    external\n    view\n    override\n    returns (bool, bool)\n  {\n    return (shouldSyncLPBefore, shouldSyncLPAfter);\n  }\n\n  // internal functions\n\n  function _syncLP() internal override {\n    emit LPSynced();\n  }\n\n  function _burnLP(uint256) internal override {\n    emit Triggered();\n  }\n}\n"
    },
    "src/MetaheroLPMForUniswapV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./core/erc20/IWrappedNative.sol\";\nimport \"./uniswapV2/IUniswapV2Factory.sol\";\nimport \"./uniswapV2/IUniswapV2Pair.sol\";\nimport \"./uniswapV2/IUniswapV2Router02.sol\";\nimport \"./MetaheroLPM.sol\";\n\n/**\n * @title Metahero liquidity pool manager for Uniswap v2\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract MetaheroLPMForUniswapV2 is MetaheroLPM {\n  struct Settings {\n    uint256 enableBurnLPAtValue; // value of the tokens that turned on the burnLP method\n    address stableCoin; // stable coin address eg. BUSD, DAI\n  }\n\n  /**\n   * @return settings object\n   */\n  Settings public settings;\n\n  /**\n   * @return Uniswap V2 factory address\n   */\n  IUniswapV2Factory public uniswapFactory;\n\n  /**\n   * @return Uniswap V2 pair address\n   */\n  IUniswapV2Pair public uniswapPair;\n\n  /**\n   * @return Uniswap V2 router02 address\n   */\n  IUniswapV2Router02 public uniswapRouter;\n\n  IWrappedNative private wrappedNative;\n  bool private correctPairOrder;\n\n  // events\n\n  /**\n   * @dev Emitted the contract is initialized\n   * @param enableBurnLPAtValue value of the tokens that turned on the burnLP method\n   * @param stableCoin stable coin address eg. BUSD, DAI\n   * @param token token address\n   * @param uniswapRouter Uniswap V2 router02 address\n   * @param uniswapPair Uniswap V2 pair address\n   */\n  event Initialized(\n    uint256 enableBurnLPAtValue,\n    address stableCoin,\n    address token,\n    address uniswapRouter,\n    address uniswapPair\n  );\n\n  /**\n   * @dev Public constructor\n   */\n  constructor() public MetaheroLPM() {\n    //\n  }\n\n  // external functions\n\n  /**\n   * @dev Mints stable coins to the contract\n   */\n  receive() external payable {\n    _deposit(msg.value);\n  }\n\n  /**\n   * @dev Mints stable coins to the contract\n   */\n  function deposit() external payable {\n    _deposit(msg.value);\n  }\n\n  /**\n   * @dev Initializes the contract\n   * @param enableBurnLPAtValue value of the tokens that turned on the burnLP method\n   * @param stableCoin stable coin address eg. BUSD, DAI\n   * @param token_ token address\n   * @param uniswapRouter_ Uniswap V2 router02 address\n   */\n  function initialize(\n    uint256 enableBurnLPAtValue,\n    address stableCoin,\n    address token_,\n    address uniswapRouter_\n  ) external onlyInitializer {\n    _initialize(token_);\n\n    if (enableBurnLPAtValue != 0) {\n      require(\n        stableCoin != address(0),\n        \"MetaheroLPMForUniswapV2#2\" // stable coin is the zero address\n      );\n\n      settings.enableBurnLPAtValue = enableBurnLPAtValue;\n      settings.stableCoin = stableCoin;\n    }\n\n    require(\n      uniswapRouter_ != address(0),\n      \"MetaheroLPMForUniswapV2#3\" // Uniswap V2 router02 is the zero address\n    );\n\n    uniswapRouter = IUniswapV2Router02(uniswapRouter_);\n    uniswapFactory = IUniswapV2Factory(uniswapRouter.factory());\n\n    wrappedNative = IWrappedNative(uniswapRouter.WETH());\n\n    // create a pair\n    uniswapPair = IUniswapV2Pair(\n      uniswapFactory.createPair(address(token), address(wrappedNative))\n    );\n\n    correctPairOrder = address(token) < address(wrappedNative);\n\n    emit Initialized(\n      enableBurnLPAtValue,\n      stableCoin,\n      token_,\n      uniswapRouter_,\n      address(uniswapPair)\n    );\n  }\n\n  // external functions (views)\n\n  /**\n   * @notice Checks when to sync the liquidity pool\n   * @param sender sender address\n   * @param recipient recipient address\n   */\n  function canSyncLP(address sender, address recipient)\n    external\n    view\n    override\n    returns (bool shouldSyncLPBefore, bool shouldSyncLPAfter)\n  {\n    if (sender != address(uniswapPair)) {\n      // omit when swap HERO > BNB\n      if (recipient == address(uniswapPair)) {\n        shouldSyncLPBefore = true; // swap BNB > HERO\n      } else {\n        shouldSyncLPAfter = true;\n      }\n    }\n\n    return (shouldSyncLPBefore, shouldSyncLPAfter);\n  }\n\n  // internal functions\n\n  function _syncLP() internal override {\n    uint256 totalAmount = token.balanceOf(address(this));\n\n    if (totalAmount >= 2) {\n      uint256 swapAmount = totalAmount.div(2);\n      uint256 liquidityAmount = totalAmount.sub(swapAmount);\n\n      // swap half for native\n      _swapTokens(swapAmount);\n\n      // add other half with received native\n      _addTokensToLiquidity(liquidityAmount);\n    }\n  }\n\n  function _burnLP(uint256 amount) internal override {\n    if (settings.enableBurnLPAtValue != 0) {\n      (uint256 tokenReserve, ) = _getLiquidityReserves();\n\n      require(\n        tokenReserve != 0,\n        \"MetaheroLPMForUniswapV2#4\" // token reserve is zero\n      );\n\n      require(\n        amount <= tokenReserve,\n        \"MetaheroLPMForUniswapV2#5\" // amount higher than token reserve\n      );\n\n      uint256 tokenReserveValue = _calcTokensValue(tokenReserve);\n\n      require(\n        tokenReserveValue > settings.enableBurnLPAtValue,\n        \"MetaheroLPMForUniswapV2#6\" // burnLP disabled\n      );\n\n      uint256 amountValue = _calcTokensValue(amount);\n      uint256 maxAmountValue = tokenReserveValue.sub(\n        settings.enableBurnLPAtValue\n      );\n\n      require(\n        amountValue <= maxAmountValue,\n        \"MetaheroLPMForUniswapV2#7\" // amount is too high\n      );\n    }\n\n    // remove liquidity\n    _removeLiquidity();\n\n    uint256 totalAmount = token.balanceOf(address(this));\n\n    require(\n      totalAmount >= amount,\n      \"MetaheroLPMForUniswapV2#8\" // amount is too high\n    );\n\n    token.burn(amount); // burn tokens\n\n    _addTokensToLiquidity(totalAmount.sub(amount)); // adds others to liquidity\n  }\n\n  // private functions\n\n  function _deposit(uint256 amount) private {\n    require(\n      amount != 0,\n      \"MetaheroLPMForUniswapV2#1\" // amount is zero\n    );\n\n    wrappedNative.deposit{value: amount}();\n  }\n\n  function _swapTokens(uint256 amount) private {\n    token.approve(address(uniswapRouter), amount);\n\n    address[] memory path = new address[](2);\n\n    path[0] = address(token);\n    path[1] = address(wrappedNative);\n\n    // omit revert, let's use those tokens on the next swap\n    try\n      uniswapRouter.swapExactTokensForTokens(\n        amount,\n        0,\n        path,\n        address(this),\n        block.timestamp // solhint-disable-line not-rely-on-time\n      )\n    {\n      //\n    } catch {\n      //\n    }\n  }\n\n  function _addTokensToLiquidity(uint256 tokensAmount) private {\n    uint256 wrappedNativeAmount = wrappedNative.balanceOf(address(this));\n\n    if (tokensAmount != 0 && wrappedNativeAmount != 0) {\n      token.approve(address(uniswapRouter), tokensAmount);\n\n      wrappedNative.approve(address(uniswapRouter), wrappedNativeAmount);\n\n      // omit revert, let's use those tokens on the next swap\n      try\n        uniswapRouter.addLiquidity(\n          address(token),\n          address(wrappedNative),\n          tokensAmount,\n          wrappedNativeAmount,\n          0,\n          0,\n          address(this),\n          block.timestamp // solhint-disable-line not-rely-on-time\n        )\n      {\n        //\n      } catch {\n        //\n      }\n    }\n  }\n\n  function _removeLiquidity() private {\n    uint256 liquidity = uniswapPair.balanceOf(address(this));\n\n    if (liquidity != 0) {\n      uniswapPair.approve(address(uniswapRouter), liquidity);\n\n      uniswapRouter.removeLiquidity(\n        address(token),\n        address(wrappedNative),\n        liquidity,\n        0,\n        0,\n        address(this),\n        block.timestamp // solhint-disable-line not-rely-on-time\n      );\n    }\n  }\n\n  // private functions (views)\n\n  function _calcTokensValue(uint256 amount) private view returns (uint256) {\n    address[] memory path = new address[](3);\n\n    path[0] = address(token);\n    path[1] = address(wrappedNative);\n    path[2] = settings.stableCoin;\n\n    uint256[] memory amounts = uniswapRouter.getAmountsOut(amount, path);\n\n    return amounts[2];\n  }\n\n  function _getLiquidityReserves()\n    private\n    view\n    returns (uint256 tokenReserve, uint256 wrappedNativeReserve)\n  {\n    (uint112 reserve0, uint112 reserve1, ) = uniswapPair.getReserves();\n\n    (tokenReserve, wrappedNativeReserve) = correctPairOrder\n      ? (reserve0, reserve1)\n      : (reserve1, reserve0);\n\n    return (tokenReserve, wrappedNativeReserve);\n  }\n}\n"
    },
    "src/core/erc20/IWrappedNative.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\nimport \"./IERC20.sol\";\n\n/**\n * @title Wrapped native (eg. WBNB, WETH) token interface\n *\n * @notice Based on https://github.com/Uniswap/uniswap-v2-periphery/blob/dda62473e2da448bc9cb8f4514dadda4aeede5f4/contracts/interfaces/IWETH.sol\n */\ninterface IWrappedNative is IERC20 {\n  // external functions\n\n  function deposit() external payable;\n\n  function withdraw(uint256 amount) external;\n}\n"
    },
    "src/uniswapV2/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\n/**\n * @title Uniswap v2 factory interface\n *\n * @notice Based on https://github.com/Uniswap/uniswap-v2-core/blob/4dd59067c76dea4a0e8e4bfdda41877a6b16dedc/contracts/interfaces/IUniswapV2Factory.sol\n */\ninterface IUniswapV2Factory {\n  // events\n\n  event PairCreated(\n    address indexed token0,\n    address indexed token1,\n    address pair,\n    uint256\n  );\n\n  // external functions\n\n  function createPair(address tokenA, address tokenB)\n    external\n    returns (address);\n\n  function setFeeTo(address) external;\n\n  function setFeeToSetter(address) external;\n\n  // external functions (views)\n\n  function feeTo() external view returns (address);\n\n  function feeToSetter() external view returns (address);\n\n  function getPair(address tokenA, address tokenB)\n    external\n    view\n    returns (address);\n\n  function allPairs(uint256) external view returns (address);\n\n  function allPairsLength() external view returns (uint256);\n}\n"
    },
    "src/uniswapV2/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/* solhint-disable func-name-mixedcase */\npragma solidity ^0.6.12;\n\nimport \"../core/erc20/IERC20.sol\";\n\n/**\n * @title Uniswap V2 pair interface\n *\n * @notice Based on https://github.com/Uniswap/uniswap-v2-core/blob/4dd59067c76dea4a0e8e4bfdda41877a6b16dedc/contracts/interfaces/IUniswapV2Pair.sol\n */\ninterface IUniswapV2Pair is IERC20 {\n  // events\n\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  // external functions\n\n  function initialize(address, address) external;\n\n  function mint(address to) external returns (uint256);\n\n  function burn(address to) external returns (uint256, uint256);\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  // external functions (views)\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (\n      uint112,\n      uint112,\n      uint32\n    );\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function kLast() external view returns (uint256);\n\n  // external functions (pure)\n\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n}\n"
    },
    "src/uniswapV2/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\nimport \"./IUniswapV2Router01.sol\";\n\n/**\n * @title Uniswap V2 router02 interface\n *\n * @notice Based on https://github.com/Uniswap/uniswap-v2-periphery/blob/dda62473e2da448bc9cb8f4514dadda4aeede5f4/contracts/interfaces/IUniswapV2Router02.sol\n */\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n  // external functions\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external;\n}\n"
    },
    "src/uniswapV2/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/* solhint-disable func-name-mixedcase */\npragma solidity ^0.6.12;\n\n/**\n * @title Uniswap V2 router01 interface\n *\n * @notice Based on https://github.com/Uniswap/uniswap-v2-periphery/blob/dda62473e2da448bc9cb8f4514dadda4aeede5f4/contracts/interfaces/IUniswapV2Router01.sol\n */\ninterface IUniswapV2Router01 {\n  // external functions\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256, uint256);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256, uint256);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256, uint256);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256, uint256);\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory);\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory);\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory);\n\n  // external functions (views)\n\n  function getAmountsOut(uint256 amountIn, address[] calldata path)\n    external\n    view\n    returns (uint256[] memory);\n\n  function getAmountsIn(uint256 amountOut, address[] calldata path)\n    external\n    view\n    returns (uint256[] memory);\n\n  // external functions (pure)\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256);\n\n  function factory() external pure returns (address);\n\n  function WETH() external pure returns (address);\n}\n"
    },
    "src/pancakeswap/PancakeRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/* solhint-disable */\npragma solidity ^0.6.12;\n\nimport \"../core/erc20/IERC20.sol\";\nimport \"../core/erc20/IWrappedNative.sol\";\nimport \"../core/math/SafeMathLib.sol\";\nimport \"../uniswapV2/IUniswapV2Factory.sol\";\nimport \"../uniswapV2/IUniswapV2Pair.sol\";\nimport \"../uniswapV2/IUniswapV2Router02.sol\";\nimport \"./PancakeLibrary.sol\";\nimport \"./PancakeTransferHelper.sol\";\n\n/**\n * @title Pancake router\n *\n * @notice Based on https://github.com/pancakeswap/pancake-swap-periphery/blob/d769a6d136b74fde82502ec2f9334acc1afc0732/contracts/PancakeRouter.sol\n */\ncontract PancakeRouter is IUniswapV2Router02 {\n  using SafeMathLib for uint256;\n\n  address public immutable override factory;\n  address public immutable override WETH;\n\n  // modifiers\n\n  modifier ensure(uint256 deadline) {\n    require(deadline >= block.timestamp, \"PancakeRouter: EXPIRED\");\n    _;\n  }\n\n  constructor(address _factory, address _WETH) public {\n    factory = _factory;\n    WETH = _WETH;\n  }\n\n  // external functions\n\n  receive() external payable {\n    assert(msg.sender == WETH);\n    // only accept ETH via fallback from the WETH contract\n  }\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    override\n    ensure(deadline)\n    returns (\n      uint256 amountA,\n      uint256 amountB,\n      uint256 liquidity\n    )\n  {\n    (amountA, amountB) = _addLiquidity(\n      tokenA,\n      tokenB,\n      amountADesired,\n      amountBDesired,\n      amountAMin,\n      amountBMin\n    );\n    address pair = PancakeLibrary.pairFor(factory, tokenA, tokenB);\n    PancakeTransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n    PancakeTransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n    liquidity = IUniswapV2Pair(pair).mint(to);\n  }\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable\n    override\n    ensure(deadline)\n    returns (\n      uint256 amountToken,\n      uint256 amountETH,\n      uint256 liquidity\n    )\n  {\n    (amountToken, amountETH) = _addLiquidity(\n      token,\n      WETH,\n      amountTokenDesired,\n      msg.value,\n      amountTokenMin,\n      amountETHMin\n    );\n    address pair = PancakeLibrary.pairFor(factory, token, WETH);\n    PancakeTransferHelper.safeTransferFrom(\n      token,\n      msg.sender,\n      pair,\n      amountToken\n    );\n    IWrappedNative(WETH).deposit{value: amountETH}();\n    assert(IWrappedNative(WETH).transfer(pair, amountETH));\n    liquidity = IUniswapV2Pair(pair).mint(to);\n    // refund dust eth, if any\n    if (msg.value > amountETH)\n      PancakeTransferHelper.safeTransferBNB(msg.sender, msg.value - amountETH);\n  }\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external override returns (uint256 amountToken, uint256 amountETH) {\n    address pair = PancakeLibrary.pairFor(factory, token, WETH);\n    uint256 value = approveMax ? uint256(-1) : liquidity;\n    IUniswapV2Pair(pair).permit(\n      msg.sender,\n      address(this),\n      value,\n      deadline,\n      v,\n      r,\n      s\n    );\n    (amountToken, amountETH) = removeLiquidityETH(\n      token,\n      liquidity,\n      amountTokenMin,\n      amountETHMin,\n      to,\n      deadline\n    );\n  }\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external override returns (uint256 amountA, uint256 amountB) {\n    address pair = PancakeLibrary.pairFor(factory, tokenA, tokenB);\n    uint256 value = approveMax ? uint256(-1) : liquidity;\n    IUniswapV2Pair(pair).permit(\n      msg.sender,\n      address(this),\n      value,\n      deadline,\n      v,\n      r,\n      s\n    );\n    (amountA, amountB) = removeLiquidity(\n      tokenA,\n      tokenB,\n      liquidity,\n      amountAMin,\n      amountBMin,\n      to,\n      deadline\n    );\n  }\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external override returns (uint256 amountETH) {\n    address pair = PancakeLibrary.pairFor(factory, token, WETH);\n    uint256 value = approveMax ? uint256(-1) : liquidity;\n    IUniswapV2Pair(pair).permit(\n      msg.sender,\n      address(this),\n      value,\n      deadline,\n      v,\n      r,\n      s\n    );\n    amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\n      token,\n      liquidity,\n      amountTokenMin,\n      amountETHMin,\n      to,\n      deadline\n    );\n  }\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external override ensure(deadline) returns (uint256[] memory amounts) {\n    amounts = PancakeLibrary.getAmountsOut(factory, amountIn, path);\n    require(\n      amounts[amounts.length - 1] >= amountOutMin,\n      \"PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n    );\n    PancakeTransferHelper.safeTransferFrom(\n      path[0],\n      msg.sender,\n      PancakeLibrary.pairFor(factory, path[0], path[1]),\n      amounts[0]\n    );\n    _swap(amounts, path, to);\n  }\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external override ensure(deadline) returns (uint256[] memory amounts) {\n    amounts = PancakeLibrary.getAmountsIn(factory, amountOut, path);\n    require(amounts[0] <= amountInMax, \"PancakeRouter: EXCESSIVE_INPUT_AMOUNT\");\n    PancakeTransferHelper.safeTransferFrom(\n      path[0],\n      msg.sender,\n      PancakeLibrary.pairFor(factory, path[0], path[1]),\n      amounts[0]\n    );\n    _swap(amounts, path, to);\n  }\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable\n    override\n    ensure(deadline)\n    returns (uint256[] memory amounts)\n  {\n    require(path[0] == WETH, \"PancakeRouter: INVALID_PATH\");\n    amounts = PancakeLibrary.getAmountsOut(factory, msg.value, path);\n    require(\n      amounts[amounts.length - 1] >= amountOutMin,\n      \"PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n    );\n    IWrappedNative(WETH).deposit{value: amounts[0]}();\n    assert(\n      IWrappedNative(WETH).transfer(\n        PancakeLibrary.pairFor(factory, path[0], path[1]),\n        amounts[0]\n      )\n    );\n    _swap(amounts, path, to);\n  }\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external override ensure(deadline) returns (uint256[] memory amounts) {\n    require(path[path.length - 1] == WETH, \"PancakeRouter: INVALID_PATH\");\n    amounts = PancakeLibrary.getAmountsIn(factory, amountOut, path);\n    require(amounts[0] <= amountInMax, \"PancakeRouter: EXCESSIVE_INPUT_AMOUNT\");\n    PancakeTransferHelper.safeTransferFrom(\n      path[0],\n      msg.sender,\n      PancakeLibrary.pairFor(factory, path[0], path[1]),\n      amounts[0]\n    );\n    _swap(amounts, path, address(this));\n    IWrappedNative(WETH).withdraw(amounts[amounts.length - 1]);\n    PancakeTransferHelper.safeTransferBNB(to, amounts[amounts.length - 1]);\n  }\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external override ensure(deadline) returns (uint256[] memory amounts) {\n    require(path[path.length - 1] == WETH, \"PancakeRouter: INVALID_PATH\");\n    amounts = PancakeLibrary.getAmountsOut(factory, amountIn, path);\n    require(\n      amounts[amounts.length - 1] >= amountOutMin,\n      \"PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n    );\n    PancakeTransferHelper.safeTransferFrom(\n      path[0],\n      msg.sender,\n      PancakeLibrary.pairFor(factory, path[0], path[1]),\n      amounts[0]\n    );\n    _swap(amounts, path, address(this));\n    IWrappedNative(WETH).withdraw(amounts[amounts.length - 1]);\n    PancakeTransferHelper.safeTransferBNB(to, amounts[amounts.length - 1]);\n  }\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable\n    override\n    ensure(deadline)\n    returns (uint256[] memory amounts)\n  {\n    require(path[0] == WETH, \"PancakeRouter: INVALID_PATH\");\n    amounts = PancakeLibrary.getAmountsIn(factory, amountOut, path);\n    require(amounts[0] <= msg.value, \"PancakeRouter: EXCESSIVE_INPUT_AMOUNT\");\n    IWrappedNative(WETH).deposit{value: amounts[0]}();\n    assert(\n      IWrappedNative(WETH).transfer(\n        PancakeLibrary.pairFor(factory, path[0], path[1]),\n        amounts[0]\n      )\n    );\n    _swap(amounts, path, to);\n    // refund dust eth, if any\n    if (msg.value > amounts[0])\n      PancakeTransferHelper.safeTransferBNB(msg.sender, msg.value - amounts[0]);\n  }\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external override ensure(deadline) {\n    PancakeTransferHelper.safeTransferFrom(\n      path[0],\n      msg.sender,\n      PancakeLibrary.pairFor(factory, path[0], path[1]),\n      amountIn\n    );\n    uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n    _swapSupportingFeeOnTransferTokens(path, to);\n    require(\n      IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >=\n        amountOutMin,\n      \"PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n    );\n  }\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable override ensure(deadline) {\n    require(path[0] == WETH, \"PancakeRouter: INVALID_PATH\");\n    uint256 amountIn = msg.value;\n    IWrappedNative(WETH).deposit{value: amountIn}();\n    assert(\n      IWrappedNative(WETH).transfer(\n        PancakeLibrary.pairFor(factory, path[0], path[1]),\n        amountIn\n      )\n    );\n    uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n    _swapSupportingFeeOnTransferTokens(path, to);\n    require(\n      IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >=\n        amountOutMin,\n      \"PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n    );\n  }\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external override ensure(deadline) {\n    require(path[path.length - 1] == WETH, \"PancakeRouter: INVALID_PATH\");\n    PancakeTransferHelper.safeTransferFrom(\n      path[0],\n      msg.sender,\n      PancakeLibrary.pairFor(factory, path[0], path[1]),\n      amountIn\n    );\n    _swapSupportingFeeOnTransferTokens(path, address(this));\n    uint256 amountOut = IERC20(WETH).balanceOf(address(this));\n    require(\n      amountOut >= amountOutMin,\n      \"PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n    );\n    IWrappedNative(WETH).withdraw(amountOut);\n    PancakeTransferHelper.safeTransferBNB(to, amountOut);\n  }\n\n  // public functions\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n    public\n    override\n    ensure(deadline)\n    returns (uint256 amountA, uint256 amountB)\n  {\n    address pair = PancakeLibrary.pairFor(factory, tokenA, tokenB);\n    IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity);\n    // send liquidity to pair\n    (uint256 amount0, uint256 amount1) = IUniswapV2Pair(pair).burn(to);\n    (address token0, ) = PancakeLibrary.sortTokens(tokenA, tokenB);\n    (amountA, amountB) = tokenA == token0\n      ? (amount0, amount1)\n      : (amount1, amount0);\n    require(amountA >= amountAMin, \"PancakeRouter: INSUFFICIENT_A_AMOUNT\");\n    require(amountB >= amountBMin, \"PancakeRouter: INSUFFICIENT_B_AMOUNT\");\n  }\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n    public\n    override\n    ensure(deadline)\n    returns (uint256 amountToken, uint256 amountETH)\n  {\n    (amountToken, amountETH) = removeLiquidity(\n      token,\n      WETH,\n      liquidity,\n      amountTokenMin,\n      amountETHMin,\n      address(this),\n      deadline\n    );\n    PancakeTransferHelper.safeTransfer(token, to, amountToken);\n    IWrappedNative(WETH).withdraw(amountETH);\n    PancakeTransferHelper.safeTransferBNB(to, amountETH);\n  }\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) public override ensure(deadline) returns (uint256 amountETH) {\n    (, amountETH) = removeLiquidity(\n      token,\n      WETH,\n      liquidity,\n      amountTokenMin,\n      amountETHMin,\n      address(this),\n      deadline\n    );\n    PancakeTransferHelper.safeTransfer(\n      token,\n      to,\n      IERC20(token).balanceOf(address(this))\n    );\n    IWrappedNative(WETH).withdraw(amountETH);\n    PancakeTransferHelper.safeTransferBNB(to, amountETH);\n  }\n\n  // public function (views)\n\n  function getAmountsOut(uint256 amountIn, address[] memory path)\n    public\n    view\n    override\n    returns (uint256[] memory amounts)\n  {\n    return PancakeLibrary.getAmountsOut(factory, amountIn, path);\n  }\n\n  function getAmountsIn(uint256 amountOut, address[] memory path)\n    public\n    view\n    override\n    returns (uint256[] memory amounts)\n  {\n    return PancakeLibrary.getAmountsIn(factory, amountOut, path);\n  }\n\n  // public function (pure)\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) public pure override returns (uint256 amountB) {\n    return PancakeLibrary.quote(amountA, reserveA, reserveB);\n  }\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) public pure override returns (uint256 amountOut) {\n    return PancakeLibrary.getAmountOut(amountIn, reserveIn, reserveOut);\n  }\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) public pure override returns (uint256 amountIn) {\n    return PancakeLibrary.getAmountIn(amountOut, reserveIn, reserveOut);\n  }\n\n  // private functions\n\n  function _addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin\n  ) private returns (uint256 amountA, uint256 amountB) {\n    // create the pair if it doesn't exist yet\n    if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\n      IUniswapV2Factory(factory).createPair(tokenA, tokenB);\n    }\n    (uint256 reserveA, uint256 reserveB) = PancakeLibrary.getReserves(\n      factory,\n      tokenA,\n      tokenB\n    );\n    if (reserveA == 0 && reserveB == 0) {\n      (amountA, amountB) = (amountADesired, amountBDesired);\n    } else {\n      uint256 amountBOptimal = PancakeLibrary.quote(\n        amountADesired,\n        reserveA,\n        reserveB\n      );\n      if (amountBOptimal <= amountBDesired) {\n        require(\n          amountBOptimal >= amountBMin,\n          \"PancakeRouter: INSUFFICIENT_B_AMOUNT\"\n        );\n        (amountA, amountB) = (amountADesired, amountBOptimal);\n      } else {\n        uint256 amountAOptimal = PancakeLibrary.quote(\n          amountBDesired,\n          reserveB,\n          reserveA\n        );\n        assert(amountAOptimal <= amountADesired);\n        require(\n          amountAOptimal >= amountAMin,\n          \"PancakeRouter: INSUFFICIENT_A_AMOUNT\"\n        );\n        (amountA, amountB) = (amountAOptimal, amountBDesired);\n      }\n    }\n  }\n\n  function _swap(\n    uint256[] memory amounts,\n    address[] memory path,\n    address _to\n  ) private {\n    for (uint256 i; i < path.length - 1; i++) {\n      (address input, address output) = (path[i], path[i + 1]);\n      (address token0, ) = PancakeLibrary.sortTokens(input, output);\n      uint256 amountOut = amounts[i + 1];\n      (uint256 amount0Out, uint256 amount1Out) = input == token0\n        ? (uint256(0), amountOut)\n        : (amountOut, uint256(0));\n      address to = i < path.length - 2\n        ? PancakeLibrary.pairFor(factory, output, path[i + 2])\n        : _to;\n      IUniswapV2Pair(PancakeLibrary.pairFor(factory, input, output)).swap(\n        amount0Out,\n        amount1Out,\n        to,\n        new bytes(0)\n      );\n    }\n  }\n\n  function _swapSupportingFeeOnTransferTokens(\n    address[] memory path,\n    address _to\n  ) private {\n    for (uint256 i; i < path.length - 1; i++) {\n      (address input, address output) = (path[i], path[i + 1]);\n      (address token0, ) = PancakeLibrary.sortTokens(input, output);\n      IUniswapV2Pair pair = IUniswapV2Pair(\n        PancakeLibrary.pairFor(factory, input, output)\n      );\n      uint256 amountInput;\n      uint256 amountOutput;\n      {\n        // scope to avoid stack too deep errors\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        (uint256 reserveInput, uint256 reserveOutput) = input == token0\n          ? (reserve0, reserve1)\n          : (reserve1, reserve0);\n        amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\n        amountOutput = PancakeLibrary.getAmountOut(\n          amountInput,\n          reserveInput,\n          reserveOutput\n        );\n      }\n      (uint256 amount0Out, uint256 amount1Out) = input == token0\n        ? (uint256(0), amountOutput)\n        : (amountOutput, uint256(0));\n      address to = i < path.length - 2\n        ? PancakeLibrary.pairFor(factory, output, path[i + 2])\n        : _to;\n      pair.swap(amount0Out, amount1Out, to, new bytes(0));\n    }\n  }\n}\n"
    },
    "src/pancakeswap/PancakeLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/* solhint-disable */\npragma solidity ^0.6.12;\n\nimport \"../core/math/SafeMathLib.sol\";\nimport \"../uniswapV2/IUniswapV2Pair.sol\";\nimport \"./PancakePair.sol\";\n\n/**\n * @title Pancake library\n *\n * @notice Based on https://github.com/pancakeswap/pancake-swap-periphery/blob/d769a6d136b74fde82502ec2f9334acc1afc0732/contracts/libraries/PancakeLibrary.sol\n */\nlibrary PancakeLibrary {\n  using SafeMathLib for uint256;\n\n  bytes32 private constant INIT_CODE_PAIR_HASH =\n    keccak256(abi.encodePacked(type(PancakePair).creationCode));\n\n  // internal functions (pure)\n\n  function sortTokens(address tokenA, address tokenB)\n    internal\n    pure\n    returns (address token0, address token1)\n  {\n    require(tokenA != tokenB, \"PancakeLibrary: IDENTICAL_ADDRESSES\");\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), \"PancakeLibrary: ZERO_ADDRESS\");\n  }\n\n  function pairFor(\n    address factory,\n    address tokenA,\n    address tokenB\n  ) internal pure returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = address(\n      uint256(\n        keccak256(\n          abi.encodePacked(\n            hex\"ff\",\n            factory,\n            keccak256(abi.encodePacked(token0, token1)),\n            INIT_CODE_PAIR_HASH\n          )\n        )\n      )\n    );\n  }\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) internal pure returns (uint256 amountB) {\n    require(amountA > 0, \"PancakeLibrary: INSUFFICIENT_AMOUNT\");\n    require(\n      reserveA > 0 && reserveB > 0,\n      \"PancakeLibrary: INSUFFICIENT_LIQUIDITY\"\n    );\n    amountB = amountA.mul(reserveB) / reserveA;\n  }\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) internal pure returns (uint256 amountOut) {\n    require(amountIn > 0, \"PancakeLibrary: INSUFFICIENT_INPUT_AMOUNT\");\n    require(\n      reserveIn > 0 && reserveOut > 0,\n      \"PancakeLibrary: INSUFFICIENT_LIQUIDITY\"\n    );\n    uint256 amountInWithFee = amountIn.mul(998);\n    uint256 numerator = amountInWithFee.mul(reserveOut);\n    uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n    amountOut = numerator / denominator;\n  }\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) internal pure returns (uint256 amountIn) {\n    require(amountOut > 0, \"PancakeLibrary: INSUFFICIENT_OUTPUT_AMOUNT\");\n    require(\n      reserveIn > 0 && reserveOut > 0,\n      \"PancakeLibrary: INSUFFICIENT_LIQUIDITY\"\n    );\n    uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n    uint256 denominator = reserveOut.sub(amountOut).mul(998);\n    amountIn = (numerator / denominator).add(1);\n  }\n\n  // internal functions (pure)\n\n  function getReserves(\n    address factory,\n    address tokenA,\n    address tokenB\n  ) internal view returns (uint256 reserveA, uint256 reserveB) {\n    (address token0, ) = sortTokens(tokenA, tokenB);\n    pairFor(factory, tokenA, tokenB);\n    (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(\n      pairFor(factory, tokenA, tokenB)\n    ).getReserves();\n    (reserveA, reserveB) = tokenA == token0\n      ? (reserve0, reserve1)\n      : (reserve1, reserve0);\n  }\n\n  function getAmountsOut(\n    address factory,\n    uint256 amountIn,\n    address[] memory path\n  ) internal view returns (uint256[] memory amounts) {\n    require(path.length >= 2, \"PancakeLibrary: INVALID_PATH\");\n    amounts = new uint256[](path.length);\n    amounts[0] = amountIn;\n    for (uint256 i; i < path.length - 1; i++) {\n      (uint256 reserveIn, uint256 reserveOut) = getReserves(\n        factory,\n        path[i],\n        path[i + 1]\n      );\n      amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n    }\n  }\n\n  function getAmountsIn(\n    address factory,\n    uint256 amountOut,\n    address[] memory path\n  ) internal view returns (uint256[] memory amounts) {\n    require(path.length >= 2, \"PancakeLibrary: INVALID_PATH\");\n    amounts = new uint256[](path.length);\n    amounts[amounts.length - 1] = amountOut;\n    for (uint256 i = path.length - 1; i > 0; i--) {\n      (uint256 reserveIn, uint256 reserveOut) = getReserves(\n        factory,\n        path[i - 1],\n        path[i]\n      );\n      amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n    }\n  }\n}\n"
    },
    "src/pancakeswap/PancakeTransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/* solhint-disable */\npragma solidity ^0.6.12;\n\n/**\n * @title Pancake transfer helper library\n *\n * @notice Based on https://github.com/pancakeswap/pancake-swap-lib/blob/0c16ece6edc575dc92076245badd62cddead47b3/contracts/utils/TransferHelper.sol\n */\nlibrary PancakeTransferHelper {\n  // internal functions\n\n  function safeApprove(\n    address token,\n    address to,\n    uint256 value\n  ) internal {\n    // bytes4(keccak256(bytes('approve(address,uint256)')));\n    (bool success, bytes memory data) = token.call(\n      abi.encodeWithSelector(0x095ea7b3, to, value)\n    );\n    require(\n      success && (data.length == 0 || abi.decode(data, (bool))),\n      \"TransferHelper: APPROVE_FAILED\"\n    );\n  }\n\n  function safeTransfer(\n    address token,\n    address to,\n    uint256 value\n  ) internal {\n    // bytes4(keccak256(bytes('transfer(address,uint256)')));\n    (bool success, bytes memory data) = token.call(\n      abi.encodeWithSelector(0xa9059cbb, to, value)\n    );\n    require(\n      success && (data.length == 0 || abi.decode(data, (bool))),\n      \"TransferHelper: TRANSFER_FAILED\"\n    );\n  }\n\n  function safeTransferFrom(\n    address token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n    (bool success, bytes memory data) = token.call(\n      abi.encodeWithSelector(0x23b872dd, from, to, value)\n    );\n    require(\n      success && (data.length == 0 || abi.decode(data, (bool))),\n      \"TransferHelper: TRANSFER_FROM_FAILED\"\n    );\n  }\n\n  function safeTransferBNB(address to, uint256 value) internal {\n    (bool success, ) = to.call{value: value}(new bytes(0));\n    require(success, \"TransferHelper: BNB_TRANSFER_FAILED\");\n  }\n}\n"
    },
    "src/pancakeswap/PancakePair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/* solhint-disable */\npragma solidity ^0.6.12;\n\nimport \"../core/erc20/IERC20.sol\";\nimport \"../core/math/SafeMathLib.sol\";\nimport \"../uniswapV2/IUniswapV2Factory.sol\";\nimport \"../uniswapV2/IUniswapV2Pair.sol\";\nimport \"./IPancakeCallee.sol\";\nimport \"./PancakeMath.sol\";\nimport \"./PancakeUQ112x112.sol\";\n\n/**\n * @title Pancake pair\n *\n * @notice Based on https://github.com/pancakeswap/pancake-swap-core/blob/3b214306770e86bc3a64e67c2b5bdb566b4e94a7/contracts/PancakePair.sol\n */\ncontract PancakePair is IUniswapV2Pair {\n  using SafeMathLib for uint256;\n  using PancakeUQ112x112 for uint224;\n\n  uint256 public constant override MINIMUM_LIQUIDITY = 10**3;\n  bytes32 public constant override PERMIT_TYPEHASH =\n    0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9; // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n  bytes32 public override DOMAIN_SEPARATOR;\n\n  string public override name = \"Pancake LPs\";\n  string public override symbol = \"Cake-LP\";\n  uint8 public override decimals = 18;\n  uint256 public override totalSupply;\n\n  mapping(address => uint256) public override balanceOf;\n  mapping(address => mapping(address => uint256)) public override allowance;\n  mapping(address => uint256) public override nonces;\n\n  address public override factory;\n  address public override token0;\n  address public override token1;\n\n  uint256 public override price0CumulativeLast;\n  uint256 public override price1CumulativeLast;\n  uint256 public override kLast;\n\n  bytes4 private constant SELECTOR =\n    bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n\n  uint112 private reserve0;\n  uint112 private reserve1;\n  uint32 private blockTimestampLast;\n  uint256 private unlocked = 1;\n\n  // modifiers\n\n  modifier lock() {\n    require(unlocked == 1, \"Pancake: LOCKED\");\n    unlocked = 0;\n    _;\n    unlocked = 1;\n  }\n\n  // events\n\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  constructor() public {\n    factory = msg.sender;\n\n    uint256 chainId;\n\n    assembly {\n      chainId := chainid()\n    }\n\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(name)),\n        keccak256(bytes(\"1\")),\n        chainId,\n        address(this)\n      )\n    );\n  }\n\n  // external functions\n\n  function initialize(address _token0, address _token1) external override {\n    require(msg.sender == factory, \"Pancake: FORBIDDEN\");\n    // sufficient check\n    token0 = _token0;\n    token1 = _token1;\n  }\n\n  function approve(address spender, uint256 value)\n    external\n    override\n    returns (bool)\n  {\n    _approve(msg.sender, spender, value);\n    return true;\n  }\n\n  function transfer(address to, uint256 value)\n    external\n    override\n    returns (bool)\n  {\n    _transfer(msg.sender, to, value);\n    return true;\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external override returns (bool) {\n    if (allowance[from][msg.sender] != uint256(-1)) {\n      allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n    }\n    _transfer(from, to, value);\n    return true;\n  }\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external override {\n    require(deadline >= block.timestamp, \"Pancake: EXPIRED\");\n    bytes32 digest = keccak256(\n      abi.encodePacked(\n        \"\\x19\\x01\",\n        DOMAIN_SEPARATOR,\n        keccak256(\n          abi.encode(\n            PERMIT_TYPEHASH,\n            owner,\n            spender,\n            value,\n            nonces[owner]++,\n            deadline\n          )\n        )\n      )\n    );\n    address recoveredAddress = ecrecover(digest, v, r, s);\n    require(\n      recoveredAddress != address(0) && recoveredAddress == owner,\n      \"Pancake: INVALID_SIGNATURE\"\n    );\n    _approve(owner, spender, value);\n  }\n\n  function mint(address to) external override lock returns (uint256 liquidity) {\n    (uint112 _reserve0, uint112 _reserve1, ) = getReserves();\n    // gas savings\n    uint256 balance0 = IERC20(token0).balanceOf(address(this));\n    uint256 balance1 = IERC20(token1).balanceOf(address(this));\n    uint256 amount0 = balance0.sub(_reserve0);\n    uint256 amount1 = balance1.sub(_reserve1);\n\n    bool feeOn = _mintFee(_reserve0, _reserve1);\n    uint256 _totalSupply = totalSupply;\n    // gas savings, must be defined here since totalSupply can update in _mintFee\n    if (_totalSupply == 0) {\n      liquidity = PancakeMath.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n      _mint(address(0), MINIMUM_LIQUIDITY);\n      // permanently lock the first MINIMUM_LIQUIDITY tokens\n    } else {\n      liquidity = PancakeMath.min(\n        amount0.mul(_totalSupply) / _reserve0,\n        amount1.mul(_totalSupply) / _reserve1\n      );\n    }\n    require(liquidity > 0, \"Pancake: INSUFFICIENT_LIQUIDITY_MINTED\");\n    _mint(to, liquidity);\n\n    _update(balance0, balance1, _reserve0, _reserve1);\n    if (feeOn) kLast = uint256(reserve0).mul(reserve1);\n    // reserve0 and reserve1 are up-to-date\n    emit Mint(msg.sender, amount0, amount1);\n  }\n\n  function burn(address to)\n    external\n    override\n    lock\n    returns (uint256 amount0, uint256 amount1)\n  {\n    (uint112 _reserve0, uint112 _reserve1, ) = getReserves();\n    // gas savings\n    address _token0 = token0;\n    // gas savings\n    address _token1 = token1;\n    // gas savings\n    uint256 balance0 = IERC20(_token0).balanceOf(address(this));\n    uint256 balance1 = IERC20(_token1).balanceOf(address(this));\n    uint256 liquidity = balanceOf[address(this)];\n\n    bool feeOn = _mintFee(_reserve0, _reserve1);\n    uint256 _totalSupply = totalSupply;\n    // gas savings, must be defined here since totalSupply can update in _mintFee\n    amount0 = liquidity.mul(balance0) / _totalSupply;\n    // using balances ensures pro-rata distribution\n    amount1 = liquidity.mul(balance1) / _totalSupply;\n    // using balances ensures pro-rata distribution\n    require(\n      amount0 > 0 && amount1 > 0,\n      \"Pancake: INSUFFICIENT_LIQUIDITY_BURNED\"\n    );\n    _burn(address(this), liquidity);\n    _safeTransfer(_token0, to, amount0);\n    _safeTransfer(_token1, to, amount1);\n    balance0 = IERC20(_token0).balanceOf(address(this));\n    balance1 = IERC20(_token1).balanceOf(address(this));\n\n    _update(balance0, balance1, _reserve0, _reserve1);\n    if (feeOn) kLast = uint256(reserve0).mul(reserve1);\n    // reserve0 and reserve1 are up-to-date\n    emit Burn(msg.sender, amount0, amount1, to);\n  }\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external override lock {\n    require(\n      amount0Out > 0 || amount1Out > 0,\n      \"Pancake: INSUFFICIENT_OUTPUT_AMOUNT\"\n    );\n    (uint112 _reserve0, uint112 _reserve1, ) = getReserves();\n    // gas savings\n    require(\n      amount0Out < _reserve0 && amount1Out < _reserve1,\n      \"Pancake: INSUFFICIENT_LIQUIDITY\"\n    );\n\n    uint256 balance0;\n    uint256 balance1;\n    {\n      // scope for _token{0,1}, avoids stack too deep errors\n      address _token0 = token0;\n      address _token1 = token1;\n      require(to != _token0 && to != _token1, \"Pancake: INVALID_TO\");\n      if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out);\n      // optimistically transfer tokens\n      if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out);\n      // optimistically transfer tokens\n      if (data.length > 0)\n        IPancakeCallee(to).pancakeCall(\n          msg.sender,\n          amount0Out,\n          amount1Out,\n          data\n        );\n      balance0 = IERC20(_token0).balanceOf(address(this));\n      balance1 = IERC20(_token1).balanceOf(address(this));\n    }\n    uint256 amount0In = balance0 > _reserve0 - amount0Out\n      ? balance0 - (_reserve0 - amount0Out)\n      : 0;\n    uint256 amount1In = balance1 > _reserve1 - amount1Out\n      ? balance1 - (_reserve1 - amount1Out)\n      : 0;\n    require(\n      amount0In > 0 || amount1In > 0,\n      \"Pancake: INSUFFICIENT_INPUT_AMOUNT\"\n    );\n    {\n      // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n      uint256 balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(2));\n      uint256 balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(2));\n      require(\n        balance0Adjusted.mul(balance1Adjusted) >=\n          uint256(_reserve0).mul(_reserve1).mul(1000**2),\n        \"Pancake: K\"\n      );\n    }\n\n    _update(balance0, balance1, _reserve0, _reserve1);\n    emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n  }\n\n  function skim(address to) external override lock {\n    address _token0 = token0;\n    // gas savings\n    address _token1 = token1;\n    // gas savings\n    _safeTransfer(\n      _token0,\n      to,\n      IERC20(_token0).balanceOf(address(this)).sub(reserve0)\n    );\n    _safeTransfer(\n      _token1,\n      to,\n      IERC20(_token1).balanceOf(address(this)).sub(reserve1)\n    );\n  }\n\n  function sync() external override lock {\n    _update(\n      IERC20(token0).balanceOf(address(this)),\n      IERC20(token1).balanceOf(address(this)),\n      reserve0,\n      reserve1\n    );\n  }\n\n  // public functions (views)\n\n  function getReserves()\n    public\n    view\n    override\n    returns (\n      uint112 _reserve0,\n      uint112 _reserve1,\n      uint32 _blockTimestampLast\n    )\n  {\n    _reserve0 = reserve0;\n    _reserve1 = reserve1;\n    _blockTimestampLast = blockTimestampLast;\n  }\n\n  // private functions\n\n  function _mint(address to, uint256 value) private {\n    totalSupply = totalSupply.add(value);\n    balanceOf[to] = balanceOf[to].add(value);\n    emit Transfer(address(0), to, value);\n  }\n\n  function _burn(address from, uint256 value) private {\n    balanceOf[from] = balanceOf[from].sub(value);\n    totalSupply = totalSupply.sub(value);\n    emit Transfer(from, address(0), value);\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 value\n  ) private {\n    allowance[owner][spender] = value;\n    emit Approval(owner, spender, value);\n  }\n\n  function _transfer(\n    address from,\n    address to,\n    uint256 value\n  ) private {\n    balanceOf[from] = balanceOf[from].sub(value);\n    balanceOf[to] = balanceOf[to].add(value);\n    emit Transfer(from, to, value);\n  }\n\n  function _safeTransfer(\n    address token,\n    address to,\n    uint256 value\n  ) private {\n    (bool success, bytes memory data) = token.call(\n      abi.encodeWithSelector(SELECTOR, to, value)\n    );\n    require(\n      success && (data.length == 0 || abi.decode(data, (bool))),\n      \"Pancake: TRANSFER_FAILED\"\n    );\n  }\n\n  function _update(\n    uint256 balance0,\n    uint256 balance1,\n    uint112 _reserve0,\n    uint112 _reserve1\n  ) private {\n    require(\n      balance0 <= uint112(-1) && balance1 <= uint112(-1),\n      \"Pancake: OVERFLOW\"\n    );\n    uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n    uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n    // overflow is desired\n    if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n      // * never overflows, and + overflow is desired\n      price0CumulativeLast +=\n        uint256(PancakeUQ112x112.encode(_reserve1).uqdiv(_reserve0)) *\n        timeElapsed;\n      price1CumulativeLast +=\n        uint256(PancakeUQ112x112.encode(_reserve0).uqdiv(_reserve1)) *\n        timeElapsed;\n    }\n    reserve0 = uint112(balance0);\n    reserve1 = uint112(balance1);\n    blockTimestampLast = blockTimestamp;\n    emit Sync(reserve0, reserve1);\n  }\n\n  function _mintFee(uint112 _reserve0, uint112 _reserve1)\n    private\n    returns (bool feeOn)\n  {\n    address feeTo = IUniswapV2Factory(factory).feeTo();\n    feeOn = feeTo != address(0);\n    uint256 _kLast = kLast;\n    // gas savings\n    if (feeOn) {\n      if (_kLast != 0) {\n        uint256 rootK = PancakeMath.sqrt(uint256(_reserve0).mul(_reserve1));\n        uint256 rootKLast = PancakeMath.sqrt(_kLast);\n        if (rootK > rootKLast) {\n          uint256 numerator = totalSupply.mul(rootK.sub(rootKLast));\n          uint256 denominator = rootK.mul(3).add(rootKLast);\n          uint256 liquidity = numerator / denominator;\n          if (liquidity > 0) _mint(feeTo, liquidity);\n        }\n      }\n    } else if (_kLast != 0) {\n      kLast = 0;\n    }\n  }\n}\n"
    },
    "src/pancakeswap/IPancakeCallee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\n/**\n * @title Pancake callee interfaces\n *\n * @notice Based on https://github.com/pancakeswap/pancake-swap-core/blob/3b214306770e86bc3a64e67c2b5bdb566b4e94a7/contracts/interfaces/IPancakeCallee.sol\n */\ninterface IPancakeCallee {\n  // external functions\n\n  function pancakeCall(\n    address sender,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "src/pancakeswap/PancakeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/* solhint-disable */\npragma solidity ^0.6.12;\n\n/**\n * @title Pancake math library\n *\n * @notice Based on https://github.com/pancakeswap/pancake-swap-core/blob/3b214306770e86bc3a64e67c2b5bdb566b4e94a7/contracts/libraries/Math.sol\n */\nlibrary PancakeMath {\n  // internal functions (pure)\n\n  function min(uint256 x, uint256 y) internal pure returns (uint256) {\n    return x < y ? x : y;\n  }\n\n  function sqrt(uint256 y) internal pure returns (uint256 z) {\n    if (y > 3) {\n      z = y;\n      uint256 x = y / 2 + 1;\n      while (x < z) {\n        z = x;\n        x = (y / x + x) / 2;\n      }\n    } else if (y != 0) {\n      z = 1;\n    }\n\n    return z;\n  }\n}\n"
    },
    "src/pancakeswap/PancakeUQ112x112.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/* solhint-disable */\npragma solidity ^0.6.12;\n\n/**\n * @title Pancake UQ112x112 library\n *\n * @notice Based on https://github.com/pancakeswap/pancake-swap-core/blob/3b214306770e86bc3a64e67c2b5bdb566b4e94a7/contracts/libraries/UQ112x112.sol\n */\nlibrary PancakeUQ112x112 {\n  uint224 internal constant Q112 = 2**112;\n\n  // internal functions (pure)\n\n  function encode(uint112 y) internal pure returns (uint224) {\n    return uint224(y) * Q112;\n  }\n\n  function uqdiv(uint224 x, uint112 y) internal pure returns (uint224) {\n    return x / uint224(y);\n  }\n}\n"
    },
    "src/pancakeswap/PancakeFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/* solhint-disable */\npragma solidity ^0.6.12;\n\nimport \"../uniswapV2/IUniswapV2Factory.sol\";\nimport \"../uniswapV2/IUniswapV2Pair.sol\";\nimport \"./PancakePair.sol\";\n\n/**\n * @title Pancake factory\n *\n * @notice Based on https://github.com/pancakeswap/pancake-swap-core/blob/3b214306770e86bc3a64e67c2b5bdb566b4e94a7/contracts/PancakeFactory.sol\n */\ncontract PancakeFactory is IUniswapV2Factory {\n  address public override feeTo;\n  address public override feeToSetter;\n\n  mapping(address => mapping(address => address)) public override getPair;\n  address[] public override allPairs;\n\n  constructor(address _feeToSetter) public {\n    feeToSetter = _feeToSetter;\n  }\n\n  // external functions\n\n  function createPair(address tokenA, address tokenB)\n    external\n    override\n    returns (address pair)\n  {\n    require(tokenA != tokenB, \"Pancake: IDENTICAL_ADDRESSES\");\n    (address token0, address token1) = tokenA < tokenB\n      ? (tokenA, tokenB)\n      : (tokenB, tokenA);\n    require(token0 != address(0), \"Pancake: ZERO_ADDRESS\");\n    require(getPair[token0][token1] == address(0), \"Pancake: PAIR_EXISTS\");\n    // single check is sufficient\n    bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n\n    pair = address(new PancakePair{salt: salt}());\n\n    IUniswapV2Pair(pair).initialize(token0, token1);\n    getPair[token0][token1] = pair;\n    getPair[token1][token0] = pair;\n    // populate mapping in the reverse direction\n    allPairs.push(pair);\n    emit PairCreated(token0, token1, pair, allPairs.length);\n  }\n\n  function setFeeTo(address _feeTo) external override {\n    require(msg.sender == feeToSetter, \"Pancake: FORBIDDEN\");\n    feeTo = _feeTo;\n  }\n\n  function setFeeToSetter(address _feeToSetter) external override {\n    require(msg.sender == feeToSetter, \"Pancake: FORBIDDEN\");\n    feeToSetter = _feeToSetter;\n  }\n\n  // external functions (views)\n\n  function allPairsLength() external view override returns (uint256) {\n    return allPairs.length;\n  }\n}\n"
    },
    "src/core/erc20/WrappedNativeMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./ERC20Mock.sol\";\nimport \"./IWrappedNative.sol\";\n\n/**\n * @title Wrapped native mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract WrappedNativeMock is IWrappedNative, ERC20Mock {\n  using SafeMathLib for uint256;\n\n  /**\n   * @dev Public constructor\n   */\n  constructor() public ERC20Mock() {\n    //\n  }\n\n  // external functions\n\n  function deposit() external payable override {\n    require(msg.value != 0, \"WrappedNativeMock#1\");\n\n    totalSupply = totalSupply.add(msg.value);\n    balanceOf[msg.sender] = balanceOf[msg.sender].add(msg.value);\n\n    emit Transfer(address(0), msg.sender, msg.value);\n  }\n\n  function withdraw(uint256 amount) external override {\n    require(amount <= balanceOf[msg.sender], \"WrappedNativeMock#2\");\n\n    totalSupply = totalSupply.sub(amount);\n    balanceOf[msg.sender] = balanceOf[msg.sender].sub(amount);\n\n    msg.sender.transfer(amount);\n\n    emit Transfer(msg.sender, address(0), amount);\n  }\n}\n"
    },
    "src/core/erc20/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"../math/SafeMathLib.sol\";\nimport \"./ERC20.sol\";\n\n/**\n * @title ERC20 token mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract ERC20Mock is ERC20 {\n  using SafeMathLib for uint256;\n\n  // metadata\n\n  string private constant TOKEN_NAME = \"Mocked token\";\n  string private constant TOKEN_SYMBOL = \"MOCK\";\n  uint8 private constant TOKEN_DECIMALS = 18; // 0.000000000000000000\n\n  uint256 public override totalSupply;\n  mapping(address => uint256) public override balanceOf;\n  mapping(address => mapping(address => uint256)) public override allowance;\n\n  /**\n   * @dev Public constructor\n   */\n  constructor() public ERC20(TOKEN_NAME, TOKEN_SYMBOL, TOKEN_DECIMALS) {\n    //\n  }\n\n  // external functions\n\n  function setBalance(address account, uint256 balance) external {\n    require(account != address(0), \"ERC20Mock#1\");\n\n    uint256 diff;\n\n    if (balance > balanceOf[account]) {\n      diff = balance.sub(balanceOf[account]);\n\n      totalSupply = totalSupply.add(diff);\n      balanceOf[account] = balanceOf[account].add(diff);\n\n      emit Transfer(address(0), account, diff);\n    } else {\n      diff = balanceOf[account].sub(balance);\n\n      totalSupply = totalSupply.sub(diff);\n      balanceOf[account] = balanceOf[account].sub(diff);\n\n      emit Transfer(account, address(0), diff);\n    }\n  }\n\n  function transfer(address recipient, uint256 amount)\n    external\n    override\n    returns (bool)\n  {\n    _transfer(msg.sender, recipient, amount);\n\n    return true;\n  }\n\n  function approve(address spender, uint256 amount)\n    external\n    override\n    returns (bool)\n  {\n    _approve(msg.sender, spender, amount);\n\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external override returns (bool) {\n    _transfer(sender, recipient, amount);\n\n    require(allowance[sender][msg.sender] >= amount, \"ERC20Mock#2\");\n\n    _approve(sender, msg.sender, allowance[sender][msg.sender].sub(amount));\n\n    return true;\n  }\n\n  // private functions\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) private {\n    require(sender != address(0), \"ERC20Mock#3\");\n\n    require(recipient != address(0), \"ERC20Mock#4\");\n\n    require(balanceOf[sender] >= amount, \"ERC20Mock#5\");\n\n    balanceOf[sender] = balanceOf[sender].sub(amount);\n    balanceOf[recipient] = balanceOf[recipient].add(amount);\n\n    emit Transfer(sender, recipient, amount);\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) private {\n    require(owner != address(0), \"ERC20Mock#6\");\n\n    require(spender != address(0), \"ERC20Mock#7\");\n\n    allowance[owner][spender] = amount;\n\n    emit Approval(owner, spender, amount);\n  }\n}\n"
    },
    "src/MetaheroDAO.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./core/lifecycle/Initializable.sol\";\nimport \"./core/math/MathLib.sol\";\nimport \"./core/math/SafeMathLib.sol\";\nimport \"./IMetaheroDAO.sol\";\nimport \"./MetaheroToken.sol\";\n\n/**\n * @title Metahero DAO\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract MetaheroDAO is Initializable, IMetaheroDAO {\n  using MathLib for uint256;\n  using SafeMathLib for uint256;\n\n  struct Settings {\n    uint256 minVotingPeriod;\n    uint256 snapshotWindow;\n  }\n\n  struct Proposal {\n    uint256 snapshotId;\n    bytes callData;\n    uint256 startsAt;\n    uint256 endsAt;\n    bool processed;\n    uint256 votesMinPercentage;\n    uint256 votesMinWeight;\n    uint256 votesYesWeight;\n    uint256 votesNoWeight;\n    uint256 votesCount;\n    mapping(address => uint8) votes; // 1 - yes, 2 - no\n  }\n\n  struct WeightsHistory {\n    uint256[] weights;\n    uint256[] snapshotIds;\n  }\n\n  // globals\n\n  uint256 private constant MAX_VOTES_MIN_PERCENTAGE = 75; // 75%\n\n  /**\n   * @return operator address\n   */\n  address public operator;\n\n  /**\n   * @return token address\n   */\n  MetaheroToken public token;\n\n  /**\n   * @return settings object\n   */\n  Settings public settings;\n\n  mapping(uint256 => Proposal) private proposals;\n  mapping(address => WeightsHistory) private membersWeightsHistory;\n  WeightsHistory private totalWeightsHistory;\n  uint256 private proposalCounter;\n  uint256 private snapshotBaseTimestamp;\n\n  // events\n\n  /**\n   * @dev Emitted the contract is initialized\n   * @param token token address\n   * @param operator operator address\n   * @param minVotingPeriod min voting period\n   * @param snapshotWindow snapshot window\n   * @param snapshotBaseTimestamp snapshot base timestamp\n   */\n  event Initialized(\n    address token,\n    address operator,\n    uint256 minVotingPeriod,\n    uint256 snapshotWindow,\n    uint256 snapshotBaseTimestamp\n  );\n\n  /**\n   * @dev Emitted the proposal is created\n   * @param proposalId proposal id\n   * @param callData token call data\n   * @param snapshotId snapshot id\n   * @param startsAt starts at\n   * @param endsAt ends at\n   * @param votesMinPercentage votes min percentage\n   * @param votesMinWeight votes min weight\n   */\n  event ProposalCreated(\n    uint256 proposalId,\n    uint256 snapshotId,\n    bytes callData,\n    uint256 startsAt,\n    uint256 endsAt,\n    uint256 votesMinPercentage,\n    uint256 votesMinWeight\n  );\n\n  /**\n   * @dev Emitted the proposal is processed\n   * @param proposalId proposal id\n   * @param votesYesWeight votes yes weight\n   * @param votesNoWeight votes no weight\n   */\n  event ProposalProcessed(\n    uint256 proposalId,\n    uint256 votesYesWeight,\n    uint256 votesNoWeight\n  );\n\n  /**\n   * @dev Emitted the vote is submitted\n   * @param proposalId proposal id\n   * @param member member address\n   * @param vote where `1` eq yes and `2` eq no\n   */\n  event VoteSubmitted(uint256 proposalId, address member, uint8 vote);\n\n  // modifiers\n\n  /**\n   * @dev Throws if msg.sender is not the operator\n   */\n  modifier onlyOperator() {\n    require(\n      msg.sender == operator,\n      \"MetaheroDAO#1\" // msg.sender is not the operator\n    );\n\n    _;\n  }\n\n  /**\n   * @dev Throws if msg.sender is not the token\n   */\n  modifier onlyToken() {\n    require(\n      msg.sender == address(token),\n      \"MetaheroDAO#2\" // msg.sender is not the token\n    );\n\n    _;\n  }\n\n  /**\n   * @dev Public constructor\n   */\n  constructor() public Initializable() {\n    //\n  }\n\n  // external functions\n\n  /**\n   * @dev Initializes the contract\n   * @param token_ token address\n   * @param operator_ custom operator address\n   * @param minVotingPeriod min voting period\n   * @param snapshotWindow snapshot window\n   */\n  function initialize(\n    address token_,\n    address operator_,\n    uint256 minVotingPeriod,\n    uint256 snapshotWindow\n  ) external onlyInitializer {\n    require(\n      token_ != address(0),\n      \"MetaheroDAO#3\" // token is the zero address\n    );\n\n    require(\n      minVotingPeriod != 0,\n      \"MetaheroDAO#4\" // min voting period is zero\n    );\n\n    require(\n      snapshotWindow != 0,\n      \"MetaheroDAO#5\" // snapshot window is zero\n    );\n\n    token = MetaheroToken(token_);\n\n    if (operator_ == address(0)) {\n      operator_ = token.owner();\n    }\n\n    operator = operator_;\n\n    settings.minVotingPeriod = minVotingPeriod;\n    settings.snapshotWindow = snapshotWindow;\n\n    snapshotBaseTimestamp = block.timestamp; // solhint-disable-line not-rely-on-time\n\n    emit Initialized(\n      token_,\n      operator_,\n      minVotingPeriod,\n      snapshotWindow,\n      snapshotBaseTimestamp\n    );\n  }\n\n  /**\n   * @notice Called by a token to sync a dao member\n   * @param member member address\n   * @param memberWeight member weight\n   * @param totalWeight all members weight\n   */\n  function syncMember(\n    address member,\n    uint256 memberWeight,\n    uint256 totalWeight\n  ) external override onlyToken {\n    uint256 snapshotId = _getSnapshotIdAt(block.timestamp); // solhint-disable-line not-rely-on-time\n\n    _setMemberWeight(member, memberWeight, snapshotId);\n\n    _setTotalWeight(totalWeight, snapshotId);\n  }\n\n  /**\n   * @notice Called by a token to sync a dao members\n   * @param memberA member A address\n   * @param memberAWeight member A weight\n   * @param memberB member B address\n   * @param memberBWeight member B weight\n   * @param totalWeight all members weight\n   */\n  function syncMembers(\n    address memberA,\n    uint256 memberAWeight,\n    address memberB,\n    uint256 memberBWeight,\n    uint256 totalWeight\n  ) external override onlyToken {\n    uint256 snapshotId = _getSnapshotIdAt(block.timestamp); // solhint-disable-line not-rely-on-time\n\n    _setMemberWeight(memberA, memberAWeight, snapshotId);\n\n    _setMemberWeight(memberB, memberBWeight, snapshotId);\n\n    _setTotalWeight(totalWeight, snapshotId);\n  }\n\n  /**\n   * @dev Removes all token fees\n   */\n  function removeAllTokenFees() external onlyOperator {\n    token.updateFees(\n      MetaheroToken.Fees(0, 0),\n      MetaheroToken.Fees(0, 0),\n      MetaheroToken.Fees(0, 0)\n    );\n  }\n\n  /**\n   * @dev Removes token lp fees\n   */\n  function removeTokenLPFees() external onlyOperator {\n    (\n      MetaheroToken.Fees memory burnFees,\n      MetaheroToken.Fees memory lpFees,\n      MetaheroToken.Fees memory rewardsFees,\n\n    ) = token.settings();\n\n    require(\n      lpFees.sender != 0 || lpFees.recipient != 0,\n      \"MetaheroDAO#6\" // already removed\n    );\n\n    token.updateFees(\n      MetaheroToken.Fees(\n        burnFees.sender.add(lpFees.sender),\n        burnFees.recipient.add(lpFees.recipient)\n      ),\n      MetaheroToken.Fees(0, 0), // remove lp fees\n      rewardsFees\n    );\n  }\n\n  /**\n   * @dev Excludes token account\n   * @param account account address\n   * @param excludeSenderFromFee exclude sender from fee\n   * @param excludeRecipientFromFee exclude recipient from fee\n   */\n  function excludeTokenAccount(\n    address account,\n    bool excludeSenderFromFee,\n    bool excludeRecipientFromFee\n  ) external onlyOperator {\n    token.excludeAccount(\n      account,\n      excludeSenderFromFee,\n      excludeRecipientFromFee\n    );\n  }\n\n  /**\n   * @dev Creates proposal\n   * @param callData token call data\n   * @param startsIn starts in\n   * @param endsIn ends in\n   * @param votesMinPercentage votes min percentage\n   */\n  function createProposal(\n    bytes calldata callData,\n    uint256 startsIn,\n    uint256 endsIn,\n    uint256 votesMinPercentage\n  ) external onlyOperator {\n    require(\n      endsIn > startsIn,\n      \"MetaheroDAO#7\" // `ends in` should be higher than `starts in`\n    );\n\n    require(\n      endsIn.sub(startsIn) >= settings.minVotingPeriod,\n      \"MetaheroDAO#8\" // voting period is too short\n    );\n\n    proposalCounter++;\n\n    uint256 proposalId = proposalCounter;\n    uint256 snapshotId = _getSnapshotIdAt(block.timestamp); // solhint-disable-line not-rely-on-time\n    uint256 startsAt = startsIn.add(block.timestamp); // solhint-disable-line not-rely-on-time\n    uint256 endsAt = endsIn.add(block.timestamp); // solhint-disable-line not-rely-on-time\n    uint256 votesMinWeight;\n\n    if (votesMinPercentage != 0) {\n      require(\n        votesMinPercentage <= MAX_VOTES_MIN_PERCENTAGE,\n        \"MetaheroDAO#9\" // invalid votes min percentage\n      );\n\n      votesMinWeight = _getTotalWeightOnSnapshot(snapshotId).percent(\n        votesMinPercentage\n      );\n    }\n\n    proposals[proposalId].snapshotId = snapshotId;\n    proposals[proposalId].callData = callData;\n    proposals[proposalId].startsAt = startsAt;\n    proposals[proposalId].endsAt = endsAt;\n    proposals[proposalId].votesMinPercentage = votesMinPercentage;\n    proposals[proposalId].votesMinWeight = votesMinWeight;\n\n    emit ProposalCreated(\n      proposalId,\n      snapshotId,\n      callData,\n      startsAt,\n      endsAt,\n      votesMinPercentage,\n      votesMinWeight\n    );\n  }\n\n  /**\n   * @dev Processes proposal\n   * @param proposalId proposal id\n   */\n  function processProposal(uint256 proposalId) external {\n    Proposal memory proposal = proposals[proposalId];\n\n    require(\n      proposal.snapshotId != 0,\n      \"MetaheroDAO#10\" // proposal not found\n    );\n\n    require(\n      proposal.endsAt <= block.timestamp, // solhint-disable-line not-rely-on-time\n      \"MetaheroDAO#11\"\n    );\n\n    require(\n      !proposal.processed,\n      \"MetaheroDAO#12\" // already processed\n    );\n\n    if (\n      proposal.callData.length > 0 &&\n      proposal.votesYesWeight > proposal.votesNoWeight &&\n      proposal.votesYesWeight >= proposal.votesMinWeight\n    ) {\n      (bool success, ) = address(token).call(proposal.callData); // solhint-disable-line avoid-low-level-calls\n\n      require(\n        success,\n        \"MetaheroDAO#13\" // call failed\n      );\n    }\n\n    proposals[proposalId].processed = true;\n\n    emit ProposalProcessed(\n      proposalId,\n      proposal.votesYesWeight,\n      proposal.votesNoWeight\n    );\n  }\n\n  /**\n   * @dev Submits vote\n   * @param proposalId proposal id\n   * @param vote where `1` eq yes and `2` eq no\n   */\n  function submitVote(uint256 proposalId, uint8 vote) external {\n    Proposal memory proposal = proposals[proposalId];\n\n    require(\n      proposal.snapshotId != 0,\n      \"MetaheroDAO#14\" // proposal not found\n    );\n\n    require(\n      proposal.startsAt <= block.timestamp, // solhint-disable-line not-rely-on-time\n      \"MetaheroDAO#15\"\n    );\n\n    require(\n      proposal.endsAt > block.timestamp, // solhint-disable-line not-rely-on-time\n      \"MetaheroDAO#16\"\n    );\n\n    require(vote == 1 || vote == 2, \"MetaheroDAO#17\");\n\n    require(proposals[proposalId].votes[msg.sender] == 0, \"MetaheroDAO#18\");\n\n    uint256 memberWeight = _getMemberWeightOnSnapshot(\n      msg.sender,\n      proposal.snapshotId\n    );\n\n    require(memberWeight != 0, \"MetaheroDAO#19\");\n\n    if (vote == 1) {\n      // yes vote\n      proposals[proposalId].votesYesWeight = proposal.votesYesWeight.add(\n        memberWeight\n      );\n    }\n\n    if (vote == 2) {\n      // no vote\n      proposals[proposalId].votesNoWeight = proposal.votesNoWeight.add(\n        memberWeight\n      );\n    }\n\n    proposals[proposalId].votesCount = proposal.votesCount.add(1);\n    proposals[proposalId].votes[msg.sender] = vote;\n\n    emit VoteSubmitted(proposalId, msg.sender, vote);\n  }\n\n  // external functions (views)\n\n  function getProposal(uint256 proposalId)\n    external\n    view\n    returns (\n      uint256 snapshotId,\n      bytes memory callData,\n      uint256 startsAt,\n      uint256 endsAt,\n      bool processed,\n      uint256 votesMinPercentage,\n      uint256 votesMinWeight,\n      uint256 votesYesWeight,\n      uint256 votesNoWeight,\n      uint256 votesCount\n    )\n  {\n    {\n      snapshotId = proposals[proposalId].snapshotId;\n      callData = proposals[proposalId].callData;\n      startsAt = proposals[proposalId].startsAt;\n      endsAt = proposals[proposalId].endsAt;\n      processed = proposals[proposalId].processed;\n      votesMinPercentage = proposals[proposalId].votesMinPercentage;\n      votesMinWeight = proposals[proposalId].votesMinWeight;\n      votesYesWeight = proposals[proposalId].votesYesWeight;\n      votesNoWeight = proposals[proposalId].votesNoWeight;\n      votesCount = proposals[proposalId].votesCount;\n    }\n\n    return (\n      snapshotId,\n      callData,\n      startsAt,\n      endsAt,\n      processed,\n      votesMinPercentage,\n      votesMinWeight,\n      votesYesWeight,\n      votesNoWeight,\n      votesCount\n    );\n  }\n\n  function getMemberProposalVote(address member, uint256 proposalId)\n    external\n    view\n    returns (uint8)\n  {\n    return proposals[proposalId].votes[member];\n  }\n\n  function getCurrentSnapshotId() external view returns (uint256) {\n    return _getSnapshotIdAt(block.timestamp); // solhint-disable-line not-rely-on-time\n  }\n\n  function getSnapshotIdAt(uint256 timestamp) external view returns (uint256) {\n    return _getSnapshotIdAt(timestamp);\n  }\n\n  function getCurrentMemberWeight(address member)\n    external\n    view\n    returns (uint256)\n  {\n    return\n      _getMemberWeightOnSnapshot(\n        member,\n        _getSnapshotIdAt(block.timestamp) // solhint-disable-line not-rely-on-time\n      );\n  }\n\n  function getMemberWeightOnSnapshot(address member, uint256 snapshotId)\n    external\n    view\n    returns (uint256)\n  {\n    return _getMemberWeightOnSnapshot(member, snapshotId);\n  }\n\n  function getCurrentTotalWeight() external view returns (uint256) {\n    return\n      _getTotalWeightOnSnapshot(\n        _getSnapshotIdAt(block.timestamp) // solhint-disable-line not-rely-on-time\n      );\n  }\n\n  function getTotalWeightOnSnapshot(uint256 snapshotId)\n    external\n    view\n    returns (uint256)\n  {\n    return _getTotalWeightOnSnapshot(snapshotId);\n  }\n\n  // private functions\n\n  function _setMemberWeight(\n    address member,\n    uint256 memberWeight,\n    uint256 snapshotId\n  ) private {\n    uint256 snapshotIdsLen = membersWeightsHistory[member].snapshotIds.length;\n\n    if (snapshotIdsLen == 0) {\n      membersWeightsHistory[member].weights.push(memberWeight);\n      membersWeightsHistory[member].snapshotIds.push(snapshotId);\n    } else {\n      uint256 snapshotIdsLastIndex = snapshotIdsLen - 1;\n\n      if (\n        membersWeightsHistory[member].snapshotIds[snapshotIdsLastIndex] ==\n        snapshotId\n      ) {\n        membersWeightsHistory[member].weights[\n          snapshotIdsLastIndex\n        ] = memberWeight;\n      } else {\n        membersWeightsHistory[member].weights.push(memberWeight);\n        membersWeightsHistory[member].snapshotIds.push(snapshotId);\n      }\n    }\n  }\n\n  function _setTotalWeight(uint256 totalWeight, uint256 snapshotId) private {\n    uint256 snapshotIdsLen = totalWeightsHistory.snapshotIds.length;\n\n    if (snapshotIdsLen == 0) {\n      totalWeightsHistory.weights.push(totalWeight);\n      totalWeightsHistory.snapshotIds.push(snapshotId);\n    } else {\n      uint256 snapshotIdsLastIndex = snapshotIdsLen - 1;\n\n      if (totalWeightsHistory.snapshotIds[snapshotIdsLastIndex] == snapshotId) {\n        totalWeightsHistory.weights[snapshotIdsLastIndex] = totalWeight;\n      } else {\n        totalWeightsHistory.weights.push(totalWeight);\n        totalWeightsHistory.snapshotIds.push(snapshotId);\n      }\n    }\n  }\n\n  // private functions (views)\n\n  function _getSnapshotIdAt(uint256 timestamp) private view returns (uint256) {\n    return\n      snapshotBaseTimestamp >= timestamp\n        ? 0\n        : timestamp.sub(snapshotBaseTimestamp).div(settings.snapshotWindow).add(\n          1\n        );\n  }\n\n  function _getMemberWeightOnSnapshot(address member, uint256 snapshotId)\n    private\n    view\n    returns (uint256 result)\n  {\n    WeightsHistory memory weightsHistory = membersWeightsHistory[member];\n    uint256 len = weightsHistory.snapshotIds.length;\n\n    if (len != 0) {\n      for (uint256 pos = 1; pos <= len; pos++) {\n        uint256 index = len - pos;\n\n        if (weightsHistory.snapshotIds[index] <= snapshotId) {\n          result = membersWeightsHistory[member].weights[index];\n          break;\n        }\n      }\n    } else {\n      (, uint256 holdingBalance, uint256 totalRewards) = token\n        .getBalanceSummary(member);\n\n      if (totalRewards != 0) {\n        result = holdingBalance;\n      }\n    }\n\n    return result;\n  }\n\n  function _getTotalWeightOnSnapshot(uint256 snapshotId)\n    private\n    view\n    returns (uint256 result)\n  {\n    uint256 len = totalWeightsHistory.snapshotIds.length;\n\n    if (len != 0) {\n      for (uint256 pos = 1; pos <= len; pos++) {\n        uint256 index = len - pos;\n\n        if (totalWeightsHistory.snapshotIds[index] <= snapshotId) {\n          result = totalWeightsHistory.weights[index];\n          break;\n        }\n      }\n    } else {\n      (, uint256 totalHolding, , ) = token.summary();\n\n      result = totalHolding;\n    }\n\n    return result;\n  }\n}\n"
    },
    "src/MetaheroDAOMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./IMetaheroDAO.sol\";\n\n/**\n * @title Metahero DAO mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract MetaheroDAOMock is IMetaheroDAO {\n  // events\n\n  event MemberWeightSynced(address member, uint256 memberWeight);\n\n  event TotalWeightSynced(uint256 totalWeight);\n\n  // external functions\n\n  function syncMember(\n    address member,\n    uint256 memberWeight,\n    uint256 totalWeight\n  ) external override {\n    emit MemberWeightSynced(member, memberWeight);\n\n    emit TotalWeightSynced(totalWeight);\n  }\n\n  function syncMembers(\n    address memberA,\n    uint256 memberAWeight,\n    address memberB,\n    uint256 memberBWeight,\n    uint256 totalWeight\n  ) external override {\n    emit MemberWeightSynced(memberA, memberAWeight);\n\n    emit MemberWeightSynced(memberB, memberBWeight);\n\n    emit TotalWeightSynced(totalWeight);\n  }\n}\n"
    },
    "src/core/math/MathLibMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./MathLib.sol\";\n\n/**\n * @title Math library mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract MathLibMock {\n  using MathLib for uint256;\n\n  // external functions (pure)\n\n  function percent(uint256 a, uint256 p) external pure returns (uint256) {\n    return a.percent(p);\n  }\n}\n"
    },
    "src/core/lifecycle/InitializableMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./Initializable.sol\";\n\n/**\n * @title Initializable mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract InitializableMock is Initializable {\n  // events\n\n  event Triggered();\n\n  /**\n   * @dev Public constructor\n   */\n  constructor() public Initializable() {\n    //\n  }\n\n  // external functions\n\n  function triggerOnlyInitializer() external onlyInitializer {\n    emit Triggered();\n  }\n}\n"
    },
    "src/core/math/SafeMathLibMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./SafeMathLib.sol\";\n\n/**\n * @title Safe math library mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract SafeMathLibMock {\n  using SafeMathLib for uint256;\n\n  // external functions (pure)\n\n  function add(uint256 a, uint256 b) external pure returns (uint256) {\n    return a.add(b);\n  }\n\n  function sub(uint256 a, uint256 b) external pure returns (uint256) {\n    return a.sub(b);\n  }\n\n  function mul(uint256 a, uint256 b) external pure returns (uint256) {\n    return a.mul(b);\n  }\n\n  function div(uint256 a, uint256 b) external pure returns (uint256) {\n    return a.div(b);\n  }\n}\n"
    },
    "src/core/access/OwnedMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./Owned.sol\";\n\n/**\n * @title Owned mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract OwnedMock is Owned {\n  // events\n\n  event Triggered();\n\n  /**\n   * @dev Public constructor\n   */\n  constructor() public Owned() {\n    //\n  }\n\n  // external functions\n\n  function triggerOnlyOwner() external onlyOwner {\n    emit Triggered();\n  }\n}\n"
    },
    "src/core/access/LockableMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./Lockable.sol\";\n\n/**\n * @title Lockable mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract LockableMock is Lockable {\n  // events\n\n  event Triggered();\n\n  /**\n   * @dev Public constructor\n   */\n  constructor() public {\n    //\n  }\n\n  // external functions\n\n  function setLocked(bool locked_) external {\n    locked = locked_;\n  }\n\n  // external functions\n\n  function triggerLock() external lock {\n    emit Triggered();\n  }\n\n  function triggerLockOrThrowError() external lockOrThrowError {\n    emit Triggered();\n  }\n}\n"
    },
    "src/core/access/ControlledMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./Controlled.sol\";\n\n/**\n * @title Controlled mock\n *\n * @author Stanisław Głogowski <stan@metahero.io>\n */\ncontract ControlledMock is Controlled {\n  // events\n\n  event Triggered();\n\n  /**\n   * @dev Public constructor\n   */\n  constructor() public Controlled() {\n    //\n  }\n\n  // external functions\n\n  function triggerOnlyController() external onlyController {\n    emit Triggered();\n  }\n\n  function initializeController(address controller_) external {\n    _initializeController(controller_);\n  }\n\n  function setController(address controller_) external {\n    _setController(controller_);\n  }\n\n  function removeController() external {\n    _removeController();\n  }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "istanbul",
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}